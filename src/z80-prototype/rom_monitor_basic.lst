                        ; --------------------------------------
                        ; zasm: assemble "rom_monitor_basic.asm"
                        ; date: 2020-02-05 20:35:37
                        ; --------------------------------------


                        ; Calling convention used in this program
                        ; ---------------------------------------
                        ;
                        ; Unless otherwise noted, the first parameter, and the return value are stored as follows:
                        ; 8 bits: L
                        ; 16 bits: HL
                        ; 32 bits: DEHL
                        ;
                        ; Additional parameters are passed on the stack, left-to-right.
                        ; Parameters and return values larger than 32 bits are passed on the stack (return value
                        ; space set up by caller as a hidden first argument).
                        ; Callee saves/restores any modified registers.
                        ; Caller pops arguments after call returns.
                        ; AF registers are scratch (caller preserves, if needed).
                        
                        ; same as 'bin', except that the default fill byte for 'defs' etc. is 0xff
                        #target rom
                        
                        #include "z80.inc"
                        ; Macros and definitions related to the Z80 and its instruction set
                        
                        M_deref_hl	macro
                            ; hl = (hl)
                            ; destroys a
                            ld	    a, (hl)
                            inc	    hl
                            ld	    h, (hl)
                            ld	    l, a
                            endm
                        #include "7segdisp.inc"
0000:                   PORT_SEG0	equ 0x00	    ; port address for first 7-segment display element
0010:                   PORT_SEG1	equ 0x10	    ; port address for second 7-segment display element
                        
                        ; 7-segment display map
                        ;      A
                        ;  +-------+
                        ;  |       |
                        ; F|       |B
                        ;  |   G   |
                        ;  +-------+
                        ;  |       |
                        ; E|       |C
                        ;  |   D   |
                        ;  +-------+  .DP
                        
                        ; These values are the bit masks.
0001:                   SEG_A		equ 0x01	; segment A
0002:                   SEG_B		equ 0x02	; segment B
0004:                   SEG_C		equ 0x04	; segment C
0008:                   SEG_D		equ 0x08	; segment D
0010:                   SEG_E		equ 0x10	; segment E
0020:                   SEG_F		equ 0x20	; segment F
0040:                   SEG_G		equ 0x40	; segment G
0080:                   SEG_DP		equ 0x80	; decimal point
                        
                        ; These are the bit numbers (useful for bit, set, and res instructions).
0000:                   SEG_IDX_A	equ 0
0001:                   SEG_IDX_B	equ 1
0002:                   SEG_IDX_C	equ 2
0003:                   SEG_IDX_D	equ 3
0004:                   SEG_IDX_E	equ 4
0005:                   SEG_IDX_F	equ 5
0006:                   SEG_IDX_G	equ 6
0007:                   SEG_IDX_DP	equ 7
                        #include "joystick.inc"
0000:                   PORT_JOY0	equ 0x00	    ; port address for first joystick (read-only)
0010:                   PORT_JOY1	equ 0x10	    ; port address for second joystick (read-only)
                        
                        ; Bit masks for the values in the joystick status register.
                        ; These bits are active-low (normally high).
0001:                   JOY_UP		equ 0x01
0002:                   JOY_DOWN	equ 0x02
0004:                   JOY_LEFT	equ 0x04
0008:                   JOY_RIGHT	equ 0x08
0010:                   JOY_FIRE	equ 0x10
0020:                   JOY_RESERVED1	equ 0x20
0040:                   JOY_RESERVED2	equ 0x40
0080:                   JOY_RESERVED3	equ 0x80
                        
                        ; The bit numbers (useful for bit, set, and res instructions).
0000:                   JOY_IDX_UP	equ 0
0001:                   JOY_IDX_DOWN	equ 1
0002:                   JOY_IDX_LEFT	equ 2
0003:                   JOY_IDX_RIGHT	equ 3
0004:                   JOY_IDX_FIRE	equ 4
                        #include "z84c20.inc"
                        ; The Z84C20 is the Z80's PIO peripheral. See um0081.pdf for documentation.
                        
0030:                   PORT_PIOBASE	equ 0x30		; base port address for PIO chip
0030:                   PORT_PIOADAT	equ PORT_PIOBASE	; port address for PIO port A, data register
0031:                   PORT_PIOBDAT	equ PORT_PIOBASE + 1    ; port address for PIO port B, data register
0032:                   PORT_PIOACTL	equ PORT_PIOBASE + 2    ; port address for PIO port A, control register
0033:                   PORT_PIOBCTL	equ PORT_PIOBASE + 3    ; port address for PIO port B, control register
                        
                        ; PIO Control Register commands
0000:                   PIOC_IVEC	equ 0x00	; OR in the high 7 bits of the interrupt vector
000F:                   PIOC_MODE	equ 0x0F	; OR in the desired PIOMODE_xxx setting
0007:                   PIOC_ICTL	equ 0x07	; OR in the desired PIOICTL_xxx settings
                        
                        ; PIOC_MODE values
0000:                   PIOMODE_OUTPUT	equ 0x00
0040:                   PIOMODE_INPUT	equ 0x40
0080:                   PIOMODE_BIDIREC	equ 0x80
00C0:                   PIOMODE_CONTROL	equ 0xC0	; next control byte written must be the IO direction byte
                        				; 1 = input, 0 = output
                        
                        ; PIOC_ICTL values
0080:                   PIOICTL_INTENA	equ 0x80	; enable interrupts
0000:                   PIOICTL_INTDIS	equ 0x00	; disable interrupts
0040:                   PIOICTL_AND	equ 0x40	; AND inputs together for port monitoring interrupt
0000:                   PIOICTL_OR	equ 0x00	; OR inputs together for port monitoring interrupt
0020:                   PIOICTL_HIGH	equ 0x20	; interrupt on high (1) inputs
0000:                   PIOICTL_LOW	equ 0x00	; interrupt on low (0) inputs
0010:                   PIOICTL_MASKNXT equ 0x10	; next control byte written must be the input interrupt mask
                        				; 1 = input masked, 0 = input enabled
                        
                        M_pio_reset	macro
                            ld	    a, PIOC_MODE | PIOMODE_INPUT
                            out	    (PORT_PIOACTL), a
                            out	    (PORT_PIOBCTL), a
                            ld	    a, PIOC_ICTL | PIOICTL_INTDIS
                            out	    (PORT_PIOACTL), a
                            out	    (PORT_PIOBCTL), a
                            endm
                        #include "z84c30.inc"
                        ; The Z84C30 is the Z80's CTC peripheral. See um0081.pdf for documentation.
                        
0040:                   PORT_CTCBASE	equ 0x40		; base port address for CTC chip
0040:                   PORT_CTCIVEC	equ PORT_CTCBASE	; port address for Interrupt Vector Register
0040:                   PORT_CTC0	equ PORT_CTCBASE	; port address for CTC channel 0
0041:                   PORT_CTC1	equ PORT_CTCBASE + 1	; port address for CTC channel 1
0042:                   PORT_CTC2	equ PORT_CTCBASE + 2	; port address for CTC channel 2
0043:                   PORT_CTC3	equ PORT_CTCBASE + 3	; port address for CTC channel 3
                        
                        ; CTC Channel Control Word bits
0080:                   CTC_INTENA	equ 0x80		; enable interrupts
0000:                   CTC_INTDIS	equ 0x00		; disable interrupts
0040:                   CTC_MODECTR	equ 0x40		; COUNTER mode
0000:                   CTC_MODETMR	equ 0x00		; TIMER mode
0020:                   CTC_SCALE256	equ 0x20		; prescale by 256
0000:                   CTC_SCALE16	equ 0x00		; prescale by 16
0010:                   CTC_RISING	equ 0x10		; CLK/TRG on rising edges
0000:                   CTC_FALLING	equ 0x00		; CLK/TRG on falling edges
0008:                   CTC_CLKTRG	equ 0x08		; CLK/TRG pulse starts timer
0000:                   CTC_AUTO	equ 0x00		; automatic timer start after loading time constant
0004:                   CTC_TIMENXT	equ 0x04		; next control byte written is the time constant
0002:                   CTC_RESET	equ 0x02		; software reset
0001:                   CTC_CONTROL	equ 0x01		; always set to indicate this is a control word, not IVEC 
                        
                        M_ctc_reset	macro
                            ld	    a, CTC_CONTROL | CTC_RESET | CTC_INTDIS
                            out	    (PORT_CTC0), a
                            out	    (PORT_CTC1), a
                            out	    (PORT_CTC2), a
                            out	    (PORT_CTC3), a
                            endm
                        #include "z84c40.inc"
                        ; The Z84C40 is the Z80's SIO peripheral. See um0081.pdf for documentation.
                        
0020:                   PORT_SIOBASE	    equ 0x20		    ; base port address for SIO chip
0020:                   PORT_SIOADAT	    equ PORT_SIOBASE	    ; port address for SIO port A, data register
0021:                   PORT_SIOBDAT	    equ PORT_SIOBASE + 1    ; port address for SIO port B, data register
0022:                   PORT_SIOACTL	    equ PORT_SIOBASE + 2    ; port address for SIO port A, control register
0023:                   PORT_SIOBCTL	    equ PORT_SIOBASE + 3    ; port address for SIO port B, control register
                        
                        ; WR0 "CRC Reset Code" values (bits 7-6)
0000:                   SIOWR0_CRC_NOP		equ 0x00	    ; no CRC reset code
0040:                   SIOWR0_CRC_RST_RX_CHK	equ 1 << 6	    ; reset RX CRC checker
0080:                   SIOWR0_CRC_RST_TX_GEN	equ 2 << 6	    ; reset TX CRC generator
00C0:                   SIOWR0_CRC_RST_TX_UNDR  equ 3 << 6	    ; reset TX underrun/EOM latch
                        
                        ; WR0 "Command" values (bits 5-3)
0000:                   SIOWR0_CMD_NOP		equ 0x00	    ; no command
0008:                   SIOWR0_CMD_SND_ABRT	equ 1 << 3	    ; send abort (SDLC only)
0010:                   SIOWR0_CMD_RST_EXTINT	equ 2 << 3	    ; reset external/status interrupts
0018:                   SIOWR0_CMD_RST_CHAN	equ 3 << 3	    ; reset channel
0020:                   SIOWR0_CMD_INTENA_NXTRX	equ 4 << 3	    ; enable interrupt on next receive character
0028:                   SIOWR0_CMD_RST_TXINTPND equ 5 << 3	    ; reset TX interrupt pending
0030:                   SIOWR0_CMD_RST_ERR	equ 6 << 3	    ; reset error latches
0038:                   SIOWR0_CMD_INTRETN	equ 7 << 3	    ; return from interrupt (not needed with Z80)
                        
                        ; WR0 "Pointer" values (bits 2-0)
0000:                   SIOWR0_PTR_R0		equ 0x00	    ; set pointer to register 0
0001:                   SIOWR0_PTR_R1		equ 0x01	    ; set pointer to register 1
0002:                   SIOWR0_PTR_R2		equ 0x02	    ; set pointer to register 2
0003:                   SIOWR0_PTR_R3		equ 0x03	    ; set pointer to register 3
0004:                   SIOWR0_PTR_R4		equ 0x04	    ; set pointer to register 4
0005:                   SIOWR0_PTR_R5		equ 0x05	    ; set pointer to register 5
0006:                   SIOWR0_PTR_R6		equ 0x06	    ; set pointer to register 6
0007:                   SIOWR0_PTR_R7		equ 0x07	    ; set pointer to register 7
                        
                        ; WR1 interrupt & wait/ready control bits
0001:                   SIOWR1_EXTINTENA	equ 0x01	    ; external/status interrupt enable
0002:                   SIOWR1_TXINTENA		equ 0x02	    ; TX interrupt enable
0004:                   SIOWR1_STATIVEC		equ 0x04	    ; status affects interrupt vector (set in ch. B only)
0000:                   SIOWR1_RXINT_DISABLE	equ 0 << 3	    ; RX interrupts disabled
0008:                   SIOWR1_RXINT_FIRST	equ 1 << 3	    ; RX interrupt on first character
0010:                   SIOWR1_RXINT_ALLPRTY	equ 2 << 3	    ; RX interrupt on all characters, parity err is SR cond
0018:                   SIOWR1_RXINT_ALLNPRTY	equ 3 << 3	    ; RX interrupt on all characters, parity err no intr
                        ; bits 7-5 are for WAIT/READY functions, which we don't use (always write as 0)
                        
                        ; WR2 is the interrupt vector register (set in channel B only)
                        
                        ; WR3 receiver logic control bits
0001:                   SIOWR3_RXENA		equ 0x01	    ; receiver enable
0002:                   SIOWR3_SYNC_INHIBIT	equ 0x02	    ; sync character load inhibit
0004:                   SIOWR3_ADDR_SRCHMODE	equ 0x04	    ; address search mode
0008:                   SIOWR3_RXCRCENA		equ 0x08	    ; receiver CRC enable
0010:                   SIOWR3_ENTER_HUNT	equ 0x10	    ; enter hunt phase
0020:                   SIOWR3_AUTO_ENABLES	equ 0x20	    ; auto enables (DCD/CTS are RX/TX enables)
0000:                   SIOWR3_RX_5_BITS	equ 0 << 6	    ; receive 5 bits/character
0040:                   SIOWR3_RX_7_BITS	equ 1 << 6	    ; receive 7 bits/character
0080:                   SIOWR3_RX_6_BITS	equ 2 << 6	    ; receive 6 bits/character
00C0:                   SIOWR3_RX_8_BITS	equ 3 << 6	    ; receive 8 bits/character
                        
                        ; WR4 RX/TX configuration (set first before WR1, WR3, WR5, WR6, and WR7)
0001:                   SIOWR4_PARITY		equ 0x01	    ; parity on/off
0002:                   SIOWR4_PRTY_EVEN	equ 0x02	    ; even parity
0000:                   SIOWR4_PRTY_ODD		equ 0x00	    ; odd parity
0000:                   SIOWR4_TXSTOP_SYNC	equ 0 << 2	    ; synchronous mode (no TX stop bits)
0004:                   SIOWR4_TXSTOP_1		equ 1 << 2	    ; 1 TX stop bit
0008:                   SIOWR4_TXSTOP_1_5	equ 2 << 2	    ; 1.5 TX stop bits
000C:                   SIOWR4_TXSTOP_2		equ 3 << 2	    ; 2 TX stop bits
                        ; bits 5-4 set the sync modes, which we don't use (always write as 0)
0000:                   SIOWR4_CLK_x1		equ 0 << 6	    ; data rate x1 = clock rate
0040:                   SIOWR4_CLK_x16		equ 1 << 6	    ; data rate x16 = clock rate
0080:                   SIOWR4_CLK_x32		equ 2 << 6	    ; data rate x32 = clock rate
00C0:                   SIOWR4_CLK_x64		equ 3 << 6	    ; data rate x64 = clock rate
                        
                        ; WR5 transmitter logic control bits
0001:                   SIOWR5_TXCRCENA		equ 0x01	    ; transmitter CRC enable
0002:                   SIOWR5_RTS		equ 0x02	    ; request to send
0004:                   SIOWR5_CRC16_SDLC	equ 0x04	    ; CRC-16 vs. SDLC polynomial
0008:                   SIOWR5_TXENA		equ 0x08	    ; transmitter enable
0010:                   SIOWR5_SND_BRK		equ 0x10	    ; send break
0000:                   SIOWR5_TX_5_BITS	equ 0 << 5	    ; transmit 5 bits/character
0020:                   SIOWR5_TX_7_BITS	equ 1 << 5	    ; transmit 7 bits/character
0040:                   SIOWR5_TX_6_BITS	equ 2 << 5	    ; transmit 6 bits/character
0060:                   SIOWR5_TX_8_BITS	equ 3 << 5	    ; transmit 8 bits/character
0080:                   SIOWR5_DTR		equ 0x80	    ; data terminal ready
                        
                        ; WR6 transmitter sync register for use in synchronous modes, which we don't use
                        ; WR7 receiver sync register for use in synchronous modes, which we don't use
                        
                        ; RR0 status bits (mostly normal operation)
0001:                   SIORR0_RCA		equ 0x01	    ; RX character available
0002:                   SIORR0_INTPND		equ 0x02	    ; interrupt pending (channel A only)
0004:                   SIORR0_TBE		equ 0x04	    ; TX buffer empty
0008:                   SIORR0_DCD		equ 0x08	    ; latched DCD input bit
0010:                   SIORR0_SYNC		equ 0x10	    ; latched SYNC input bit (hunt in SDLC)
0020:                   SIORR0_CTS		equ 0x20	    ; latched CTS input bit
0040:                   SIORR0_TX_UNDR		equ 0x40	    ; TX underrun / end of message
0080:                   SIORR0_BRK_ABRT		equ 0x80	    ; break/abort detected
                        ; As bit numbers, useful for the "bit" instruction, to test individual bit flags
0000:                   SIORR0_IDX_RCA		equ 0
0001:                   SIORR0_IDX_INTPND	equ 1
0002:                   SIORR0_IDX_TBE		equ 2
0003:                   SIORR0_IDX_DCD		equ 3
0004:                   SIORR0_IDX_SYNC		equ 4
0005:                   SIORR0_IDX_CTS		equ 5
0006:                   SIORR0_IDX_TX_UNDR	equ 6
0007:                   SIORR0_IDX_BRK_ABRT	equ 7
                        
                        ; RR1 status bits (mostly errors)
0001:                   SIORR1_ALLSENT		equ 0x01	    ; all characters fully sent
                        ; bits 3-1 are SDLC-only
0010:                   SIORR1_PRTYERR		equ 0x10	    ; parity error
0020:                   SIORR1_ROE		equ 0x20	    ; RX overrun error
0040:                   SIORR1_CRCFRMERR	equ 0x40	    ; CRC/framing error
                        ; bit 7 is SDLC-only
                        
                        ; RR2 is the interrupt vector register (read from channel B only)
                        ; - if "Status Affects Vector" bit is set, this will be the current vector value,
                        ;   modified by whatever interrupt conditions are pending
                        
                        M_sio_reset	macro
                            ld	    a, SIOWR0_CMD_RST_CHAN
                            out	    (PORT_SIOACTL), a
                            out	    (PORT_SIOBCTL), a
                            endm
                        #include "ascii.inc"
0000:                   ASC_NUL	equ 0x00
0001:                   ASC_SOH	equ 0x01
0004:                   ASC_EOT	equ 0x04
0006:                   ASC_ACK	equ 0x06
0007:                   ASC_BEL	equ 0x07
0008:                   ASC_BS	equ 0x08
0009:                   ASC_HT	equ 0x09
000A:                   ASC_LF	equ 0x0A
000D:                   ASC_CR	equ 0x0D
0015:                   ASC_NAK	equ 0x15
001B:                   ASC_ESC	equ 0x1B
                        
                        ; some macros that we have to declare before use
                        M_sio_puts  macro str
                            ; Careful: destroys HL
                            ld	    hl, &str
                            call    sio_puts
                            endm
                        
                        M_sio_putc  macro ch
                            ; Careful: destroys L
                            ld	    l, &ch
                            call    sio_putc
                            endm
                        
                        ; 128KB Static RAM - AS6C1008-55PCN
                        ; The first 8KB is shadowed by the EPROM.
                        ; The next 56KB is mapped from 0x2000-0xFFFF.
                        ; The top 64KB is not addressable (A16 tied low).
                        
                        ; We map our RAM area high so that our data fields don't clobber low memory where we're
                        ; likely to be loading programs.
FC00:                   #data RAM, 0xFC00, 0x400
                        ; define static variables here
                        
                        ; 128KB Flash ROM - SST39SF010A
                        ; The first 8KB is mapped from 0-0x1FFF.
0000:                   #code ROM, 0, 0x2000
                        
                        ; reset vector
0000:                   RST0::
0000: 31FFFF   [10]         ld	    sp, RAM_end-1
                            ; reset peripherals
                            M_pio_reset
0003: 3E4F     [17]         ld	    a, PIOC_MODE | PIOMODE_INPUT
0005: D332     [28]         out	    (PORT_PIOACTL), a
0007: D333     [39]         out	    (PORT_PIOBCTL), a
0009: 3E07     [46]         ld	    a, PIOC_ICTL | PIOICTL_INTDIS
000B: D332     [57]         out	    (PORT_PIOACTL), a
000D: D333     [68]         out	    (PORT_PIOBCTL), a
                            M_sio_reset
000F: 3E18     [75]         ld	    a, SIOWR0_CMD_RST_CHAN
0011: D322     [86]         out	    (PORT_SIOACTL), a
0013: D323     [97]         out	    (PORT_SIOBCTL), a
                            M_ctc_reset
0015: 3E03     [104]        ld	    a, CTC_CONTROL | CTC_RESET | CTC_INTDIS
0017: D340     [115]        out	    (PORT_CTC0), a
0019: D341     [126]        out	    (PORT_CTC1), a
001B: D342     [137]        out	    (PORT_CTC2), a
001D: D343     [148]        out	    (PORT_CTC3), a
                            ; clear 7-segment display
001F: CD6B03   [165]        call    seg_init
                            ; initialize peripherals
0022: CD5000   [182]        call    ctc_init	    ; need to set up CTC to get SIO working (need baud rate gen)
0025: CD6100   [199]        call    sio_init
                            ; print startup banner
                            M_sio_puts startup_msg
                            ; Careful: destroys HL
0028: 213100   [209]        ld	    hl, startup_msg
002B: CD3C03   [226]        call    sio_puts
002E: C37D00   [236]        jp	    cmd_loop
                        
0031:                   startup_msg::
0031: 0D0A5A38              .text   ASC_CR, ASC_LF, "Z80MON/BASIC v1 ", __date__
0035: 304D4F4E          
0039: 2F424153          
003D: 49432076          
0041: 31203230          
0045: 32302D30          
0049: 322D3035          
                            ; Falling through...
004D:                   crlf::
004D: 0D0A00                .text   ASC_CR, ASC_LF, ASC_NUL
                        
                        ; void ctc_init()
                        #local
0050:                   ctc_init::
                            ; channel 0 is the baud rate generator for serial 0
0050: 3E57     [ 7]         ld	    a, CTC_CONTROL | CTC_RESET | CTC_TIMENXT | CTC_RISING | CTC_MODECTR
0052: D340     [18]         out	    (PORT_CTC0), a
0054: 3E03     [25]         ld	    a, 3	    ; 1.8432MHz divided by 3 is 614.4kHz (SIO at x16 gives 38400 baud)
0056: D340     [36]         out	    (PORT_CTC0), a
                            ; channel 1 is the baud rate generator for serial 1
0058: 3E57     [43]         ld	    a, CTC_CONTROL | CTC_RESET | CTC_TIMENXT | CTC_RISING | CTC_MODECTR
005A: D341     [54]         out	    (PORT_CTC1), a
005C: 3E03     [61]         ld	    a, 3	    ; 1.8432MHz divided by 3 is 614.4kHz (SIO at x16 gives 38400 baud)
005E: D341     [72]         out	    (PORT_CTC1), a
0060: C9       [82]         ret
                        #endlocal
                        
                        ; void sio_init()
                        #local
0061:                   sio_init::
0061: E5       [11]         push    hl
0062: C5       [22]         push    bc
                            ; configure SIO port A
0063: 012207   [32]         ld	    bc, 0x0700 | PORT_SIOACTL
0066: 217600   [42]         ld	    hl, sioA_cfg
0069: EDB3     [58|21]      otir
                            ; configure SIO port B
006B: 012307   [68]         ld	    bc, 0x0700 | PORT_SIOBCTL
006E: 217600   [78]         ld	    hl, sioB_cfg
0071: EDB3     [94|21]      otir
0073: C1       [104]        pop	    bc
0074: E1       [114]        pop	    hl
0075: C9       [124]        ret
0076:                   sioA_cfg:
0076:                   sioB_cfg:
0076: 18                    .byte SIOWR0_CMD_RST_CHAN
0077: 04                    .byte SIOWR0_PTR_R4
0078: 44                    .byte SIOWR4_TXSTOP_1 | SIOWR4_CLK_x16
                            ; No need to set up WR1/WR2, as they are only used for interrupts
0079: 03                    .byte SIOWR0_PTR_R3
007A: C1                    .byte SIOWR3_RXENA | SIOWR3_RX_8_BITS
007B: 05                    .byte SIOWR0_PTR_R5
007C: EA                    .byte SIOWR5_RTS | SIOWR5_TXENA | SIOWR5_TX_8_BITS | SIOWR5_DTR
                            ; No need to set up WR6/WR7, as they are only used for synchronous modes
                        #endlocal
                        
                        ; void cmd_loop()
                        #local
007D:                   cmd_loop::
007D: E5       [11]         push    hl
007E: C5       [22]         push    bc
007F:                   prompt:
                            M_sio_putc '>'
                            ; Careful: destroys L
007F: 2E3E     [ 7]         ld	    l, '>'
0081: CD3203   [24]         call    sio_putc
0084:                   nextByte:
0084: CD4402   [17]         call    sio_getc
                            ; map input byte to upper case
0087: CDF601   [34]         call    toupper
                            ; switch on input byte, and dispatch to appropriate subroutine
008A: 7D       [38]         ld	    a, l
008B: 21A700   [48]         ld	    hl, cmd_chars
008E: 010700   [58]         ld	    bc, num_cmds
0091: EDB1     [74|21]      cpir
0093: 20EF     [81|86]      jr	    nz, nextByte
0095: 21AE00   [91]         ld	    hl, cmd_procs
                            ; add 2 * (num_cmds - 1 - c) to hl
0098: 3E06     [98]         ld	    a, num_cmds-1
009A: 91       [102]        sub	    c
009B: 87       [106]        add	    a
009C: 4F       [110]        ld	    c, a
009D: 09       [121]        add	    hl, bc
                            M_deref_hl
                            ; hl = (hl)
                            ; destroys a
009E: 7E       [128]        ld	    a, (hl)
009F: 23       [134]        inc	    hl
00A0: 66       [141]        ld	    h, (hl)
00A1: 6F       [145]        ld	    l, a
                            ; call hl
00A2: CDF301   [162]        call    jp_hl
00A5: 18D8     [174]        jr	    prompt
                        
00A7:                   cmd_chars:
00A7: 01424352              .byte ASC_SOH,'B','C','R','I','O',ASC_CR
00AB: 494F0D            
0007:                   num_cmds	equ $-cmd_chars
00AE:                   cmd_procs:
00AE: BC00                  .word cmd_do_packet
00B0: 4901                  .word cmd_do_basic
00B2: 5701                  .word cmd_do_call
00B4: 8601                  .word cmd_do_reset
00B6: 9001                  .word cmd_do_input
00B8: B501                  .word cmd_do_output
00BA: E201                  .word cmd_do_cr
                        #endlocal
                        
                        #local
00BC:                   cmd_do_packet::
00BC: E5       [11]         push    hl
00BD: C5       [22]         push    bc
00BE: D5       [33]         push    de
                            ; get packet type
00BF: CD4402   [50]         call    sio_getc
00C2: 7D       [54]         ld	    a, l
00C3: FE57     [61]         cp	    'W'
00C5: 2811     [68|73]      jr	    z, doWrite
00C7: FE43     [75]         cp	    'C'
00C9: 284E     [82|87]      jr	    z, doCall
                            ; unrecognized packet type!
                            ; might be nice to consume everything up to EOT, but how long should we wait?
00CB:                   failure:
00CB: 2E4E     [ 7]         ld	    l, 'N'
00CD: 1802     [19]         jr	    putcAndDone
00CF:                   success:
00CF: 2E41     [ 7]         ld	    l, 'A'
00D1:                   putcAndDone:
00D1: CD3203   [17]         call    sio_putc
00D4:                   done:
00D4: D1       [10]         pop	    de
00D5: C1       [20]         pop	    bc
00D6: E1       [30]         pop	    hl
00D7: C9       [40]         ret
                        
00D8:                   doWrite:
                            ; Write packet consists of:
                            ;	'W'
                            ;	2-byte address
                            ;	2-byte length
                            ;	data bytes
                            ;	checksum byte
                            ;	EOT
                            ; place address in de and ix
00D8: CD4402   [17]         call    sio_getc
00DB: 5D       [21]         ld	    e, l
00DC: CD4402   [38]         call    sio_getc
00DF: 55       [42]         ld	    d, l
00E0: D5       [53]         push    de
00E1: DDE1     [67]         pop	    ix
                            ; place length in bc
00E3: CD4402   [84]         call    sio_getc
00E6: 4D       [88]         ld	    c, l
00E7: CD4402   [105]        call    sio_getc
00EA: 45       [109]        ld	    b, l
                            ; get a checksum started
00EB: 3E57     [116]        ld	    a, 'W'
00ED: 83       [120]        add	    e
00EE: 82       [124]        add	    d
00EF: 81       [128]        add	    c
00F0: 80       [132]        add	    b
                            ; keep running checksum in d
00F1: 57       [136]        ld	    d, a
                            ; read data bytes
00F2:                   writeLoop:
                            ; test bc against 0
00F2: AF       [ 4]         xor	    a		    ; resets carry flag, sets a=0
00F3: 67       [ 8]         ld	    h, a
00F4: 6F       [12]         ld	    l, a	    ; set hl=0
00F5: ED42     [27]         sbc	    hl, bc	    ; test bc against 0
00F7: 280E     [34|39]      jr	    z, writeDataDone
00F9: 0B       [40]         dec	    bc
00FA: CD4402   [57]         call    sio_getc	    ; l = next byte
00FD: DD7500   [76]         ld	    (ix), l
0100: DD23     [86]         inc	    ix
                            ; checksum data byte
0102: 7A       [90]         ld	    a, d
0103: 85       [94]         add	    l
0104: 57       [98]         ld	    d, a
0105: 18EB     [110]        jr	    writeLoop
0107:                   writeDataDone:
0107: CD4402   [17]         call    sio_getc	    ; l = incoming checksum
010A: 5D       [21]         ld	    e, l
010B: CD4402   [38]         call    sio_getc	    ; expecting an EOT
010E: 7D       [42]         ld	    a, l
010F: FE04     [49]         cp	    ASC_EOT
0111: 20B8     [56|61]      jr	    nz, failure
                            ; validate checksum
0113: 7A       [60]         ld	    a, d
0114: BB       [64]         cp	    e
0115: 28B8     [71|76]      jr	    z, success
0117: 18B2     [83]         jr	    failure
                        
0119:                   doCall:
                            ; Call packet consists of:
                            ;	'C'
                            ;	2-byte address
                            ;	checksum byte
                            ;	EOT
                            ; place address in bc
0119: CD4402   [17]         call    sio_getc
011C: 4D       [21]         ld	    c, l
011D: CD4402   [38]         call    sio_getc
0120: 45       [42]         ld	    b, l
0121: CD4402   [59]         call    sio_getc	    ; l = incoming checksum
0124: 5D       [63]         ld	    e, l
0125: CD4402   [80]         call    sio_getc	    ; expecting an EOT
0128: 7D       [84]         ld	    a, l
0129: FE04     [91]         cp	    ASC_EOT
012B: 209E     [98|103]     jr	    nz, failure
                            ; calculate checksum
012D: 3E43     [105]        ld	    a, 'C'
012F: 81       [109]        add	    c
0130: 80       [113]        add	    b
                            ; validate checksum
0131: BB       [117]        cp	    e
0132: 2097     [124|129]    jr	    nz, failure
                            M_sio_putc 'A'
                            ; Careful: destroys L
0134: 2E41     [131]        ld	    l, 'A'
0136: CD3203   [148]        call    sio_putc
                            ; af is scratch & we already save/restore bc, de, hl
                            ; save/restore ix, iy too
0139: DDE5     [163]        push    ix
013B: FDE5     [178]        push    iy
                            ; call bc
013D: CDF401   [195]        call    jp_bc
0140: CD6B03   [212]        call    seg_init
0143: FDE1     [226]        pop	    iy
0145: DDE1     [240]        pop	    ix
0147: 188B     [252]        jr	    done
                        #endlocal
                        
                        #local
0149:                   cmd_do_basic::
                            M_sio_putc 'B'
                            ; Careful: destroys L
0149: 2E42     [ 7]         ld	    l, 'B'
014B: CD3203   [24]         call    sio_putc
                            M_sio_puts crlf
                            ; Careful: destroys HL
014E: 214D00   [34]         ld	    hl, crlf
0151: CD3C03   [51]         call    sio_puts
0154: C37F03   [61]         jp	    COLD	; BASIC "cold" start entry point
                        #endlocal
                        
                        #local
0157:                   cmd_do_call::
0157: E5       [11]         push    hl
0158: D5       [22]         push    de
0159: C5       [33]         push    bc
                            M_sio_puts prompt_str
                            ; Careful: destroys HL
015A: 218301   [43]         ld	    hl, prompt_str
015D: CD3C03   [60]         call    sio_puts
0160: CDA102   [77]         call    sio_gethex16
0163: 2814     [84|89]      jr	    z, done
                            ; call address is in HL
                            ; AF is scratch & we already save/restore BC, DE, HL
                            ; save/restore IX, IY too
0165: DDE5     [99]         push    ix
0167: FDE5     [114]        push    iy
0169: CDF301   [131]        call    jp_hl	; call HL
016C: CD6B03   [148]        call    seg_init
016F: FDE1     [162]        pop	    iy
0171: DDE1     [176]        pop	    ix
                            M_sio_puts cmd_ok_str
                            ; Careful: destroys HL
0173: 21EE01   [186]        ld	    hl, cmd_ok_str
0176: CD3C03   [203]        call    sio_puts
0179:                   done:
                            M_sio_puts crlf
                            ; Careful: destroys HL
0179: 214D00   [10]         ld	    hl, crlf
017C: CD3C03   [27]         call    sio_puts
017F: C1       [37]         pop	    bc
0180: D1       [47]         pop	    de
0181: E1       [57]         pop	    hl
0182: C9       [67]         ret
                        
0183:                   prompt_str:
0183: 432400                .asciz  "C$"
                        #endlocal
                        
0186:                   cmd_do_reset::
0186: E5       [11]         push    hl
                            M_sio_putc 'R'
                            ; Careful: destroys L
0187: 2E52     [18]         ld	    l, 'R'
0189: CD3203   [35]         call    sio_putc
018C: CD7103   [52]         call    delay_1ms
018F: C7       [63]         rst	    0x00	; reset
                        
                        #local
0190:                   cmd_do_input::
0190: E5       [11]         push    hl
0191: C5       [22]         push    bc
                            M_sio_puts prompt_str
                            ; Careful: destroys HL
0192: 21B201   [32]         ld	    hl, prompt_str
0195: CD3C03   [49]         call    sio_puts
0198: CD4E02   [66]         call    sio_gethex8
019B: 280C     [73|78]      jr	    z, done
                            ; I/O address is in l
019D: 4D       [77]         ld	    c, l
                            M_sio_puts cmd_equals_str
                            ; Careful: destroys HL
019E: 21EB01   [87]         ld	    hl, cmd_equals_str
01A1: CD3C03   [104]        call    sio_puts
01A4: ED68     [116]        in	    l, (c)
01A6: CD5203   [133]        call    sio_puthex8
01A9:                   done:
                            M_sio_puts crlf
                            ; Careful: destroys HL
01A9: 214D00   [10]         ld	    hl, crlf
01AC: CD3C03   [27]         call    sio_puts
01AF: C1       [37]         pop	    bc
01B0: E1       [47]         pop	    hl
01B1: C9       [57]         ret
                        
01B2:                   prompt_str:
01B2: 492400                .asciz  "I$"
                        #endlocal
                        
                        #local
01B5:                   cmd_do_output::
01B5: E5       [11]         push    hl
01B6: C5       [22]         push    bc
                            M_sio_puts prompt_str
                            ; Careful: destroys HL
01B7: 21DF01   [32]         ld	    hl, prompt_str
01BA: CD3C03   [49]         call    sio_puts
01BD: CD4E02   [66]         call    sio_gethex8
01C0: 2814     [73|78]      jr	    z, done
                            ; I/O address is in l -- stash it in c
01C2: 4D       [77]         ld	    c, l
                            M_sio_puts cmd_equals_str
                            ; Careful: destroys HL
01C3: 21EB01   [87]         ld	    hl, cmd_equals_str
01C6: CD3C03   [104]        call    sio_puts
01C9: CD4E02   [121]        call    sio_gethex8
01CC: 2808     [128|133]    jr	    z, done
                            ; output value is in l
01CE: ED69     [140]        out	    (c), l
                            M_sio_puts cmd_ok_str
                            ; Careful: destroys HL
01D0: 21EE01   [150]        ld	    hl, cmd_ok_str
01D3: CD3C03   [167]        call    sio_puts
01D6:                   done:
                            M_sio_puts crlf
                            ; Careful: destroys HL
01D6: 214D00   [10]         ld	    hl, crlf
01D9: CD3C03   [27]         call    sio_puts
01DC: C1       [37]         pop	    bc
01DD: E1       [47]         pop	    hl
01DE: C9       [57]         ret
                        
01DF:                   prompt_str:
01DF: 4F2400                .asciz  "O$"
                        #endlocal
                        
01E2:                   cmd_do_cr::
01E2: E5       [11]         push    hl
                            M_sio_puts crlf
                            ; Careful: destroys HL
01E3: 214D00   [21]         ld	    hl, crlf
01E6: CD3C03   [38]         call    sio_puts
01E9: E1       [48]         pop	    hl
01EA: C9       [58]         ret
                        
01EB:                   cmd_equals_str::
01EB: 3D2400                .asciz  "=$"
01EE:                   cmd_ok_str::
01EE: 0D0A4F4B              .text   ASC_CR, ASC_LF, "OK", ASC_NUL
01F2: 00                
                        
                        ; Library routines
                        ; ----------------
                        
                        ; Call jp_hl to make a call to the address in hl. What actually happens is the call to jp_hl loads
                        ; the return address on the stack, then control transfers to jp_hl, which jumps to the address
                        ; in hl, thus giving the effect of "call hl", which isn't a Z80 instruction.
01F3:                   jp_hl::
01F3: E9       [ 4]         jp	    hl
                        
                        ; Call jp_bc to make a call to the address in bc. What actually happens is the call to jp_bc loads
                        ; the return address on the stack, then control transfers to jp_bc, which jumps to the address
                        ; in bc, thus giving the effect of "call bc", which isn't a Z80 instruction.
01F4:                   jp_bc::
01F4: C5       [11]         push    bc
01F5: C9       [21]         ret
                        
                        ; uint8_t toupper(uint8_t ch)
                        ; - map character "ch" to upper-case, if it is a lower-case letter
                        #local
01F6:                   toupper::
01F6: 7D       [ 4]         ld	    a, l
01F7: FE61     [11]         cp	    'a'
01F9: D8       [16|22]      ret	    c
01FA: FE7B     [23]         cp	    'z'+1
01FC: D0       [28|34]      ret	    nc
01FD: E6DF     [35]         and	    ~0x20
01FF: 6F       [39]         ld	    l, a
0200: C9       [49]         ret
                        #endlocal
                        
                        ; Z_flag isxdigit(uint8_t ch)
                        ; - set Z flag iff "ch" is a digit 0-9 or A-F
                        #local
0201:                   isxdigit::
0201: 7D       [ 4]         ld	    a, l
0202: FE30     [11]         cp	    '0'
0204: 380C     [18|23]      jr	    c, no
0206: FE3A     [25]         cp	    '9'+1
0208: 380B     [32|37]      jr	    c, yes
020A: FE41     [39]         cp	    'A'
020C: 3804     [46|51]      jr	    c, no
020E: FE47     [53]         cp	    'F'+1
0210: 3803     [60|65]      jr	    c, yes
                            ; otherwise, no
0212:                   no:
0212: FE30     [ 7]         cp	    '0'		; reset Z flag (a != '0', so Z is reset)
0214: C9       [17]         ret
0215:                   yes:
0215: AF       [ 4]         xor	    a		; set Z flag
0216: C9       [14]         ret
                        #endlocal
                        
                        ; uint8_t hex2bin(uint8_t ch)
                        ; - converts the single hex digit "ch" (must be 0-9 or A-F) into a binary value between 0-15
                        ; - pass "ch" in A
                        ; - returns value in low nybble of A
                        #local
0217:                   hex2bin::
0217: FE41     [ 7]         cp	    'A'
0219: 3003     [14|19]      jr	    nc, hex
021B: D630     [21]         sub	    '0'
021D: C9       [31]         ret
021E:                   hex:
021E: D637     [ 7]         sub	    'A'-10
0220: C9       [17]         ret
                        #endlocal
                        
                        ; uint16_t hex2bin2(uint8_t high, uint8_t low)
                        ; - converts the two hex digits "high" and "low" (must be 0-9 or A-F) into an unsigned 8-bit value
                        ; - pass "high" in H, and "low" in L
                        ; - returns result in L
                        #local
0221:                   hex2bin2::
0221: E5       [11]         push    hl		; preserve H
0222: 7C       [15]         ld	    a, h
0223: CD1702   [32]         call    hex2bin
0226: 67       [36]         ld	    h, a	; convert digit in H to nybble in H
0227: 7D       [40]         ld	    a, l
0228: CD1702   [57]         call    hex2bin
022B: 6F       [61]         ld	    l, a	; convert digit in L to nybble in L
                            ; compute A = (H << 4) | L
022C: 7C       [65]         ld	    a, h
022D: 87       [69]         add	    a
022E: 87       [73]         add	    a
022F: 87       [77]         add	    a
0230: 87       [81]         add	    a
0231: B5       [85]         or	    l
0232: E1       [95]         pop	    hl
0233: 6F       [99]         ld	    l, a
0234: C9       [109]        ret
                        #endlocal
                        
                        ; uint8_t bin2hex(uint8_t val)
                        ; - converts the lower 4 bits of the 8-bit value "val" to hexadecimal (0-9,A-F)
                        #local
0235:                   bin2hex::
0235: 7D       [ 4]         ld	    a, l
0236: E60F     [11]         and	    0xF
0238: FE0A     [18]         cp	    0xA
023A: 3804     [25|30]      jr	    c, decimal
023C: C637     [32]         add	    'A'-10
023E: 6F       [36]         ld	    l, a
023F: C9       [46]         ret
0240:                   decimal:
0240: C630     [ 7]         add	    '0'
0242: 6F       [11]         ld	    l, a
0243: C9       [21]         ret
                        #endlocal
                        
                        ; uint8_t sio_getc()
                        ; - wait synchronously until a byte is available from port A, and return it
                        #local
0244:                   sio_getc::
0244:                   waitRX:
                            ; wait for an input character
0244: DB22     [11]         in	    a, (PORT_SIOACTL)
0246: CB47     [19]         bit	    SIORR0_IDX_RCA, a
0248: 28FA     [26|31]      jr	    z, waitRX
                            ; read input character
024A: DB20     [37]         in	    a, (PORT_SIOADAT)
024C: 6F       [41]         ld	    l, a
024D: C9       [51]         ret
                        #endlocal
                        
                        ; int8_t sio_gethex8()
                        ; - read a two-char 8-bit hex value from port A
                        ; - echoes chars as entered, erases as backspaced
                        ; - BS erases last entered char
                        ; - ESC aborts entry at any point
                        ; - CR accepts entry
                        ; - returns unsigned 8-bit value entered in L
                        ; - Z flag is set if user aborted entry, cleared otherwise
                        #local
024E:                   sio_gethex8::
024E: C5       [11]         push    bc
024F:                   getFirst:
024F: CD4402   [17]         call    sio_getc
0252: 7D       [21]         ld	    a, l
0253: FE1B     [28]         cp	    ASC_ESC
0255: 2848     [35|40]      jr	    z, abort	; Z is set, return
0257: CDF601   [52]         call    toupper
025A: CD0102   [69]         call    isxdigit	; Z set iff is hex digit
025D: 20F0     [76|81]      jr	    nz, getFirst
025F: CD3203   [93]         call    sio_putc	; echo digit
0262: 45       [97]         ld	    b, l	; store high digit in B
0263:                   getSecond:
0263: CD4402   [17]         call    sio_getc
0266: 7D       [21]         ld	    a, l
0267: FE1B     [28]         cp	    ASC_ESC
0269: 2834     [35|40]      jr	    z, abort	; Z is set, return
026B: FE10     [42]         cp	    BS
026D: 2005     [49|54]      jr	    nz, notBS1
026F: CD3203   [66]         call    sio_putc	; echo BS
0272: 18DB     [78]         jr	    getFirst
0274:                   notBS1:
0274: CDF601   [17]         call    toupper
0277: CD0102   [34]         call    isxdigit	; Z set iff is hex digit
027A: 20E7     [41|46]      jr	    nz, getSecond
027C: CD3203   [58]         call    sio_putc	; echo digit
027F: 4D       [62]         ld	    c, l	; store low digit in C
0280:                   getThird:
0280: CD4402   [17]         call    sio_getc
0283: 7D       [21]         ld	    a, l
0284: FE1B     [28]         cp	    ASC_ESC
0286: 2817     [35|40]      jr	    z, abort	; Z is set, return
0288: FE0D     [42]         cp	    ASC_CR
028A: 2809     [49|54]      jr	    z, convert
028C: FE08     [56]         cp	    ASC_BS
028E: 20F0     [63|68]      jr	    nz, getThird
                            ; handle backspace
0290: CD3203   [80]         call    sio_putc	; echo BS
0293: 18CE     [92]         jr	    getSecond
0295:                   convert:
0295: E5       [11]         push    hl		; save H
0296: 6069     [19]         ld	    hl, bc
0298: CD2102   [36]         call    hex2bin2
029B: 7D       [40]         ld	    a, l
029C: E1       [50]         pop	    hl		; restore H
029D: 6F       [54]         ld	    l, a
029E: B0       [58]         or	    b		; reset Z flag by ORing in the ASCII hex digit in B
029F:                   abort:
029F: C1       [10]         pop	    bc
02A0: C9       [20]         ret
                        #endlocal
                        
                        ; int16_t sio_gethex16()
                        ; - read a four-char 16-bit hex value from port A
                        ; - echoes chars as entered, erases as backspaced
                        ; - BS erases last entered char
                        ; - ESC aborts entry at any point
                        ; - CR accepts entry
                        ; - returns unsigned 16-bit value entered in HL
                        ; - Z flag is set if user aborted entry, cleared otherwise
                        #local
02A1:                   sio_gethex16::
02A1: C5       [11]         push    bc
02A2: D5       [22]         push    de
02A3:                   getFirst:
02A3: CD4402   [17]         call    sio_getc
02A6: 7D       [21]         ld	    a, l
02A7: FE1B     [28]         cp	    ASC_ESC
02A9: CA2F03   [38|38]      jp	    z, abort	; Z is set, return
02AC: CDF601   [55]         call    toupper
02AF: CD0102   [72]         call    isxdigit	; Z set iff is hex digit
02B2: 20EF     [79|84]      jr	    nz, getFirst
02B4: CD3203   [96]         call    sio_putc	; echo digit
02B7: 45       [100]        ld	    b, l	; store digit1 in B
02B8:                   getSecond:
02B8: CD4402   [17]         call    sio_getc
02BB: 7D       [21]         ld	    a, l
02BC: FE1B     [28]         cp	    ASC_ESC
02BE: 286F     [35|40]      jr	    z, abort	; Z is set, return
02C0: FE10     [42]         cp	    BS
02C2: 2005     [49|54]      jr	    nz, notBS1
02C4: CD3203   [66]         call    sio_putc	; echo BS
02C7: 18DA     [78]         jr	    getFirst
02C9:                   notBS1:
02C9: CDF601   [17]         call    toupper
02CC: CD0102   [34]         call    isxdigit	; Z set iff is hex digit
02CF: 20E7     [41|46]      jr	    nz, getSecond
02D1: CD3203   [58]         call    sio_putc	; echo digit
02D4: 4D       [62]         ld	    c, l	; store digit2 in C
02D5:                   getThird:
02D5: CD4402   [17]         call    sio_getc
02D8: 7D       [21]         ld	    a, l
02D9: FE1B     [28]         cp	    ASC_ESC
02DB: 2852     [35|40]      jr	    z, abort	; Z is set, return
02DD: FE08     [42]         cp	    ASC_BS
02DF: 2005     [49|54]      jr	    nz, notBS2
02E1: CD3203   [66]         call    sio_putc	; echo BS
02E4: 18D2     [78]         jr	    getSecond
02E6:                   notBS2:
02E6: CDF601   [17]         call    toupper
02E9: CD0102   [34]         call    isxdigit	; Z set iff is hex digit
02EC: 20E7     [41|46]      jr	    nz, getThird
02EE: CD3203   [58]         call    sio_putc	; echo digit
02F1: 55       [62]         ld	    d, l	; store digit3 in D
02F2:                   getFourth:
02F2: CD4402   [17]         call    sio_getc
02F5: 7D       [21]         ld	    a, l
02F6: FE1B     [28]         cp	    ASC_ESC
02F8: 2835     [35|40]      jr	    z, abort	; Z is set, return
02FA: FE08     [42]         cp	    ASC_BS
02FC: 2005     [49|54]      jr	    nz, notBS3
02FE: CD3203   [66]         call    sio_putc	; echo BS
0301: 18D2     [78]         jr	    getThird
0303:                   notBS3:
0303: CDF601   [17]         call    toupper
0306: CD0102   [34]         call    isxdigit	; Z set iff is hex digit
0309: 20E7     [41|46]      jr	    nz, getFourth
030B: CD3203   [58]         call    sio_putc	; echo digit
030E: 5D       [62]         ld	    e, l	; store digit4 in E
030F:                   getFifth:
030F: CD4402   [17]         call    sio_getc
0312: 7D       [21]         ld	    a, l
0313: FE1B     [28]         cp	    ASC_ESC
0315: 2818     [35|40]      jr	    z, abort	; Z is set, return
0317: FE0D     [42]         cp	    ASC_CR
0319: 2809     [49|54]      jr	    z, convert
031B: FE08     [56]         cp	    ASC_BS
031D: 20F0     [63|68]      jr	    nz, getFifth
                            ; handle backspace
031F: CD3203   [80]         call    sio_putc	; echo BS
0322: 18CE     [92]         jr	    getFourth
0324:                   convert:
0324: 6069     [ 8]         ld	    hl, bc	; HL := digit1,digit2
0326: CD2102   [25]         call    hex2bin2	; L := hex2bin2(digit1,digit2)
0329: EB       [29]         ex	    de, hl	; HL := digit3,digit4 ; E := hex2bin2(digit1,digit2)
032A: CD2102   [46]         call    hex2bin2	; L := hex2bin2(digit3,digit4)
032D: 63       [50]         ld	    h, e	; H := hex2bin2(digit1,digit2)
032E: B0       [54]         or	    b		; reset Z flag by ORing in the ASCII hex digit in B
032F:                   abort:
032F: D1       [10]         pop	    de
0330: C1       [20]         pop	    bc
0331: C9       [30]         ret
                        #endlocal
                        
                        ; void sio_putc(uint8_t ch)
                        ; - write the specified character "ch" to port A
                        #local
0332:                   sio_putc::
0332:                   waitTX:
                            ; wait until transmitter is idle
0332: DB22     [11]         in	    a, (PORT_SIOACTL)
0334: CB57     [19]         bit	    SIORR0_IDX_TBE, a
0336: 28FA     [26|31]      jr	    z, waitTX
                            ; write output character
0338: 7D       [30]         ld	    a, l
0339: D320     [41]         out	    (PORT_SIOADAT), a	; send byte out serial port
033B: C9       [51]         ret
                        #endlocal
                        
                        ; void sio_puts(uint8_t *text)
                        ; - write the NUL-terminated string at "text" to port A
                        #local
033C:                   sio_puts::
033C: E5       [11]         push    hl
033D: C5       [22]         push    bc
033E:                   nextByte:
033E: 7E       [ 7]         ld	    a, (hl)
033F: 23       [13]         inc	    hl
0340: B7       [17]         or	    a		; fast test a==0
0341: 280C     [24|29]      jr	    z, done
0343: 47       [28]         ld	    b, a
0344:                   waitTX:
                            ; wait until transmitter is idle
0344: DB22     [11]         in	    a, (PORT_SIOACTL)
0346: CB57     [19]         bit	    SIORR0_IDX_TBE, a
0348: 28FA     [26|31]      jr	    z, waitTX
                            ; write output character
034A: 78       [30]         ld	    a, b
034B: D320     [41]         out	    (PORT_SIOADAT), a	; send byte out serial port
034D: 18EF     [53]         jr	    nextByte
034F:                   done:
034F: C1       [10]         pop	    bc
0350: E1       [20]         pop	    hl
0351: C9       [30]         ret
                        #endlocal
                        
                        ; void sio_puthex8(uint8_t val)
                        ; - writes the specified 8-bit value "val" as a pair of hex digits to port A
0352:                   sio_puthex8::
0352: E5       [11]         push    hl
0353: 65       [15]         ld	    h, l
0354: CB3D     [23]         srl	    l
0356: CB3D     [31]         srl	    l
0358: CB3D     [39]         srl	    l
035A: CB3D     [47]         srl	    l
035C: CD3502   [64]         call    bin2hex
035F: CD3203   [81]         call    sio_putc
0362: 6C       [85]         ld	    l, h
0363: CD3502   [102]        call    bin2hex
0366: CD3203   [119]        call    sio_putc
0369: E1       [129]        pop	    hl
036A: C9       [139]        ret
                        
                        ; void seg_init()
036B:                   seg_init::
036B: AF       [ 4]         xor	    a
036C: D300     [15]         out	    (PORT_SEG0), a
036E: D310     [26]         out	    (PORT_SEG1), a
0370: C9       [36]         ret
                        
                        ; void delay_1ms()
                        ; - delay for 1ms (technically, 0.9999ms)
                        #local
0371:                   delay_1ms::
0371: C5       [11]         push    bc		; 11 T-states
                        ; To delay 1ms, we want to wait 10,000 T-states (@10MHz)
                        ; The loop is (38*b + 13*(b-1) + 8) T-states long
                        ; Rearranging: 51*b - 5
                        ; Solve for b: b = (10000 + 5 / 51) = 196.17
0372: 06C3     [18]         ld	    b, 195	; 7 T-states
0374:                   loop:
0374: DD7E01   [19]         ld	    a, (ix+1)	; 19 T-states
0377: DD7E01   [38]         ld	    a, (ix+1)	; 19 T-states
037A: 10F8     [46|51]      djnz    loop	; (b-1)*13+8 T-states
037C: C1       [56]         pop	    bc		; 10 T-states
037D: 00       [60]         nop			; 4 T-states
037E: C9       [70]         ret			; 10 T-states
                        ; We also assume the routine is CALLed, for 17 T-states.
                        ; Total delay is therefore:
                        ;   17 + 11 + 7 + 51*195 - 5 + 10 + 4 + 10 = 9,999
                        #endlocal
                        
                        
                        ;==================================================================================
                        ; The updates to the original BASIC within this file are copyright Grant Searle
                        ;
                        ; You have permission to use this for NON COMMERCIAL USE ONLY
                        ; If you wish to use it elsewhere, please include an acknowledgement to myself.
                        ;
                        ; http://searle.hostei.com/grant/index.html
                        ;
                        ; eMail: home.micros01@btinternet.com
                        ;
                        ; If the above don't work, please perform an Internet search to see if I have
                        ; updated the web page hosting service.
                        ;
                        ;==================================================================================
                        
                        ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
                        ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
                        ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
                        ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
                        ; the original ROM code (checksum A934H). PA
                        
                        ; GENERAL EQUATES
                        
0003:                   CTRLC   .EQU    03H             ; Control "C"
0007:                   CTRLG   .EQU    07H             ; Control "G"
0008:                   BKSP    .EQU    08H             ; Back space
000A:                   LF      .EQU    0AH             ; Line feed
000C:                   CS      .EQU    0CH             ; Clear screen
000D:                   CR      .EQU    0DH             ; Carriage return
000F:                   CTRLO   .EQU    0FH             ; Control "O"
0011:                   CTRLQ	.EQU	11H		        ; Control "Q"
0012:                   CTRLR   .EQU    12H             ; Control "R"
0013:                   CTRLS   .EQU    13H             ; Control "S"
0015:                   CTRLU   .EQU    15H             ; Control "U"
001B:                   ESC     .EQU    1BH             ; Escape
007F:                   DEL     .EQU    7FH             ; Delete
                        
                        ; BASIC WORK SPACE LOCATIONS
                        
                        ; Start immediately after ROM at $2000.
2000:                   AFTER_CODE .EQU 2000H
2045:                   WRKSPC  .EQU    AFTER_CODE+45H	    ; BASIC Work space
2048:                   USR     .EQU    WRKSPC+3H           ; "USR (x)" jump
204B:                   OUTSUB  .EQU    WRKSPC+6H           ; "OUT p,n"
204C:                   OTPORT  .EQU    WRKSPC+7H           ; Port (p)
204E:                   DIVSUP  .EQU    WRKSPC+9H           ; Division support routine
204F:                   DIV1    .EQU    WRKSPC+0AH           ; <- Values
2053:                   DIV2    .EQU    WRKSPC+0EH           ; <-   to
2057:                   DIV3    .EQU    WRKSPC+12H           ; <-   be
205A:                   DIV4    .EQU    WRKSPC+15H           ; <-inserted
205C:                   SEED    .EQU    WRKSPC+17H           ; Random number seed
207F:                   LSTRND  .EQU    WRKSPC+3AH           ; Last random number
2083:                   INPSUB  .EQU    WRKSPC+3EH           ; #INP (x)" Routine
2084:                   INPORT  .EQU    WRKSPC+3FH           ; PORT (x)
2086:                   NULLS   .EQU    WRKSPC+41H           ; Number of nulls
2087:                   LWIDTH  .EQU    WRKSPC+42H           ; Terminal width
2088:                   COMMAN  .EQU    WRKSPC+43H           ; Width for commas
2089:                   NULFLG  .EQU    WRKSPC+44H           ; Null after input byte flag
208A:                   CTLOFG  .EQU    WRKSPC+45H           ; Control "O" flag
208B:                   LINESC  .EQU    WRKSPC+46H           ; Lines counter
208D:                   LINESN  .EQU    WRKSPC+48H           ; Lines number
208F:                   CHKSUM  .EQU    WRKSPC+4AH           ; Array load/save check sum
2091:                   NMIFLG  .EQU    WRKSPC+4CH           ; Flag for NMI break routine
2092:                   BRKFLG  .EQU    WRKSPC+4DH           ; Break flag
2093:                   RINPUT  .EQU    WRKSPC+4EH           ; Input reflection
2096:                   POINT   .EQU    WRKSPC+51H           ; "POINT" reflection (unused)
2099:                   PSET    .EQU    WRKSPC+54H           ; "SET"   reflection
209C:                   RESET   .EQU    WRKSPC+57H           ; "RESET" reflection
209F:                   STRSPC  .EQU    WRKSPC+5AH           ; Bottom of string space
20A1:                   LINEAT  .EQU    WRKSPC+5CH           ; Current line number
20A3:                   BASTXT  .EQU    WRKSPC+5EH           ; Pointer to start of program
20A6:                   BUFFER  .EQU    WRKSPC+61H           ; Input buffer
20AB:                   STACK   .EQU    WRKSPC+66H           ; Initial stack
20F0:                   CURPOS  .EQU    WRKSPC+0ABH          ; Character position on line
20F1:                   LCRFLG  .EQU    WRKSPC+0ACH          ; Locate/Create flag
20F2:                   TYPE    .EQU    WRKSPC+0ADH          ; Data type flag
20F3:                   DATFLG  .EQU    WRKSPC+0AEH          ; Literal statement flag
20F4:                   LSTRAM  .EQU    WRKSPC+0AFH          ; Last available RAM
20F6:                   TMSTPT  .EQU    WRKSPC+0B1H          ; Temporary string pointer
20F8:                   TMSTPL  .EQU    WRKSPC+0B3H          ; Temporary string pool
2104:                   TMPSTR  .EQU    WRKSPC+0BFH          ; Temporary string
2108:                   STRBOT  .EQU    WRKSPC+0C3H          ; Bottom of string space
210A:                   CUROPR  .EQU    WRKSPC+0C5H          ; Current operator in EVAL
210C:                   LOOPST  .EQU    WRKSPC+0C7H          ; First statement of loop
210E:                   DATLIN  .EQU    WRKSPC+0C9H          ; Line of current DATA item
2110:                   FORFLG  .EQU    WRKSPC+0CBH          ; "FOR" loop flag
2111:                   LSTBIN  .EQU    WRKSPC+0CCH          ; Last byte entered
2112:                   READFG  .EQU    WRKSPC+0CDH          ; Read/Input flag
2113:                   BRKLIN  .EQU    WRKSPC+0CEH          ; Line of break
2115:                   NXTOPR  .EQU    WRKSPC+0D0H          ; Next operator in EVAL
2117:                   ERRLIN  .EQU    WRKSPC+0D2H          ; Line of error
2119:                   CONTAD  .EQU    WRKSPC+0D4H          ; Where to CONTinue
211B:                   PROGND  .EQU    WRKSPC+0D6H          ; End of program
211D:                   VAREND  .EQU    WRKSPC+0D8H          ; End of variables
211F:                   ARREND  .EQU    WRKSPC+0DAH          ; End of arrays
2121:                   NXTDAT  .EQU    WRKSPC+0DCH          ; Next data item
2123:                   FNRGNM  .EQU    WRKSPC+0DEH          ; Name of FN argument
2125:                   FNARG   .EQU    WRKSPC+0E0H          ; FN argument value
2129:                   FPREG   .EQU    WRKSPC+0E4H          ; Floating point register
212C:                   FPEXP   .EQU    FPREG+3         ; Floating point exponent
212D:                   SGNRES  .EQU    WRKSPC+0E8H     ; Sign of result
212E:                   PBUFF   .EQU    WRKSPC+0E9H     ; Number print buffer
213B:                   MULVAL  .EQU    WRKSPC+0F6H     ; Multiplier
213E:                   PROGST  .EQU    WRKSPC+0F9H     ; Start of program text area
21A2:                   STLOOK  .EQU    WRKSPC+15DH     ; Start of memory test
                        
                        ; BASIC ERROR CODE VALUES
                        
0000:                   NF      .EQU    00H             ; NEXT without FOR
0002:                   SN      .EQU    02H             ; Syntax error
0004:                   RG      .EQU    04H             ; RETURN without GOSUB
0006:                   OD      .EQU    06H             ; Out of DATA
0008:                   FC      .EQU    08H             ; Function call error
000A:                   OV      .EQU    0AH             ; Overflow
000C:                   OM      .EQU    0CH             ; Out of memory
000E:                   UL      .EQU    0EH             ; Undefined line number
0010:                   BS      .EQU    10H             ; Bad subscript
0012:                   DD      .EQU    12H             ; Re-DIMensioned array
0014:                   DZ      .EQU    14H             ; Division by zero (/0)
0016:                   ID      .EQU    16H             ; Illegal direct
0018:                   TM      .EQU    18H             ; Type miss-match
001A:                   OS      .EQU    1AH             ; Out of string space
001C:                   LS      .EQU    1CH             ; String too long
001E:                   ST      .EQU    1EH             ; String formula too complex
0020:                   CN      .EQU    20H             ; Can't CONTinue
0022:                   UF      .EQU    22H             ; UnDEFined FN function
0024:                   MO      .EQU    24H             ; Missing operand
0026:                   HX      .EQU    26H             ; HEX error
0028:                   BN      .EQU    28H             ; BIN error
                        
037F:                   COLD:		                ; Jump for cold start
037F: DD210000 [14]             LD      IX,0            ; Flag cold start
0383: C38A03   [24]             JP      CSTART          ; Jump to initialise
                        
0386: 040C                      .WORD   DEINT           ; Get integer -32768 to 32767
0388: 7A13                      .WORD   ABPASS          ; Return integer in AB
                        
                        
038A:                   CSTART:
038A: 214520   [10]     	LD      HL,WRKSPC       ; Start of workspace RAM
038D: F9       [16]             LD      SP,HL           ; Set up a temporary stack
038E: AF       [20]     	XOR	A               ; Clear break flag
038F: 329220   [33]             LD      (BRKFLG),A
                        
0392: 112B06   [10]     INIT:   LD      DE,INITAB       ; Initialise workspace
0395: 0663     [17]             LD      B,INITBE-INITAB+3; Bytes to copy
0397: 214520   [27]             LD      HL,WRKSPC       ; Into workspace RAM
039A: 1A       [ 7]     COPY:   LD      A,(DE)          ; Get source
039B: 77       [14]             LD      (HL),A          ; To destination
039C: 23       [20]             INC     HL              ; Next destination
039D: 13       [26]             INC     DE              ; Next source
039E: 05       [30]             DEC     B               ; Count bytes
039F: C29A03   [40|40]          JP      NZ,COPY         ; More to move
03A2: F9       [46]             LD      SP,HL           ; Temporary stack
03A3: CD2C08   [63]             CALL    CLREG           ; Clear registers and stack
03A6: CDFA0D   [80]             CALL    PRNTCRLF        ; Output CRLF
03A9: 32EF20   [93]             LD      (BUFFER+72+1),A ; Mark end of buffer
03AC: 323E21   [106]            LD      (PROGST),A      ; Initialise program area
03AF: 21A221   [10]     MSIZE:  LD      HL,STLOOK       ; Point to start of RAM
03B2: 23       [ 6]     MLOOP:  INC     HL              ; Next byte
03B3: 7C       [10]             LD      A,H             ; Above address FFFF ?
03B4: B5       [14]             OR      L
03B5: CAC403   [24|24]          JP      Z,SETTOP        ; Yes - 64K RAM
03B8: 7E       [31]             LD      A,(HL)          ; Get contents
03B9: 47       [35]             LD      B,A             ; Save it
03BA: 2F       [39]             CPL                     ; Flip all bits
03BB: 77       [46]             LD      (HL),A          ; Put it back
03BC: BE       [53]             CP      (HL)            ; RAM there if same
03BD: 70       [60]             LD      (HL),B          ; Restore old contents
03BE: CAB203   [70|70]          JP      Z,MLOOP         ; If RAM - test next byte
03C1: C3C403   [80]             JP      SETTOP          ; Top of RAM found
                        
03C4: 2B       [ 6]     SETTOP: DEC     HL              ; Back one byte
03C5: 11A121   [16]             LD      DE,STLOOK-1     ; See if enough RAM
03C8: CDBB09   [33]             CALL    CPDEHL          ; Compare DE with HL
03CB: DAAF03   [43|43]          JP      C,MSIZE         ; Ask again if not enough RAM
03CE: 11CEFF   [53]             LD      DE,0-50         ; 50 Bytes string space
03D1: 22F420   [69]             LD      (LSTRAM),HL     ; Save last available RAM
03D4: 19       [80]             ADD     HL,DE           ; Allocate string space
03D5: 229F20   [96]             LD      (STRSPC),HL     ; Save string space
03D8: CD0708   [113]            CALL    CLRPTR          ; Clear program area
03DB: 2A9F20   [129]            LD      HL,(STRSPC)     ; Get end of memory
03DE: 11EFFF   [139]            LD      DE,0-17         ; Offset for free bytes
03E1: 19       [150]            ADD     HL,DE           ; Adjust HL
03E2: 113E21   [160]            LD      DE,PROGST       ; Start of program text
03E5: 7D       [164]            LD      A,L             ; Get LSB
03E6: 93       [168]            SUB     E               ; Adjust it
03E7: 6F       [172]            LD      L,A             ; Re-save
03E8: 7C       [176]            LD      A,H             ; Get MSB
03E9: 9A       [180]            SBC     A,D             ; Adjust it
03EA: 67       [184]            LD      H,A             ; Re-save
03EB: E5       [195]            PUSH    HL              ; Save bytes free
03EC: 211404   [205]            LD      HL,SIGNON       ; Sign-on message
03EF: CD9814   [222]            CALL    PRS             ; Output string
03F2: E1       [232]            POP     HL              ; Get bytes free back
03F3: CD3B1B   [249]            CALL    PRNTHL          ; Output amount of free memory
03F6: 210504   [259]            LD      HL,BFREE        ; " Bytes free" message
03F9: CD9814   [276]            CALL    PRS             ; Output string
                        
03FC: 31AB20   [10]     WARMST: LD      SP,STACK        ; Temporary stack
03FF: CD2C08   [17]     BRKRET: CALL    CLREG           ; Clear registers and stack
0402: C34507   [27]             JP      PRNTOK          ; Go to get command line
                        
0405: 20427974          BFREE:  .BYTE   " Bytes free",CR,LF,0,0
0409: 65732066          
040D: 7265650D          
0411: 0A0000            
                        
0414: 5A383020          SIGNON: .BYTE   "Z80 BASIC Ver 4.7b",CR,LF
0418: 42415349          
041C: 43205665          
0420: 7220342E          
0424: 37620D0A          
0428: 436F7079                  .BYTE   "Copyright ",40,"C",41
042C: 72696768          
0430: 74202843          
0434: 29                
0435: 20313937                  .BYTE   " 1978 by Microsoft",CR,LF,0,0
0439: 38206279          
043D: 204D6963          
0441: 726F736F          
0445: 66740D0A          
0449: 0000              
                        
                        ; FUNCTION ADDRESS TABLE
                        
044B: B019              FNCTAB: .WORD   SGN
044D: 741A                      .WORD   INT
044F: C619                      .WORD   ABS
0451: 4820                      .WORD   USR
0453: 5813                      .WORD   FRE
0455: DD16                      .WORD   INP
0457: 8613                      .WORD   POS
0459: 3A1C                      .WORD   SQR
045B: 191D                      .WORD   RND
045D: 5518                      .WORD   LOG
045F: 881C                      .WORD   EXP
0461: 8E1D                      .WORD   COS
0463: 941D                      .WORD   SIN
0465: F51D                      .WORD   TAN
0467: 0A1E                      .WORD   ATN
0469: 3117                      .WORD   PEEK
046B: 7B1E                      .WORD   DEEK
046D: 9620                      .WORD   POINT
046F: 0A16                      .WORD   LEN
0471: 2214                      .WORD   STR
0473: A416                      .WORD   VAL
0475: 1916                      .WORD   ASC
0477: 2A16                      .WORD   CHR
0479: 9D1E                      .WORD   HEX
047B: 301F                      .WORD   BIN
047D: 3A16                      .WORD   LEFT
047F: 6A16                      .WORD   RIGHT
0481: 7416                      .WORD   MID
                        
                        ; RESERVED WORD LIST
                        
0483: C54E44            WORDS:  .BYTE   'E'+80H,"ND"
0486: C64F52                    .BYTE   'F'+80H,"OR"
0489: CE455854                  .BYTE   'N'+80H,"EXT"
048D: C4415441                  .BYTE   'D'+80H,"ATA"
0491: C94E5055                  .BYTE   'I'+80H,"NPUT"
0495: 54                
0496: C4494D                    .BYTE   'D'+80H,"IM"
0499: D2454144                  .BYTE   'R'+80H,"EAD"
049D: CC4554                    .BYTE   'L'+80H,"ET"
04A0: C74F544F                  .BYTE   'G'+80H,"OTO"
04A4: D2554E                    .BYTE   'R'+80H,"UN"
04A7: C946                      .BYTE   'I'+80H,"F"
04A9: D2455354                  .BYTE   'R'+80H,"ESTORE"
04AD: 4F5245            
04B0: C74F5355                  .BYTE   'G'+80H,"OSUB"
04B4: 42                
04B5: D2455455                  .BYTE   'R'+80H,"ETURN"
04B9: 524E              
04BB: D2454D                    .BYTE   'R'+80H,"EM"
04BE: D3544F50                  .BYTE   'S'+80H,"TOP"
04C2: CF5554                    .BYTE   'O'+80H,"UT"
04C5: CF4E                      .BYTE   'O'+80H,"N"
04C7: CE554C4C                  .BYTE   'N'+80H,"ULL"
04CB: D7414954                  .BYTE   'W'+80H,"AIT"
04CF: C44546                    .BYTE   'D'+80H,"EF"
04D2: D04F4B45                  .BYTE   'P'+80H,"OKE"
04D6: C44F4B45                  .BYTE   'D'+80H,"OKE"
04DA: D3435245                  .BYTE   'S'+80H,"CREEN"
04DE: 454E              
04E0: CC494E45                  .BYTE   'L'+80H,"INES"
04E4: 53                
04E5: C34C53                    .BYTE   'C'+80H,"LS"
04E8: D7494454                  .BYTE   'W'+80H,"IDTH"
04EC: 48                
04ED: CD4F4E49                  .BYTE   'M'+80H,"ONITOR"
04F1: 544F52            
04F4: D34554                    .BYTE   'S'+80H,"ET"
04F7: D2455345                  .BYTE   'R'+80H,"ESET"
04FB: 54                
04FC: D052494E                  .BYTE   'P'+80H,"RINT"
0500: 54                
0501: C34F4E54                  .BYTE   'C'+80H,"ONT"
0505: CC495354                  .BYTE   'L'+80H,"IST"
0509: C34C4541                  .BYTE   'C'+80H,"LEAR"
050D: 52                
050E: C34C4F41                  .BYTE   'C'+80H,"LOAD"
0512: 44                
0513: C3534156                  .BYTE   'C'+80H,"SAVE"
0517: 45                
0518: CE4557                    .BYTE   'N'+80H,"EW"
                        
051B: D4414228                  .BYTE   'T'+80H,"AB("
051F: D44F                      .BYTE   'T'+80H,"O"
0521: C64E                      .BYTE   'F'+80H,"N"
0523: D3504328                  .BYTE   'S'+80H,"PC("
0527: D448454E                  .BYTE   'T'+80H,"HEN"
052B: CE4F54                    .BYTE   'N'+80H,"OT"
052E: D3544550                  .BYTE   'S'+80H,"TEP"
                        
0532: AB                        .BYTE   '+'+80H
0533: AD                        .BYTE   '-'+80H
0534: AA                        .BYTE   '*'+80H
0535: AF                        .BYTE   '/'+80H
0536: DE                        .BYTE   '^'+80H
0537: C14E44                    .BYTE   'A'+80H,"ND"
053A: CF52                      .BYTE   'O'+80H,"R"
053C: BE                        .BYTE   '>'+80H
053D: BD                        .BYTE   '='+80H
053E: BC                        .BYTE   '<'+80H
                        
053F: D3474E                    .BYTE   'S'+80H,"GN"
0542: C94E54                    .BYTE   'I'+80H,"NT"
0545: C14253                    .BYTE   'A'+80H,"BS"
0548: D55352                    .BYTE   'U'+80H,"SR"
054B: C65245                    .BYTE   'F'+80H,"RE"
054E: C94E50                    .BYTE   'I'+80H,"NP"
0551: D04F53                    .BYTE   'P'+80H,"OS"
0554: D35152                    .BYTE   'S'+80H,"QR"
0557: D24E44                    .BYTE   'R'+80H,"ND"
055A: CC4F47                    .BYTE   'L'+80H,"OG"
055D: C55850                    .BYTE   'E'+80H,"XP"
0560: C34F53                    .BYTE   'C'+80H,"OS"
0563: D3494E                    .BYTE   'S'+80H,"IN"
0566: D4414E                    .BYTE   'T'+80H,"AN"
0569: C1544E                    .BYTE   'A'+80H,"TN"
056C: D045454B                  .BYTE   'P'+80H,"EEK"
0570: C445454B                  .BYTE   'D'+80H,"EEK"
0574: D04F494E                  .BYTE   'P'+80H,"OINT"
0578: 54                
0579: CC454E                    .BYTE   'L'+80H,"EN"
057C: D3545224                  .BYTE   'S'+80H,"TR$"
0580: D6414C                    .BYTE   'V'+80H,"AL"
0583: C15343                    .BYTE   'A'+80H,"SC"
0586: C3485224                  .BYTE   'C'+80H,"HR$"
058A: C8455824                  .BYTE   'H'+80H,"EX$"
058E: C2494E24                  .BYTE   'B'+80H,"IN$"
0592: CC454654                  .BYTE   'L'+80H,"EFT$"
0596: 24                
0597: D2494748                  .BYTE   'R'+80H,"IGHT$"
059B: 5424              
059D: CD494424                  .BYTE   'M'+80H,"ID$"
05A1: 80                        .BYTE   80H             ; End of list marker
                        
                        ; KEYWORD ADDRESS TABLE
                        
05A2: 9C0B              WORDTB: .WORD   PEND
05A4: 920A                      .WORD   FOR
05A6: 740F                      .WORD   NEXT
05A8: E90C                      .WORD   DATA
05AA: 7B0E                      .WORD   INPUT
05AC: B011                      .WORD   DIM
05AE: AA0E                      .WORD   READ
05B0: 000D                      .WORD   LET
05B2: A60C                      .WORD   GOTO
05B4: 890C                      .WORD   RUN
05B6: 780D                      .WORD   IF
05B8: 5B0B                      .WORD   RESTOR
05BA: 950C                      .WORD   GOSUB
05BC: C40C                      .WORD   RETURN
05BE: EB0C                      .WORD   REM
05C0: 9A0B                      .WORD   STOP
05C2: E916                      .WORD   POUT
05C4: 5A0D                      .WORD   ON
05C6: DB0B                      .WORD   NULL
05C8: EF16                      .WORD   WAIT
05CA: 8E13                      .WORD   DEF
05CC: 3817                      .WORD   POKE
05CE: 861E                      .WORD   DOKE
05D0: EB0C                      .WORD   REM
05D2: 6C1E                      .WORD   LINES
05D4: 5F1E                      .WORD   CLS
05D6: 641E                      .WORD   WIDTH
05D8: 9D1F                      .WORD   MONITR
05DA: 9920                      .WORD   PSET
05DC: 9C20                      .WORD   RESET
05DE: 9C0D                      .WORD   PRINT
05E0: C80B                      .WORD   CONT
05E2: 070A                      .WORD   LIST
05E4: 430C                      .WORD   CLEAR
05E6: EB0C                      .WORD   REM
05E8: EB0C                      .WORD   REM
05EA: 0608                      .WORD   NEW
                        
                        ; RESERVED WORD TOKEN VALUES
                        
0080:                   ZEND    .EQU    080H            ; END
0081:                   ZFOR    .EQU    081H            ; FOR
0083:                   ZDATA   .EQU    083H            ; DATA
0088:                   ZGOTO   .EQU    088H            ; GOTO
008C:                   ZGOSUB  .EQU    08CH            ; GOSUB
008E:                   ZREM    .EQU    08EH            ; REM
009E:                   ZPRINT  .EQU    09EH            ; PRINT
00A4:                   ZNEW    .EQU    0A4H            ; NEW
                        
00A5:                   ZTAB    .EQU    0A5H            ; TAB
00A6:                   ZTO     .EQU    0A6H            ; TO
00A7:                   ZFN     .EQU    0A7H            ; FN
00A8:                   ZSPC    .EQU    0A8H            ; SPC
00A9:                   ZTHEN   .EQU    0A9H            ; THEN
00AA:                   ZNOT    .EQU    0AAH            ; NOT
00AB:                   ZSTEP   .EQU    0ABH            ; STEP
                        
00AC:                   ZPLUS   .EQU    0ACH            ; +
00AD:                   ZMINUS  .EQU    0ADH            ; -
00AE:                   ZTIMES  .EQU    0AEH            ; *
00AF:                   ZDIV    .EQU    0AFH            ; /
00B2:                   ZOR     .EQU    0B2H            ; OR
00B3:                   ZGTR    .EQU    0B3H            ; >
00B4:                   ZEQUAL  .EQU    0B4H            ; M
00B5:                   ZLTH    .EQU    0B5H            ; <
00B6:                   ZSGN    .EQU    0B6H            ; SGN
00C7:                   ZPOINT  .EQU    0C7H            ; POINT
00CF:                   ZLEFT   .EQU    0CDH +2         ; LEFT$
                        
                        ; ARITHMETIC PRECEDENCE TABLE
                        
05EC: 79                PRITAB: .BYTE   79H             ; Precedence value
05ED: 221B                      .WORD   PADD            ; FPREG = <last> + FPREG
                        
05EF: 79                        .BYTE   79H             ; Precedence value
05F0: 5617                      .WORD   PSUB            ; FPREG = <last> - FPREG
                        
05F2: 7C                        .BYTE   7CH             ; Precedence value
05F3: 9418                      .WORD   MULT            ; PPREG = <last> * FPREG
                        
05F5: 7C                        .BYTE   7CH             ; Precedence value
05F6: F518                      .WORD   DIV             ; FPREG = <last> / FPREG
                        
05F8: 7F                        .BYTE   7FH             ; Precedence value
05F9: 431C                      .WORD   POWER           ; FPREG = <last> ^ FPREG
                        
05FB: 50                        .BYTE   50H             ; Precedence value
05FC: 0911                      .WORD   PAND            ; FPREG = <last> AND FPREG
                        
05FE: 46                        .BYTE   46H             ; Precedence value
05FF: 0811                      .WORD   POR             ; FPREG = <last> OR FPREG
                        
                        ; BASIC ERROR CODE LIST
                        
0601: 4E46              ERRORS: .BYTE   "NF"            ; NEXT without FOR
0603: 534E                      .BYTE   "SN"            ; Syntax error
0605: 5247                      .BYTE   "RG"            ; RETURN without GOSUB
0607: 4F44                      .BYTE   "OD"            ; Out of DATA
0609: 4643                      .BYTE   "FC"            ; Illegal function call
060B: 4F56                      .BYTE   "OV"            ; Overflow error
060D: 4F4D                      .BYTE   "OM"            ; Out of memory
060F: 554C                      .BYTE   "UL"            ; Undefined line
0611: 4253                      .BYTE   "BS"            ; Bad subscript
0613: 4444                      .BYTE   "DD"            ; Re-DIMensioned array
0615: 2F30                      .BYTE   "/0"            ; Division by zero
0617: 4944                      .BYTE   "ID"            ; Illegal direct
0619: 544D                      .BYTE   "TM"            ; Type mis-match
061B: 4F53                      .BYTE   "OS"            ; Out of string space
061D: 4C53                      .BYTE   "LS"            ; String too long
061F: 5354                      .BYTE   "ST"            ; String formula too complex
0621: 434E                      .BYTE   "CN"            ; Can't CONTinue
0623: 5546                      .BYTE   "UF"            ; Undefined FN function
0625: 4D4F                      .BYTE   "MO"            ; Missing operand
0627: 4858                      .BYTE   "HX"            ; HEX error
0629: 424E                      .BYTE   "BN"            ; BIN error
                        
                        ; INITIALISATION TABLE -------------------------------------------------------
                        
062B: C3FC03   [10]     INITAB: JP      WARMST          ; Warm start jump
062E: C3190C   [20]             JP      FCERR           ; "USR (X)" jump (Set to Error)
0631: D300     [31]             OUT     (0),A           ; "OUT p,n" skeleton
0633: C9       [41]             RET
0634: D600     [48]             SUB     0               ; Division support routine
0636: 6F       [52]             LD      L,A
0637: 7C       [56]             LD      A,H
0638: DE00     [63]             SBC     A,0
063A: 67       [67]             LD      H,A
063B: 78       [71]             LD      A,B
063C: DE00     [78]             SBC     A,0
063E: 47       [82]             LD      B,A
063F: 3E00     [89]             LD      A,0
0641: C9       [99]             RET
0642: 000000                    .BYTE   0,0,0                   ; Random number seed table used by RND
0645: 354ACA99                  .BYTE   035H,04AH,0CAH,099H     ;-2.65145E+07
0649: 391C7698                  .BYTE   039H,01CH,076H,098H     ; 1.61291E+07
064D: 2295B398                  .BYTE   022H,095H,0B3H,098H     ;-1.17691E+07
0651: 0ADD4798                  .BYTE   00AH,0DDH,047H,098H     ; 1.30983E+07
0655: 53D19999                  .BYTE   053H,0D1H,099H,099H     ;-2-01612E+07
0659: 0A1A9F98                  .BYTE   00AH,01AH,09FH,098H     ;-1.04269E+07
065D: 65BCCD98                  .BYTE   065H,0BCH,0CDH,098H     ;-1.34831E+07
0661: D6773E98                  .BYTE   0D6H,077H,03EH,098H     ; 1.24825E+07
0665: 52C74F80                  .BYTE   052H,0C7H,04FH,080H     ; Last random number
0669: DB00     [110]            IN      A,(0)           ; INP (x) skeleton
066B: C9       [120]            RET
066C: 01                        .BYTE   1               ; POS (x) number (1)
066D: FF                        .BYTE   255             ; Terminal width (255 = no auto CRLF)
066E: 1C                        .BYTE   28              ; Width for commas (3 columns)
066F: 00                        .BYTE   0               ; No nulls after input bytes
0670: 00                        .BYTE   0               ; Output enabled (^O off)
0671: 1400                      .WORD   20              ; Initial lines counter
0673: 1400                      .WORD   20              ; Initial lines number
0675: 0000                      .WORD   0               ; Array load/save check sum
0677: 00                        .BYTE   0               ; Break not by NMI
0678: 00                        .BYTE   0               ; Break flag
0679: C33F09   [130]            JP      TTYLIN          ; Input reflection (set to TTY)
067C: C30000   [140]            JP      $0000           ; POINT reflection unused
067F: C30000   [150]            JP      $0000           ; SET reflection
0682: C30000   [160]            JP      $0000          	; RESET reflection
0685: A221                      .WORD   STLOOK          ; Temp string space
0687: FEFF                      .WORD   -2              ; Current line number (cold)
0689: 3F21                      .WORD   PROGST+1        ; Start of program text
068B:                   INITBE:                         
                        
                        ; END OF INITIALISATION TABLE ---------------------------------------------------
                        
068B: 20457272          ERRMSG: .BYTE   " Error",0
068F: 6F7200            
0692: 20696E20          INMSG:  .BYTE   " in ",0
0696: 00                
0696:                   ZERBYT  .EQU    $-1             ; A zero byte
0697: 4F6B0D0A          OKMSG:  .BYTE   "Ok",CR,LF,0,0
069B: 0000              
069D: 42726561          BRKMSG: .BYTE   "Break",0
06A1: 6B00              
                        
06A3: 210400   [10]     BAKSTK: LD      HL,4            ; Look for "FOR" block with
06A6: 39       [21]             ADD     HL,SP           ; same index as specified
06A7: 7E       [ 7]     LOKFOR: LD      A,(HL)          ; Get block ID
06A8: 23       [13]             INC     HL              ; Point to index address
06A9: FE81     [20]             CP      ZFOR            ; Is it a "FOR" token
06AB: C0       [25|31]          RET     NZ              ; No - exit
06AC: 4E       [32]             LD      C,(HL)          ; BC = Address of "FOR" index
06AD: 23       [38]             INC     HL
06AE: 46       [45]             LD      B,(HL)
06AF: 23       [51]             INC     HL              ; Point to sign of STEP
06B0: E5       [62]             PUSH    HL              ; Save pointer to sign
06B1: 69       [66]             LD      L,C             ; HL = address of "FOR" index
06B2: 60       [70]             LD      H,B
06B3: 7A       [74]             LD      A,D             ; See if an index was specified
06B4: B3       [78]             OR      E               ; DE = 0 if no index specified
06B5: EB       [82]             EX      DE,HL           ; Specified index into HL
06B6: CABD06   [92|92]          JP      Z,INDFND        ; Skip if no index given
06B9: EB       [96]             EX      DE,HL           ; Index back into DE
06BA: CDBB09   [113]            CALL    CPDEHL          ; Compare index with one given
06BD: 010D00   [10]     INDFND: LD      BC,16-3         ; Offset to next block
06C0: E1       [20]             POP     HL              ; Restore pointer to sign
06C1: C8       [25|31]          RET     Z               ; Return if block found
06C2: 09       [36]             ADD     HL,BC           ; Point to next block
06C3: C3A706   [46]             JP      LOKFOR          ; Keep on looking
                        
06C6: CDE006   [17]     MOVUP:  CALL    ENFMEM          ; See if enough memory
06C9: C5       [11]     MOVSTR: PUSH    BC              ; Save end of source
06CA: E3       [30]             EX      (SP),HL         ; Swap source and dest" end
06CB: C1       [40]             POP     BC              ; Get end of destination
06CC: CDBB09   [17]     MOVLP:  CALL    CPDEHL          ; See if list moved
06CF: 7E       [24]             LD      A,(HL)          ; Get byte
06D0: 02       [31]             LD      (BC),A          ; Move it
06D1: C8       [36|42]          RET     Z               ; Exit if all done
06D2: 0B       [42]             DEC     BC              ; Next byte to move to
06D3: 2B       [48]             DEC     HL              ; Next byte to move
06D4: C3CC06   [58]             JP      MOVLP           ; Loop until all bytes moved
                        
06D7: E5       [11]     CHKSTK: PUSH    HL              ; Save code string address
06D8: 2A1F21   [27]             LD      HL,(ARREND)     ; Lowest free memory
06DB: 0600     [34]             LD      B,0             ; BC = Number of levels to test
06DD: 09       [45]             ADD     HL,BC           ; 2 Bytes for each level
06DE: 09       [56]             ADD     HL,BC
06DF: 3E                        .BYTE   3EH             ; Skip "PUSH HL"
06E0: E5       [11]     ENFMEM: PUSH    HL              ; Save code string address
06E1: 3ED0     [18]             LD      A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
06E3: 95       [22]             SUB     L
06E4: 6F       [26]             LD      L,A
06E5: 3EFF     [33]             LD      A,0FFH; HIGH (-48) ; 48 Bytes minimum RAM
06E7: 9C       [37]             SBC     A,H
06E8: DAEF06   [47|47]          JP      C,OMERR         ; Not enough - ?OM Error
06EB: 67       [51]             LD      H,A
06EC: 39       [62]             ADD     HL,SP           ; Test if stack is overflowed
06ED: E1       [72]             POP     HL              ; Restore code string address
06EE: D8       [77|83]          RET     C               ; Return if enough mmory
06EF: 1E0C     [ 7]     OMERR:  LD      E,OM            ; ?OM Error
06F1: C30E07   [17]             JP      ERROR
                        
06F4: 2A0E21   [16]     DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
06F7: 22A120   [32]             LD      (LINEAT),HL     ; Save as current line
06FA: 1E02     [ 7]     SNERR:  LD      E,SN            ; ?SN Error
06FC: 01                        .BYTE   01H             ; Skip "LD E,DZ"
06FD: 1E14     [ 7]     DZERR:  LD      E,DZ            ; ?/0 Error
06FF: 01                        .BYTE   01H             ; Skip "LD E,NF"
0700: 1E00     [ 7]     NFERR:  LD      E,NF            ; ?NF Error
0702: 01                        .BYTE   01H             ; Skip "LD E,DD"
0703: 1E12     [ 7]     DDERR:  LD      E,DD            ; ?DD Error
0705: 01                        .BYTE   01H             ; Skip "LD E,UF"
0706: 1E22     [ 7]     UFERR:  LD      E,UF            ; ?UF Error
0708: 01                        .BYTE   01H             ; Skip "LD E,OV
0709: 1E0A     [ 7]     OVERR:  LD      E,OV            ; ?OV Error
070B: 01                        .BYTE   01H             ; Skip "LD E,TM"
070C: 1E18     [ 7]     TMERR:  LD      E,TM            ; ?TM Error
                        
070E: CD2C08   [17]     ERROR:  CALL    CLREG           ; Clear registers and stack
0711: 328A20   [30]             LD      (CTLOFG),A      ; Enable output (A is 0)
0714: CDED0D   [47]             CALL    STTLIN          ; Start new line
0717: 210106   [57]             LD      HL,ERRORS       ; Point to error codes
071A: 57       [61]             LD      D,A             ; D = 0 (A is 0)
071B: 3E3F     [68]             LD      A,'?'
071D: CDCC09   [85]             CALL    OUTC            ; Output '?'
0720: 19       [96]             ADD     HL,DE           ; Offset to correct error code
0721: 7E       [103]            LD      A,(HL)          ; First character
0722: CDCC09   [120]            CALL    OUTC            ; Output it
0725: CD4B0B   [137]            CALL    GETCHR          ; Get next character
0728: CDCC09   [154]            CALL    OUTC            ; Output it
072B: 218B06   [164]            LD      HL,ERRMSG       ; "Error" message
072E: CD9814   [17]     ERRIN:  CALL    PRS             ; Output message
0731: 2AA120   [33]             LD      HL,(LINEAT)     ; Get line of error
0734: 11FEFF   [43]             LD      DE,-2           ; Cold start error if -2
0737: CDBB09   [60]             CALL    CPDEHL          ; See if cold start error
073A: CA8A03   [70|70]          JP      Z,CSTART        ; Cold start error - Restart
073D: 7C       [74]             LD      A,H             ; Was it a direct error?
073E: A5       [78]             AND     L               ; Line = -1 if direct error
073F: 3C       [82]             INC     A
0740: C4331B   [92|99]          CALL    NZ,LINEIN       ; No - output line of error
0743: 3E                        .BYTE   3EH             ; Skip "POP BC"
0744: C1       [10]     POPNOK: POP     BC              ; Drop address in input buffer
                        
0745: AF       [ 4]     PRNTOK: XOR     A               ; Output "Ok" and get command
0746: 328A20   [17]             LD      (CTLOFG),A      ; Enable output
0749: CDED0D   [34]             CALL    STTLIN          ; Start new line
074C: 219706   [44]             LD      HL,OKMSG        ; "Ok" message
074F: CD9814   [61]             CALL    PRS             ; Output "Ok"
0752: 21FFFF   [10]     GETCMD: LD      HL,-1           ; Flag direct mode
0755: 22A120   [26]             LD      (LINEAT),HL     ; Save as current line
0758: CD3F09   [43]             CALL    GETLIN          ; Get an input line
075B: DA5207   [53|53]          JP      C,GETCMD        ; Get line again if break
075E: CD4B0B   [70]             CALL    GETCHR          ; Get first character
0761: 3C       [74]             INC     A               ; Test if end of line
0762: 3D       [78]             DEC     A               ; Without affecting Carry
0763: CA5207   [88|88]          JP      Z,GETCMD        ; Nothing entered - Get another
0766: F5       [99]             PUSH    AF              ; Save Carry status
0767: CD1E0C   [116]            CALL    ATOH            ; Get line number into DE
076A: D5       [127]            PUSH    DE              ; Save line number
076B: CD5608   [144]            CALL    CRUNCH          ; Tokenise rest of line
076E: 47       [148]            LD      B,A             ; Length of tokenised line
076F: D1       [158]            POP     DE              ; Restore line number
0770: F1       [168]            POP     AF              ; Restore Carry
0771: D22B0B   [178|178]        JP      NC,EXCUTE       ; No line number - Direct mode
0774: D5       [189]            PUSH    DE              ; Save line number
0775: C5       [200]            PUSH    BC              ; Save length of tokenised line
0776: AF       [204]            XOR     A
0777: 321121   [217]            LD      (LSTBIN),A      ; Clear last byte input
077A: CD4B0B   [234]            CALL    GETCHR          ; Get next character
077D: B7       [238]            OR      A               ; Set flags
077E: F5       [249]            PUSH    AF              ; And save them
077F: CDE607   [266]            CALL    SRCHLN          ; Search for line number in DE
0782: DA8B07   [276|276]        JP      C,LINFND        ; Jump if line found
0785: F1       [286]            POP     AF              ; Get status
0786: F5       [297]            PUSH    AF              ; And re-save
0787: CABF0C   [307|307]        JP      Z,ULERR         ; Nothing after number - Error
078A: B7       [311]            OR      A               ; Clear Carry
078B: C5       [11]     LINFND: PUSH    BC              ; Save address of line in prog
078C: D2A207   [21|21]          JP      NC,INEWLN       ; Line not found - Insert new
078F: EB       [25]             EX      DE,HL           ; Next line address in DE
0790: 2A1B21   [41]             LD      HL,(PROGND)     ; End of program
0793: 1A       [ 7]     SFTPRG: LD      A,(DE)          ; Shift rest of program down
0794: 02       [14]             LD      (BC),A
0795: 03       [20]             INC     BC              ; Next destination
0796: 13       [26]             INC     DE              ; Next source
0797: CDBB09   [43]             CALL    CPDEHL          ; All done?
079A: C29307   [53|53]          JP      NZ,SFTPRG       ; More to do
079D: 60       [57]             LD      H,B             ; HL - New end of program
079E: 69       [61]             LD      L,C
079F: 221B21   [77]             LD      (PROGND),HL     ; Update end of program
                        
07A2: D1       [10]     INEWLN: POP     DE              ; Get address of line,
07A3: F1       [20]             POP     AF              ; Get status
07A4: CAC907   [30|30]          JP      Z,SETPTR        ; No text - Set up pointers
07A7: 2A1B21   [46]             LD      HL,(PROGND)     ; Get end of program
07AA: E3       [65]             EX      (SP),HL         ; Get length of input line
07AB: C1       [75]             POP     BC              ; End of program to BC
07AC: 09       [86]             ADD     HL,BC           ; Find new end
07AD: E5       [97]             PUSH    HL              ; Save new end
07AE: CDC606   [114]            CALL    MOVUP           ; Make space for line
07B1: E1       [124]            POP     HL              ; Restore new end
07B2: 221B21   [140]            LD      (PROGND),HL     ; Update end of program pointer
07B5: EB       [144]            EX      DE,HL           ; Get line to move up in HL
07B6: 74       [151]            LD      (HL),H          ; Save MSB
07B7: D1       [161]            POP     DE              ; Get new line number
07B8: 23       [167]            INC     HL              ; Skip pointer
07B9: 23       [173]            INC     HL
07BA: 73       [180]            LD      (HL),E          ; Save LSB of line number
07BB: 23       [186]            INC     HL
07BC: 72       [193]            LD      (HL),D          ; Save MSB of line number
07BD: 23       [199]            INC     HL              ; To first byte in line
07BE: 11A620   [209]            LD      DE,BUFFER       ; Copy buffer to program
07C1: 1A       [ 7]     MOVBUF: LD      A,(DE)          ; Get source
07C2: 77       [14]             LD      (HL),A          ; Save destinations
07C3: 23       [20]             INC     HL              ; Next source
07C4: 13       [26]             INC     DE              ; Next destination
07C5: B7       [30]             OR      A               ; Done?
07C6: C2C107   [40|40]          JP      NZ,MOVBUF       ; No - Repeat
07C9: CD1208   [17]     SETPTR: CALL    RUNFST          ; Set line pointers
07CC: 23       [23]             INC     HL              ; To LSB of pointer
07CD: EB       [27]             EX      DE,HL           ; Address to DE
07CE: 62       [ 4]     PTRLP:  LD      H,D             ; Address to HL
07CF: 6B       [ 8]             LD      L,E
07D0: 7E       [15]             LD      A,(HL)          ; Get LSB of pointer
07D1: 23       [21]             INC     HL              ; To MSB of pointer
07D2: B6       [28]             OR      (HL)            ; Compare with MSB pointer
07D3: CA5207   [38|38]          JP      Z,GETCMD        ; Get command line if end
07D6: 23       [44]             INC     HL              ; To LSB of line number
07D7: 23       [50]             INC     HL              ; Skip line number
07D8: 23       [56]             INC     HL              ; Point to first byte in line
07D9: AF       [60]             XOR     A               ; Looking for 00 byte
07DA: BE       [ 7]     FNDEND: CP      (HL)            ; Found end of line?
07DB: 23       [13]             INC     HL              ; Move to next byte
07DC: C2DA07   [23|23]          JP      NZ,FNDEND       ; No - Keep looking
07DF: EB       [27]             EX      DE,HL           ; Next line address to HL
07E0: 73       [34]             LD      (HL),E          ; Save LSB of pointer
07E1: 23       [40]             INC     HL
07E2: 72       [47]             LD      (HL),D          ; Save MSB of pointer
07E3: C3CE07   [57]             JP      PTRLP           ; Do next line
                        
07E6: 2AA320   [16]     SRCHLN: LD      HL,(BASTXT)     ; Start of program text
07E9: 44       [ 4]     SRCHLP: LD      B,H             ; BC = Address to look at
07EA: 4D       [ 8]             LD      C,L
07EB: 7E       [15]             LD      A,(HL)          ; Get address of next line
07EC: 23       [21]             INC     HL
07ED: B6       [28]             OR      (HL)            ; End of program found?
07EE: 2B       [34]             DEC     HL
07EF: C8       [39|45]          RET     Z               ; Yes - Line not found
07F0: 23       [45]             INC     HL
07F1: 23       [51]             INC     HL
07F2: 7E       [58]             LD      A,(HL)          ; Get LSB of line number
07F3: 23       [64]             INC     HL
07F4: 66       [71]             LD      H,(HL)          ; Get MSB of line number
07F5: 6F       [75]             LD      L,A
07F6: CDBB09   [92]             CALL    CPDEHL          ; Compare with line in DE
07F9: 60       [96]             LD      H,B             ; HL = Start of this line
07FA: 69       [100]            LD      L,C
07FB: 7E       [107]            LD      A,(HL)          ; Get LSB of next line address
07FC: 23       [113]            INC     HL
07FD: 66       [120]            LD      H,(HL)          ; Get MSB of next line address
07FE: 6F       [124]            LD      L,A             ; Next line to HL
07FF: 3F       [128]            CCF
0800: C8       [133|139]        RET     Z               ; Lines found - Exit
0801: 3F       [137]            CCF
0802: D0       [142|148]        RET     NC              ; Line not found,at line after
0803: C3E907   [152]            JP      SRCHLP          ; Keep looking
                        
0806: C0       [ 5|11]  NEW:    RET     NZ              ; Return if any more on line
0807: 2AA320   [16]     CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
080A: AF       [20]             XOR     A               ; Set program area to empty
080B: 77       [27]             LD      (HL),A          ; Save LSB = 00
080C: 23       [33]             INC     HL
080D: 77       [40]             LD      (HL),A          ; Save MSB = 00
080E: 23       [46]             INC     HL
080F: 221B21   [62]             LD      (PROGND),HL     ; Set program end
                        
0812: 2AA320   [16]     RUNFST: LD      HL,(BASTXT)     ; Clear all variables
0815: 2B       [22]             DEC     HL
                        
0816: 221321   [16]     INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
0819: 2AF420   [32]             LD      HL,(LSTRAM)     ; Get end of RAM
081C: 220821   [48]             LD      (STRBOT),HL     ; Clear string space
081F: AF       [52]             XOR     A
0820: CD5B0B   [69]             CALL    RESTOR          ; Reset DATA pointers
0823: 2A1B21   [85]             LD      HL,(PROGND)     ; Get end of program
0826: 221D21   [101]            LD      (VAREND),HL     ; Clear variables
0829: 221F21   [117]            LD      (ARREND),HL     ; Clear arrays
                        
082C: C1       [10]     CLREG:  POP     BC              ; Save return address
082D: 2A9F20   [26]             LD      HL,(STRSPC)     ; Get end of working RAN
0830: F9       [32]             LD      SP,HL           ; Set stack
0831: 21F820   [42]             LD      HL,TMSTPL       ; Temporary string pool
0834: 22F620   [58]             LD      (TMSTPT),HL     ; Reset temporary string ptr
0837: AF       [62]             XOR     A               ; A = 00
0838: 6F       [66]             LD      L,A             ; HL = 0000
0839: 67       [70]             LD      H,A
083A: 221921   [86]             LD      (CONTAD),HL     ; No CONTinue
083D: 321021   [99]             LD      (FORFLG),A      ; Clear FOR flag
0840: 222321   [115]            LD      (FNRGNM),HL     ; Clear FN argument
0843: E5       [126]            PUSH    HL              ; HL = 0000
0844: C5       [137]            PUSH    BC              ; Put back return
0845: 2A1321   [16]     DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
0848: C9       [26]             RET                     ; Return to execution driver
                        
0849: 3E3F     [ 7]     PROMPT: LD      A,'?'           ; '?'
084B: CDCC09   [24]             CALL    OUTC            ; Output character
084E: 3E20     [31]             LD      A,' '           ; Space
0850: CDCC09   [48]             CALL    OUTC            ; Output character
0853: C39320   [58]             JP      RINPUT          ; Get input line
                        
0856: AF       [ 4]     CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
0857: 32F320   [17]             LD      (DATFLG),A      ; Reset literal flag
085A: 0E05     [24]             LD      C,2+3           ; 2 byte number and 3 nulls
085C: 11A620   [34]             LD      DE,BUFFER       ; Start of input buffer
085F: 7E       [ 7]     CRNCLP: LD      A,(HL)          ; Get byte
0860: FE20     [14]             CP      ' '             ; Is it a space?
0862: CADE08   [24|24]          JP      Z,MOVDIR        ; Yes - Copy direct
0865: 47       [28]             LD      B,A             ; Save character
0866: FE22     [35]             CP      '"'             ; Is it a quote?
0868: CAFE08   [45|45]          JP      Z,CPYLIT        ; Yes - Copy literal string
086B: B7       [49]             OR      A               ; Is it end of buffer?
086C: CA0509   [59|59]          JP      Z,ENDBUF        ; Yes - End buffer
086F: 3AF320   [72]             LD      A,(DATFLG)      ; Get data type
0872: B7       [76]             OR      A               ; Literal?
0873: 7E       [83]             LD      A,(HL)          ; Get byte to copy
0874: C2DE08   [93|93]          JP      NZ,MOVDIR       ; Literal - Copy direct
0877: FE3F     [100]            CP      '?'             ; Is it '?' short for PRINT
0879: 3E9E     [107]            LD      A,ZPRINT        ; "PRINT" token
087B: CADE08   [117|117]        JP      Z,MOVDIR        ; Yes - replace it
087E: 7E       [124]            LD      A,(HL)          ; Get byte again
087F: FE30     [131]            CP      '0'             ; Is it less than '0'
0881: DA8908   [141|141]        JP      C,FNDWRD        ; Yes - Look for reserved words
0884: FE3C     [148]            CP      60; ";"+1           ; Is it "0123456789:;" ?
0886: DADE08   [158|158]        JP      C,MOVDIR        ; Yes - copy it direct
0889: D5       [11]     FNDWRD: PUSH    DE              ; Look for reserved words
088A: 118204   [21]             LD      DE,WORDS-1      ; Point to table
088D: C5       [32]             PUSH    BC              ; Save count
088E: 01DA08   [42]             LD      BC,RETNAD       ; Where to return to
0891: C5       [53]             PUSH    BC              ; Save return address
0892: 067F     [60]             LD      B,ZEND-1        ; First token value -1
0894: 7E       [67]             LD      A,(HL)          ; Get byte
0895: FE61     [74]             CP      'a'             ; Less than 'a' ?
0897: DAA208   [84|84]          JP      C,SEARCH        ; Yes - search for words
089A: FE7B     [91]             CP      'z'+1           ; Greater than 'z' ?
089C: D2A208   [101|101]        JP      NC,SEARCH       ; Yes - search for words
089F: E65F     [108]            AND     01011111B       ; Force upper case
08A1: 77       [115]            LD      (HL),A          ; Replace byte
08A2: 4E       [ 7]     SEARCH: LD      C,(HL)          ; Search for a word
08A3: EB       [11]             EX      DE,HL
08A4: 23       [ 6]     GETNXT: INC     HL              ; Get next reserved word
08A5: B6       [13]             OR      (HL)            ; Start of word?
08A6: F2A408   [23|23]          JP      P,GETNXT        ; No - move on
08A9: 04       [27]             INC     B               ; Increment token value
08AA: 7E       [34]             LD      A, (HL)         ; Get byte from table
08AB: E67F     [41]             AND     01111111B       ; Strip bit 7
08AD: C8       [46|52]          RET     Z               ; Return if end of list
08AE: B9       [50]             CP      C               ; Same character as in buffer?
08AF: C2A408   [60|60]          JP      NZ,GETNXT       ; No - get next word
08B2: EB       [64]             EX      DE,HL
08B3: E5       [75]             PUSH    HL              ; Save start of word
                        
08B4: 13       [ 6]     NXTBYT: INC     DE              ; Look through rest of word
08B5: 1A       [13]             LD      A,(DE)          ; Get byte from table
08B6: B7       [17]             OR      A               ; End of word ?
08B7: FAD608   [27|27]          JP      M,MATCH         ; Yes - Match found
08BA: 4F       [31]             LD      C,A             ; Save it
08BB: 78       [35]             LD      A,B             ; Get token value
08BC: FE88     [42]             CP      ZGOTO           ; Is it "GOTO" token ?
08BE: C2C508   [52|52]          JP      NZ,NOSPC        ; No - Don't allow spaces
08C1: CD4B0B   [69]             CALL    GETCHR          ; Get next character
08C4: 2B       [75]             DEC     HL              ; Cancel increment from GETCHR
08C5: 23       [ 6]     NOSPC:  INC     HL              ; Next byte
08C6: 7E       [13]             LD      A,(HL)          ; Get byte
08C7: FE61     [20]             CP      'a'             ; Less than 'a' ?
08C9: DACE08   [30|30]          JP      C,NOCHNG        ; Yes - don't change
08CC: E65F     [37]             AND     01011111B       ; Make upper case
08CE: B9       [ 4]     NOCHNG: CP      C               ; Same as in buffer ?
08CF: CAB408   [14|14]          JP      Z,NXTBYT        ; Yes - keep testing
08D2: E1       [24]             POP     HL              ; Get back start of word
08D3: C3A208   [34]             JP      SEARCH          ; Look at next word
                        
08D6: 48       [ 4]     MATCH:  LD      C,B             ; Word found - Save token value
08D7: F1       [14]             POP     AF              ; Throw away return
08D8: EB       [18]             EX      DE,HL
08D9: C9       [28]             RET                     ; Return to "RETNAD"
08DA: EB       [ 4]     RETNAD: EX      DE,HL           ; Get address in string
08DB: 79       [ 8]             LD      A,C             ; Get token value
08DC: C1       [18]             POP     BC              ; Restore buffer length
08DD: D1       [28]             POP     DE              ; Get destination address
08DE: 23       [ 6]     MOVDIR: INC     HL              ; Next source in buffer
08DF: 12       [13]             LD      (DE),A          ; Put byte in buffer
08E0: 13       [19]             INC     DE              ; Move up buffer
08E1: 0C       [23]             INC     C               ; Increment length of buffer
08E2: D63A     [30]             SUB     ':'             ; End of statement?
08E4: CAEC08   [40|40]          JP      Z,SETLIT        ; Jump if multi-statement line
08E7: FE49     [47]             CP      ZDATA-3AH       ; Is it DATA statement ?
08E9: C2EF08   [57|57]          JP      NZ,TSTREM       ; No - see if REM
08EC: 32F320   [13]     SETLIT: LD      (DATFLG),A      ; Set literal flag
08EF: D654     [ 7]     TSTREM: SUB     ZREM-3AH        ; Is it REM?
08F1: C25F08   [17|17]          JP      NZ,CRNCLP       ; No - Leave flag
08F4: 47       [21]             LD      B,A             ; Copy rest of buffer
08F5: 7E       [ 7]     NXTCHR: LD      A,(HL)          ; Get byte
08F6: B7       [11]             OR      A               ; End of line ?
08F7: CA0509   [21|21]          JP      Z,ENDBUF        ; Yes - Terminate buffer
08FA: B8       [25]             CP      B               ; End of statement ?
08FB: CADE08   [35|35]          JP      Z,MOVDIR        ; Yes - Get next one
08FE: 23       [ 6]     CPYLIT: INC     HL              ; Move up source string
08FF: 12       [13]             LD      (DE),A          ; Save in destination
0900: 0C       [17]             INC     C               ; Increment length
0901: 13       [23]             INC     DE              ; Move up destination
0902: C3F508   [33]             JP      NXTCHR          ; Repeat
                        
0905: 21A520   [10]     ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
0908: 12       [17]             LD      (DE),A          ; Mark end of buffer (A = 00)
0909: 13       [23]             INC     DE
090A: 12       [30]             LD      (DE),A          ; A = 00
090B: 13       [36]             INC     DE
090C: 12       [43]             LD      (DE),A          ; A = 00
090D: C9       [53]             RET
                        
090E: 3A8920   [13]     DODEL:  LD      A,(NULFLG)      ; Get null flag status
0911: B7       [17]             OR      A               ; Is it zero?
0912: 3E00     [24]             LD      A,0             ; Zero A - Leave flags
0914: 328920   [37]             LD      (NULFLG),A      ; Zero null flag
0917: C22209   [47|47]          JP      NZ,ECHDEL       ; Set - Echo it
091A: 05       [51]             DEC     B               ; Decrement length
091B: CA3F09   [61|61]          JP      Z,GETLIN        ; Get line again if empty
091E: CDCC09   [78]             CALL    OUTC            ; Output null character
0921: 3E                        .BYTE   3EH             ; Skip "DEC B"
0922: 05       [ 4]     ECHDEL: DEC     B               ; Count bytes in buffer
0923: 2B       [10]             DEC     HL              ; Back space buffer
0924: CA3609   [20|20]          JP      Z,OTKLN         ; No buffer - Try again
0927: 7E       [27]             LD      A,(HL)          ; Get deleted byte
0928: CDCC09   [44]             CALL    OUTC            ; Echo it
092B: C34809   [54]             JP      MORINP          ; Get more input
                        
092E: 05       [ 4]     DELCHR: DEC     B               ; Count bytes in buffer
092F: 2B       [10]             DEC     HL              ; Back space buffer
0930: CDCC09   [27]             CALL    OUTC            ; Output character in A
0933: C24809   [37|37]          JP      NZ,MORINP       ; Not end - Get more
0936: CDCC09   [17]     OTKLN:  CALL    OUTC            ; Output character in A
0939: CDFA0D   [17]     KILIN:  CALL    PRNTCRLF        ; Output CRLF
093C: C33F09   [27]             JP      TTYLIN          ; Get line again
                        
093F:                   GETLIN:
093F: 21A620   [10]     TTYLIN: LD      HL,BUFFER       ; Get a line by character
0942: 0601     [17]             LD      B,1             ; Set buffer as empty
0944: AF       [21]             XOR     A
0945: 328920   [34]             LD      (NULFLG),A      ; Clear null flag
0948: CDF609   [17]     MORINP: CALL    CLOTST          ; Get character and test ^O
094B: 4F       [21]             LD      C,A             ; Save character in C
094C: FE7F     [28]             CP      DEL             ; Delete character?
094E: CA0E09   [38|38]          JP      Z,DODEL         ; Yes - Process it
0951: 3A8920   [51]             LD      A,(NULFLG)      ; Get null flag
0954: B7       [55]             OR      A               ; Test null flag status
0955: CA6109   [65|65]          JP      Z,PROCES        ; Reset - Process character
0958: 3E00     [72]             LD      A,0             ; Set a null
095A: CDCC09   [89]             CALL    OUTC            ; Output null
095D: AF       [93]             XOR     A               ; Clear A
095E: 328920   [106]            LD      (NULFLG),A      ; Reset null flag
0961: 79       [ 4]     PROCES: LD      A,C             ; Get character
0962: FE07     [11]             CP      CTRLG           ; Bell?
0964: CA9E09   [21|21]          JP      Z,PUTCTL        ; Yes - Save it
0967: FE03     [28]             CP      CTRLC           ; Is it control "C"?
0969: CCFA0D   [38|45]          CALL    Z,PRNTCRLF      ; Yes - Output CRLF
096C: 37       [42]             SCF                     ; Flag break
096D: C8       [47|53]          RET     Z               ; Return if control "C"
096E: FE0D     [54]             CP      CR              ; Is it enter?
0970: CAF50D   [64|64]          JP      Z,ENDINP        ; Yes - Terminate input
0973: FE15     [71]             CP      CTRLU           ; Is it control "U"?
0975: CA3909   [81|81]          JP      Z,KILIN         ; Yes - Get another line
                        ;        CP      '@'             ; Is it "kill line"?
                        ;        JP      Z,OTKLN         ; Yes - Kill line
0978: FE08     [88]             CP      BKSP            ; Is it backspace?
097A: CA2E09   [98|98]          JP      Z,DELCHR        ; Yes - Delete character
097D: FE12     [105]            CP      CTRLR           ; Is it control "R"?
097F: C29909   [115|115]        JP      NZ,PUTBUF       ; No - Put in buffer
0982: C5       [126]            PUSH    BC              ; Save buffer length
0983: D5       [137]            PUSH    DE              ; Save DE
0984: E5       [148]            PUSH    HL              ; Save buffer address
0985: 3600     [158]            LD      (HL),0          ; Mark end of buffer
0987: CDCC09   [175]    	CALL    OUTC            ; Output character in A
098A: CDFA0D   [192]            CALL    PRNTCRLF        ; Output CRLF
098D: 21A620   [202]            LD      HL,BUFFER       ; Point to buffer start
0990: CD9814   [219]            CALL    PRS             ; Output buffer
0993: E1       [229]            POP     HL              ; Restore buffer address
0994: D1       [239]            POP     DE              ; Restore DE
0995: C1       [249]            POP     BC              ; Restore buffer length
0996: C34809   [259]            JP      MORINP          ; Get another character
                        
0999: FE20     [ 7]     PUTBUF: CP      ' '             ; Is it a control code?
099B: DA4809   [17|17]          JP      C,MORINP        ; Yes - Ignore
099E: 78       [ 4]     PUTCTL: LD      A,B             ; Get number of bytes in buffer
099F: FE49     [11]             CP      72+1            ; Test for line overflow
09A1: 3E07     [18]             LD      A,CTRLG         ; Set a bell
09A3: D2B309   [28|28]          JP      NC,OUTNBS       ; Ring bell if buffer full
09A6: 79       [32]             LD      A,C             ; Get character
09A7: 71       [39]             LD      (HL),C          ; Save in buffer
09A8: 321121   [52]             LD      (LSTBIN),A      ; Save last input byte
09AB: 23       [58]             INC     HL              ; Move up buffer
09AC: 04       [62]             INC     B               ; Increment length
09AD: CDCC09   [17]     OUTIT:  CALL    OUTC            ; Output the character entered
09B0: C34809   [27]             JP      MORINP          ; Get another character
                        
09B3: CDCC09   [17]     OUTNBS: CALL    OUTC            ; Output bell and back over it
09B6: 3E08     [24]             LD      A,BKSP          ; Set back space
09B8: C3AD09   [34]             JP      OUTIT           ; Output it and get more
                        
09BB: 7C       [ 4]     CPDEHL: LD      A,H             ; Get H
09BC: 92       [ 8]             SUB     D               ; Compare with D
09BD: C0       [13|19]          RET     NZ              ; Different - Exit
09BE: 7D       [17]             LD      A,L             ; Get L
09BF: 93       [21]             SUB     E               ; Compare with E
09C0: C9       [31]             RET                     ; Return status
                        
09C1: 7E       [ 7]     CHKSYN: LD      A,(HL)          ; Check syntax of character
09C2: E3       [26]             EX      (SP),HL         ; Address of test byte
09C3: BE       [33]             CP      (HL)            ; Same as in code string?
09C4: 23       [39]             INC     HL              ; Return address
09C5: E3       [58]             EX      (SP),HL         ; Put it back
09C6: CA4B0B   [68|68]          JP      Z,GETCHR        ; Yes - Get next character
09C9: C3FA06   [78]             JP      SNERR           ; Different - ?SN Error
                        
09CC: F5       [11]     OUTC:   PUSH    AF              ; Save character
09CD: 3A8A20   [24]             LD      A,(CTLOFG)      ; Get control "O" flag
09D0: B7       [28]             OR      A               ; Is it set?
09D1: C2CD14   [38|38]          JP      NZ,POPAF        ; Yes - don't output
09D4: F1       [48]             POP     AF              ; Restore character
09D5: C5       [59]             PUSH    BC              ; Save buffer length
09D6: F5       [70]             PUSH    AF              ; Save character
09D7: FE20     [77]             CP      ' '             ; Is it a control code?
09D9: DAF009   [87|87]          JP      C,DINPOS        ; Yes - Don't INC POS(X)
09DC: 3A8720   [100]            LD      A,(LWIDTH)      ; Get line width
09DF: 47       [104]            LD      B,A             ; To B
09E0: 3AF020   [117]            LD      A,(CURPOS)      ; Get cursor position
09E3: 04       [121]            INC     B               ; Width 255?
09E4: CAEC09   [131|131]        JP      Z,INCLEN        ; Yes - No width limit
09E7: 05       [135]            DEC     B               ; Restore width
09E8: B8       [139]            CP      B               ; At end of line?
09E9: CCFA0D   [149|156]        CALL    Z,PRNTCRLF      ; Yes - output CRLF
09EC: 3C       [ 4]     INCLEN: INC     A               ; Move on one character
09ED: 32F020   [17]             LD      (CURPOS),A      ; Save new position
09F0: F1       [10]     DINPOS: POP     AF              ; Restore character
09F1: C1       [20]             POP     BC              ; Restore buffer length
09F2: CD921F   [37]             CALL    MONOUT          ; Send it
09F5: C9       [47]             RET
                        
09F6: CD561E   [17]     CLOTST: CALL    GETINP          ; Get input character
09F9: E67F     [24]             AND     01111111B       ; Strip bit 7
09FB: FE0F     [31]             CP      CTRLO           ; Is it control "O"?
09FD: C0       [36|42]          RET     NZ              ; No don't flip flag
09FE: 3A8A20   [49]             LD      A,(CTLOFG)      ; Get flag
0A01: 2F       [53]             CPL                     ; Flip it
0A02: 328A20   [66]             LD      (CTLOFG),A      ; Put it back
0A05: AF       [70]             XOR     A               ; Null character
0A06: C9       [80]             RET
                        
0A07: CD1E0C   [17]     LIST:   CALL    ATOH            ; ASCII number to DE
0A0A: C0       [22|28]          RET     NZ              ; Return if anything extra
0A0B: C1       [32]             POP     BC              ; Rubbish - Not needed
0A0C: CDE607   [49]             CALL    SRCHLN          ; Search for line number in DE
0A0F: C5       [60]             PUSH    BC              ; Save address of line
0A10: CD5D0A   [77]             CALL    SETLIN          ; Set up lines counter
0A13: E1       [10]     LISTLP: POP     HL              ; Restore address of line
0A14: 4E       [17]             LD      C,(HL)          ; Get LSB of next line
0A15: 23       [23]             INC     HL
0A16: 46       [30]             LD      B,(HL)          ; Get MSB of next line
0A17: 23       [36]             INC     HL
0A18: 78       [40]             LD      A,B             ; BC = 0 (End of program)?
0A19: B1       [44]             OR      C
0A1A: CA4507   [54|54]          JP      Z,PRNTOK        ; Yes - Go to command mode
0A1D: CD660A   [71]             CALL    COUNT           ; Count lines
0A20: CD760B   [88]             CALL    TSTBRK          ; Test for break key
0A23: C5       [99]             PUSH    BC              ; Save address of next line
0A24: CDFA0D   [116]            CALL    PRNTCRLF        ; Output CRLF
0A27: 5E       [123]            LD      E,(HL)          ; Get LSB of line number
0A28: 23       [129]            INC     HL
0A29: 56       [136]            LD      D,(HL)          ; Get MSB of line number
0A2A: 23       [142]            INC     HL
0A2B: E5       [153]            PUSH    HL              ; Save address of line start
0A2C: EB       [157]            EX      DE,HL           ; Line number to HL
0A2D: CD3B1B   [174]            CALL    PRNTHL          ; Output line number in decimal
0A30: 3E20     [181]            LD      A,' '           ; Space after line number
0A32: E1       [191]            POP     HL              ; Restore start of line address
0A33: CDCC09   [17]     LSTLP2: CALL    OUTC            ; Output character in A
0A36: 7E       [ 7]     LSTLP3: LD      A,(HL)          ; Get next byte in line
0A37: B7       [11]             OR      A               ; End of line?
0A38: 23       [17]             INC     HL              ; To next byte in line
0A39: CA130A   [27|27]          JP      Z,LISTLP        ; Yes - get next line
0A3C: F2330A   [37|37]          JP      P,LSTLP2        ; No token - output it
0A3F: D67F     [44]             SUB     ZEND-1          ; Find and output word
0A41: 4F       [48]             LD      C,A             ; Token offset+1 to C
0A42: 118304   [58]             LD      DE,WORDS        ; Reserved word list
0A45: 1A       [ 7]     FNDTOK: LD      A,(DE)          ; Get character in list
0A46: 13       [13]             INC     DE              ; Move on to next
0A47: B7       [17]             OR      A               ; Is it start of word?
0A48: F2450A   [27|27]          JP      P,FNDTOK        ; No - Keep looking for word
0A4B: 0D       [31]             DEC     C               ; Count words
0A4C: C2450A   [41|41]          JP      NZ,FNDTOK       ; Not there - keep looking
0A4F: E67F     [ 7]     OUTWRD: AND     01111111B       ; Strip bit 7
0A51: CDCC09   [24]             CALL    OUTC            ; Output first character
0A54: 1A       [31]             LD      A,(DE)          ; Get next character
0A55: 13       [37]             INC     DE              ; Move on to next
0A56: B7       [41]             OR      A               ; Is it end of word?
0A57: F24F0A   [51|51]          JP      P,OUTWRD        ; No - output the rest
0A5A: C3360A   [61]             JP      LSTLP3          ; Next byte in line
                        
0A5D: E5       [11]     SETLIN: PUSH    HL              ; Set up LINES counter
0A5E: 2A8D20   [27]             LD      HL,(LINESN)     ; Get LINES number
0A61: 228B20   [43]             LD      (LINESC),HL     ; Save in LINES counter
0A64: E1       [53]             POP     HL
0A65: C9       [63]             RET
                        
0A66: E5       [11]     COUNT:  PUSH    HL              ; Save code string address
0A67: D5       [22]             PUSH    DE
0A68: 2A8B20   [38]             LD      HL,(LINESC)     ; Get LINES counter
0A6B: 11FFFF   [48]             LD      DE,-1
0A6E: ED5A     [63]             ADC     HL,DE           ; Decrement
0A70: 228B20   [79]             LD      (LINESC),HL     ; Put it back
0A73: D1       [89]             POP     DE
0A74: E1       [99]             POP     HL              ; Restore code string address
0A75: F0       [104|110]        RET     P               ; Return if more lines to go
0A76: E5       [115]            PUSH    HL              ; Save code string address
0A77: 2A8D20   [131]            LD      HL,(LINESN)     ; Get LINES number
0A7A: 228B20   [147]            LD      (LINESC),HL     ; Reset LINES counter
0A7D: CD561E   [164]            CALL    GETINP          ; Get input character
0A80: FE03     [171]            CP      CTRLC           ; Is it control "C"?
0A82: CA890A   [181|181]        JP      Z,RSLNBK        ; Yes - Reset LINES and break
0A85: E1       [191]            POP     HL              ; Restore code string address
0A86: C3660A   [201]            JP      COUNT           ; Keep on counting
                        
0A89: 2A8D20   [16]     RSLNBK: LD      HL,(LINESN)     ; Get LINES number
0A8C: 228B20   [32]             LD      (LINESC),HL     ; Reset LINES counter
0A8F: C3FF03   [42]             JP      BRKRET          ; Go and output "Break"
                        
0A92: 3E64     [ 7]     FOR:    LD      A,64H           ; Flag "FOR" assignment
0A94: 321021   [20]             LD      (FORFLG),A      ; Save "FOR" flag
0A97: CD000D   [37]             CALL    LET             ; Set up initial index
0A9A: C1       [47]             POP     BC              ; Drop RETurn address
0A9B: E5       [58]             PUSH    HL              ; Save code string address
0A9C: CDE90C   [75]             CALL    DATA            ; Get next statement address
0A9F: 220C21   [91]             LD      (LOOPST),HL     ; Save it for start of loop
0AA2: 210200   [101]            LD      HL,2            ; Offset for "FOR" block
0AA5: 39       [112]            ADD     HL,SP           ; Point to it
0AA6: CDA706   [17]     FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
0AA9: D1       [27]             POP     DE              ; Get code string address
0AAA: C2C20A   [37|37]          JP      NZ,FORFND       ; No nesting found
0AAD: 09       [48]             ADD     HL,BC           ; Move into "FOR" block
0AAE: D5       [59]             PUSH    DE              ; Save code string address
0AAF: 2B       [65]             DEC     HL
0AB0: 56       [72]             LD      D,(HL)          ; Get MSB of loop statement
0AB1: 2B       [78]             DEC     HL
0AB2: 5E       [85]             LD      E,(HL)          ; Get LSB of loop statement
0AB3: 23       [91]             INC     HL
0AB4: 23       [97]             INC     HL
0AB5: E5       [108]            PUSH    HL              ; Save block address
0AB6: 2A0C21   [124]            LD      HL,(LOOPST)     ; Get address of loop statement
0AB9: CDBB09   [141]            CALL    CPDEHL          ; Compare the FOR loops
0ABC: E1       [151]            POP     HL              ; Restore block address
0ABD: C2A60A   [161|161]        JP      NZ,FORSLP       ; Different FORs - Find another
0AC0: D1       [171]            POP     DE              ; Restore code string address
0AC1: F9       [177]            LD      SP,HL           ; Remove all nested loops
                        
0AC2: EB       [ 4]     FORFND: EX      DE,HL           ; Code string address to HL
0AC3: 0E08     [11]             LD      C,8
0AC5: CDD706   [28]             CALL    CHKSTK          ; Check for 8 levels of stack
0AC8: E5       [39]             PUSH    HL              ; Save code string address
0AC9: 2A0C21   [55]             LD      HL,(LOOPST)     ; Get first statement of loop
0ACC: E3       [74]             EX      (SP),HL         ; Save and restore code string
0ACD: E5       [85]             PUSH    HL              ; Re-save code string address
0ACE: 2AA120   [101]            LD      HL,(LINEAT)     ; Get current line number
0AD1: E3       [120]            EX      (SP),HL         ; Save and restore code string
0AD2: CDC20F   [137]            CALL    TSTNUM          ; Make sure it's a number
0AD5: CDC109   [154]            CALL    CHKSYN          ; Make sure "TO" is next
0AD8: A6                        .BYTE   ZTO          ; "TO" token
0AD9: CDBF0F   [171]            CALL    GETNUM          ; Get "TO" expression value
0ADC: E5       [182]            PUSH    HL              ; Save code string address
0ADD: CDED19   [199]            CALL    BCDEFP          ; Move "TO" value to BCDE
0AE0: E1       [209]            POP     HL              ; Restore code string address
0AE1: C5       [220]            PUSH    BC              ; Save "TO" value in block
0AE2: D5       [231]            PUSH    DE
0AE3: 010081   [241]            LD      BC,8100H        ; BCDE - 1 (default STEP)
0AE6: 51       [245]            LD      D,C             ; C=0
0AE7: 5A       [249]            LD      E,D             ; D=0
0AE8: 7E       [256]            LD      A,(HL)          ; Get next byte in code string
0AE9: FEAB     [263]            CP      ZSTEP           ; See if "STEP" is stated
0AEB: 3E01     [270]            LD      A,1             ; Sign of step = 1
0AED: C2FE0A   [280|280]        JP      NZ,SAVSTP       ; No STEP given - Default to 1
0AF0: CD4B0B   [297]            CALL    GETCHR          ; Jump over "STEP" token
0AF3: CDBF0F   [314]            CALL    GETNUM          ; Get step value
0AF6: E5       [325]            PUSH    HL              ; Save code string address
0AF7: CDED19   [342]            CALL    BCDEFP          ; Move STEP to BCDE
0AFA: CDA119   [359]            CALL    TSTSGN          ; Test sign of FPREG
0AFD: E1       [369]            POP     HL              ; Restore code string address
0AFE: C5       [11]     SAVSTP: PUSH    BC              ; Save the STEP value in block
0AFF: D5       [22]             PUSH    DE
0B00: F5       [33]             PUSH    AF              ; Save sign of STEP
0B01: 33       [39]             INC     SP              ; Don't save flags
0B02: E5       [50]             PUSH    HL              ; Save code string address
0B03: 2A1321   [66]             LD      HL,(BRKLIN)     ; Get address of index variable
0B06: E3       [85]             EX      (SP),HL         ; Save and restore code string
0B07: 0681     [ 7]     PUTFID: LD      B,ZFOR          ; "FOR" block marker
0B09: C5       [18]             PUSH    BC              ; Save it
0B0A: 33       [24]             INC     SP              ; Don't save C
                        
0B0B: CD760B   [17]     RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
0B0E: 221321   [33]             LD      (BRKLIN),HL     ; Save code address for break
0B11: 7E       [40]             LD      A,(HL)          ; Get next byte in code string
0B12: FE3A     [47]             CP      ':'             ; Multi statement line?
0B14: CA2B0B   [57|57]          JP      Z,EXCUTE        ; Yes - Execute it
0B17: B7       [61]             OR      A               ; End of line?
0B18: C2FA06   [71|71]          JP      NZ,SNERR        ; No - Syntax error
0B1B: 23       [77]             INC     HL              ; Point to address of next line
0B1C: 7E       [84]             LD      A,(HL)          ; Get LSB of line pointer
0B1D: 23       [90]             INC     HL
0B1E: B6       [97]             OR      (HL)            ; Is it zero (End of prog)?
0B1F: CAA40B   [107|107]        JP      Z,ENDPRG        ; Yes - Terminate execution
0B22: 23       [113]            INC     HL              ; Point to line number
0B23: 5E       [120]            LD      E,(HL)          ; Get LSB of line number
0B24: 23       [126]            INC     HL
0B25: 56       [133]            LD      D,(HL)          ; Get MSB of line number
0B26: EB       [137]            EX      DE,HL           ; Line number to HL
0B27: 22A120   [153]            LD      (LINEAT),HL     ; Save as current line number
0B2A: EB       [157]            EX      DE,HL           ; Line number back to DE
0B2B: CD4B0B   [17]     EXCUTE: CALL    GETCHR          ; Get key word
0B2E: 110B0B   [27]             LD      DE,RUNCNT       ; Where to RETurn to
0B31: D5       [38]             PUSH    DE              ; Save for RETurn
0B32: C8       [ 5|11]  IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
0B33: D680     [ 7]     ONJMP:  SUB     ZEND            ; Is it a token?
0B35: DA000D   [17|17]          JP      C,LET           ; No - try to assign it
0B38: FE25     [24]             CP      ZNEW+1-ZEND     ; END to NEW ?
0B3A: D2FA06   [34|34]          JP      NC,SNERR        ; Not a key word - ?SN Error
0B3D: 07       [38]             RLCA                    ; Double it
0B3E: 4F       [42]             LD      C,A             ; BC = Offset into table
0B3F: 0600     [49]             LD      B,0
0B41: EB       [53]             EX      DE,HL           ; Save code string address
0B42: 21A205   [63]             LD      HL,WORDTB       ; Keyword address table
0B45: 09       [74]             ADD     HL,BC           ; Point to routine address
0B46: 4E       [81]             LD      C,(HL)          ; Get LSB of routine address
0B47: 23       [87]             INC     HL
0B48: 46       [94]             LD      B,(HL)          ; Get MSB of routine address
0B49: C5       [105]            PUSH    BC              ; Save routine address
0B4A: EB       [109]            EX      DE,HL           ; Restore code string address
                        
0B4B: 23       [ 6]     GETCHR: INC     HL              ; Point to next character
0B4C: 7E       [13]             LD      A,(HL)          ; Get next code string byte
0B4D: FE3A     [20]             CP      ':'             ; Z if ':'
0B4F: D0       [25|31]          RET     NC              ; NC if > "9"
0B50: FE20     [32]             CP      ' '
0B52: CA4B0B   [42|42]          JP      Z,GETCHR        ; Skip over spaces
0B55: FE30     [49]             CP      '0'
0B57: 3F       [53]             CCF                     ; NC if < '0'
0B58: 3C       [57]             INC     A               ; Test for zero - Leave carry
0B59: 3D       [61]             DEC     A               ; Z if Null
0B5A: C9       [71]             RET
                        
0B5B: EB       [ 4]     RESTOR: EX      DE,HL           ; Save code string address
0B5C: 2AA320   [20]             LD      HL,(BASTXT)     ; Point to start of program
0B5F: CA700B   [30|30]          JP      Z,RESTNL        ; Just RESTORE - reset pointer
0B62: EB       [34]             EX      DE,HL           ; Restore code string address
0B63: CD1E0C   [51]             CALL    ATOH            ; Get line number to DE
0B66: E5       [62]             PUSH    HL              ; Save code string address
0B67: CDE607   [79]             CALL    SRCHLN          ; Search for line number in DE
0B6A: 60       [83]             LD      H,B             ; HL = Address of line
0B6B: 69       [87]             LD      L,C
0B6C: D1       [97]             POP     DE              ; Restore code string address
0B6D: D2BF0C   [107|107]        JP      NC,ULERR        ; ?UL Error if not found
0B70: 2B       [ 6]     RESTNL: DEC     HL              ; Byte before DATA statement
0B71: 222121   [16]     UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
0B74: EB       [20]             EX      DE,HL           ; Restore code string address
0B75: C9       [30]             RET
                        
                        
0B76: DB22     [11]     TSTBRK: in	a, (PORT_SIOACTL) ; Check input status
0B78: CB47     [19]     	bit	SIORR0_IDX_RCA, a
0B7A: C8       [24|30]          RET     Z               ; No key, go back
0B7B: CD561E   [41]             CALL	GETINP          ; Get the key into A
0B7E: FE1B     [48]             CP      ESC             ; Escape key?
0B80: 2813     [55|60]          JR      Z,BRK           ; Yes, break
0B82: FE03     [62]             CP      CTRLC           ; <Ctrl-C>
0B84: 280F     [69|74]          JR      Z,BRK           ; Yes, break
0B86: FE13     [76]             CP      CTRLS           ; Stop scrolling?
0B88: C0       [81|87]          RET     NZ              ; Other key, ignore
                        
                        
0B89: CD561E   [17]     STALL:  CALL	GETINP          ; Wait for key
0B8C: FE11     [24]             CP      CTRLQ           ; Resume scrolling?
0B8E: C8       [29|35]          RET      Z              ; Release the chokehold
0B8F: FE03     [36]             CP      CTRLC           ; Second break?
0B91: 2807     [43|48]          JR      Z,STOP          ; Break during hold exits prog
0B93: 18F4     [55]             JR      STALL           ; Loop until <Ctrl-Q> or <brk>
                        
0B95: 3EFF     [ 7]     BRK     LD      A,$FF           ; Set BRKFLG
0B97: 329220   [20]             LD      (BRKFLG),A      ; Store it
                        
                        
0B9A: C0       [ 5|11]  STOP:   RET     NZ              ; Exit if anything else
0B9B: F6                        .BYTE   0F6H            ; Flag "STOP"
0B9C: C0       [ 5|11]  PEND:   RET     NZ              ; Exit if anything else
0B9D: 221321   [21]             LD      (BRKLIN),HL     ; Save point of break
0BA0: 21                        .BYTE   21H             ; Skip "OR 11111111B"
0BA1: F6FF     [ 7]     INPBRK: OR      11111111B       ; Flag "Break" wanted
0BA3: C1       [17]             POP     BC              ; Return not needed and more
0BA4: 2AA120   [16]     ENDPRG: LD      HL,(LINEAT)     ; Get current line number
0BA7: F5       [27]             PUSH    AF              ; Save STOP / END status
0BA8: 7D       [31]             LD      A,L             ; Is it direct break?
0BA9: A4       [35]             AND     H
0BAA: 3C       [39]             INC     A               ; Line is -1 if direct break
0BAB: CAB70B   [49|49]          JP      Z,NOLIN         ; Yes - No line number
0BAE: 221721   [65]             LD      (ERRLIN),HL     ; Save line of break
0BB1: 2A1321   [81]             LD      HL,(BRKLIN)     ; Get point of break
0BB4: 221921   [97]             LD      (CONTAD),HL     ; Save point to CONTinue
0BB7: AF       [ 4]     NOLIN:  XOR     A
0BB8: 328A20   [17]             LD      (CTLOFG),A      ; Enable output
0BBB: CDED0D   [34]             CALL    STTLIN          ; Start a new line
0BBE: F1       [44]             POP     AF              ; Restore STOP / END status
0BBF: 219D06   [54]             LD      HL,BRKMSG       ; "Break" message
0BC2: C22E07   [64|64]          JP      NZ,ERRIN        ; "in line" wanted?
0BC5: C34507   [74]             JP      PRNTOK          ; Go to command mode
                        
0BC8: 2A1921   [16]     CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
0BCB: 7C       [20]             LD      A,H             ; Is it zero?
0BCC: B5       [24]             OR      L
0BCD: 1E20     [31]             LD      E,CN            ; ?CN Error
0BCF: CA0E07   [41|41]          JP      Z,ERROR         ; Yes - output "?CN Error"
0BD2: EB       [45]             EX      DE,HL           ; Save code string address
0BD3: 2A1721   [61]             LD      HL,(ERRLIN)     ; Get line of last break
0BD6: 22A120   [77]             LD      (LINEAT),HL     ; Set up current line number
0BD9: EB       [81]             EX      DE,HL           ; Restore code string address
0BDA: C9       [91]             RET                     ; CONTinue where left off
                        
0BDB: CD2017   [17]     NULL:   CALL    GETINT          ; Get integer 0-255
0BDE: C0       [22|28]          RET     NZ              ; Return if bad value
0BDF: 328620   [35]             LD      (NULLS),A       ; Set nulls number
0BE2: C9       [45]             RET
                        
                        
0BE3: E5       [11]     ACCSUM: PUSH    HL              ; Save address in array
0BE4: 2A8F20   [27]             LD      HL,(CHKSUM)     ; Get check sum
0BE7: 0600     [34]             LD      B,0             ; BC - Value of byte
0BE9: 4F       [38]             LD      C,A
0BEA: 09       [49]             ADD     HL,BC           ; Add byte to check sum
0BEB: 228F20   [65]             LD      (CHKSUM),HL     ; Re-save check sum
0BEE: E1       [75]             POP     HL              ; Restore address in array
0BEF: C9       [85]             RET
                        
0BF0: 7E       [ 7]     CHKLTR: LD      A,(HL)          ; Get byte
0BF1: FE41     [14]             CP      'A'             ; < 'a' ?
0BF3: D8       [19|25]          RET     C               ; Carry set if not letter
0BF4: FE5B     [26]             CP      'Z'+1           ; > 'z' ?
0BF6: 3F       [30]             CCF
0BF7: C9       [40]             RET                     ; Carry set if not letter
                        
0BF8: CD4B0B   [17]     FPSINT: CALL    GETCHR          ; Get next character
0BFB: CDBF0F   [17]     POSINT: CALL    GETNUM          ; Get integer 0 to 32767
0BFE: CDA119   [17]     DEPINT: CALL    TSTSGN          ; Test sign of FPREG
0C01: FA190C   [27|27]          JP      M,FCERR         ; Negative - ?FC Error
0C04: 3A2C21   [13]     DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
0C07: FE90     [20]             CP      80H+16          ; Exponent in range (16 bits)?
0C09: DA491A   [30|30]          JP      C,FPINT         ; Yes - convert it
0C0C: 018090   [40]             LD      BC,9080H        ; BCDE = -32768
0C0F: 110000   [50]             LD      DE,0000
0C12: E5       [61]             PUSH    HL              ; Save code string address
0C13: CD1C1A   [78]             CALL    CMPNUM          ; Compare FPREG with BCDE
0C16: E1       [88]             POP     HL              ; Restore code string address
0C17: 51       [92]             LD      D,C             ; MSB to D
0C18: C8       [97|103]         RET     Z               ; Return if in range
0C19: 1E08     [ 7]     FCERR:  LD      E,FC            ; ?FC Error
0C1B: C30E07   [17]             JP      ERROR           ; Output error-
                        
0C1E: 2B       [ 6]     ATOH:   DEC     HL              ; ASCII number to DE binary
0C1F: 110000   [10]     GETLN:  LD      DE,0            ; Get number to DE
0C22: CD4B0B   [17]     GTLNLP: CALL    GETCHR          ; Get next character
0C25: D0       [22|28]          RET     NC              ; Exit if not a digit
0C26: E5       [33]             PUSH    HL              ; Save code string address
0C27: F5       [44]             PUSH    AF              ; Save digit
0C28: 219819   [54]             LD      HL,65529/10     ; Largest number 65529
0C2B: CDBB09   [71]             CALL    CPDEHL          ; Number in range?
0C2E: DAFA06   [81|81]          JP      C,SNERR         ; No - ?SN Error
0C31: 62       [85]             LD      H,D             ; HL = Number
0C32: 6B       [89]             LD      L,E
0C33: 19       [100]            ADD     HL,DE           ; Times 2
0C34: 29       [111]            ADD     HL,HL           ; Times 4
0C35: 19       [122]            ADD     HL,DE           ; Times 5
0C36: 29       [133]            ADD     HL,HL           ; Times 10
0C37: F1       [143]            POP     AF              ; Restore digit
0C38: D630     [150]            SUB     '0'             ; Make it 0 to 9
0C3A: 5F       [154]            LD      E,A             ; DE = Value of digit
0C3B: 1600     [161]            LD      D,0
0C3D: 19       [172]            ADD     HL,DE           ; Add to number
0C3E: EB       [176]            EX      DE,HL           ; Number to DE
0C3F: E1       [186]            POP     HL              ; Restore code string address
0C40: C3220C   [196]            JP      GTLNLP          ; Go to next character
                        
0C43: CA1608   [10|10]  CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
0C46: CDFB0B   [27]             CALL    POSINT          ; Get integer 0 to 32767 to DE
0C49: 2B       [33]             DEC     HL              ; Cancel increment
0C4A: CD4B0B   [50]             CALL    GETCHR          ; Get next character
0C4D: E5       [61]             PUSH    HL              ; Save code string address
0C4E: 2AF420   [77]             LD      HL,(LSTRAM)     ; Get end of RAM
0C51: CA660C   [87|87]          JP      Z,STORED        ; No value given - Use stored
0C54: E1       [97]             POP     HL              ; Restore code string address
0C55: CDC109   [114]            CALL    CHKSYN          ; Check for comma
0C58: 2C                        .BYTE      ','
0C59: D5       [125]            PUSH    DE              ; Save number
0C5A: CDFB0B   [142]            CALL    POSINT          ; Get integer 0 to 32767
0C5D: 2B       [148]            DEC     HL              ; Cancel increment
0C5E: CD4B0B   [165]            CALL    GETCHR          ; Get next character
0C61: C2FA06   [175|175]        JP      NZ,SNERR        ; ?SN Error if more on line
0C64: E3       [194]            EX      (SP),HL         ; Save code string address
0C65: EB       [198]            EX      DE,HL           ; Number to DE
0C66: 7D       [ 4]     STORED: LD      A,L             ; Get LSB of new RAM top
0C67: 93       [ 8]             SUB     E               ; Subtract LSB of string space
0C68: 5F       [12]             LD      E,A             ; Save LSB
0C69: 7C       [16]             LD      A,H             ; Get MSB of new RAM top
0C6A: 9A       [20]             SBC     A,D             ; Subtract MSB of string space
0C6B: 57       [24]             LD      D,A             ; Save MSB
0C6C: DAEF06   [34|34]          JP      C,OMERR         ; ?OM Error if not enough mem
0C6F: E5       [45]             PUSH    HL              ; Save RAM top
0C70: 2A1B21   [61]             LD      HL,(PROGND)     ; Get program end
0C73: 012800   [71]             LD      BC,40           ; 40 Bytes minimum working RAM
0C76: 09       [82]             ADD     HL,BC           ; Get lowest address
0C77: CDBB09   [99]             CALL    CPDEHL          ; Enough memory?
0C7A: D2EF06   [109|109]        JP      NC,OMERR        ; No - ?OM Error
0C7D: EB       [113]            EX      DE,HL           ; RAM top to HL
0C7E: 229F20   [129]            LD      (STRSPC),HL     ; Set new string space
0C81: E1       [139]            POP     HL              ; End of memory to use
0C82: 22F420   [155]            LD      (LSTRAM),HL     ; Set new top of RAM
0C85: E1       [165]            POP     HL              ; Restore code string address
0C86: C31608   [175]            JP      INTVAR          ; Initialise variables
                        
0C89: CA1208   [10|10]  RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
0C8C: CD1608   [27]             CALL    INTVAR          ; Initialise variables
0C8F: 010B0B   [37]             LD      BC,RUNCNT       ; Execution driver loop
0C92: C3A50C   [47]             JP      RUNLIN          ; RUN from line number
                        
0C95: 0E03     [ 7]     GOSUB:  LD      C,3             ; 3 Levels of stack needed
0C97: CDD706   [24]             CALL    CHKSTK          ; Check for 3 levels of stack
0C9A: C1       [34]             POP     BC              ; Get return address
0C9B: E5       [45]             PUSH    HL              ; Save code string for RETURN
0C9C: E5       [56]             PUSH    HL              ; And for GOSUB routine
0C9D: 2AA120   [72]             LD      HL,(LINEAT)     ; Get current line
0CA0: E3       [91]             EX      (SP),HL         ; Into stack - Code string out
0CA1: 3E8C     [98]             LD      A,ZGOSUB        ; "GOSUB" token
0CA3: F5       [109]            PUSH    AF              ; Save token
0CA4: 33       [115]            INC     SP              ; Don't save flags
                        
0CA5: C5       [11]     RUNLIN: PUSH    BC              ; Save return address
0CA6: CD1E0C   [17]     GOTO:   CALL    ATOH            ; ASCII number to DE binary
0CA9: CDEB0C   [34]             CALL    REM             ; Get end of line
0CAC: E5       [45]             PUSH    HL              ; Save end of line
0CAD: 2AA120   [61]             LD      HL,(LINEAT)     ; Get current line
0CB0: CDBB09   [78]             CALL    CPDEHL          ; Line after current?
0CB3: E1       [88]             POP     HL              ; Restore end of line
0CB4: 23       [94]             INC     HL              ; Start of next line
0CB5: DCE907   [104|111]        CALL    C,SRCHLP        ; Line is after current line
0CB8: D4E607   [114|121]        CALL    NC,SRCHLN       ; Line is before current line
0CBB: 60       [118]            LD      H,B             ; Set up code string address
0CBC: 69       [122]            LD      L,C
0CBD: 2B       [128]            DEC     HL              ; Incremented after
0CBE: D8       [133|139]        RET     C               ; Line found
0CBF: 1E0E     [ 7]     ULERR:  LD      E,UL            ; ?UL Error
0CC1: C30E07   [17]             JP      ERROR           ; Output error message
                        
0CC4: C0       [ 5|11]  RETURN: RET     NZ              ; Return if not just RETURN
0CC5: 16FF     [12]             LD      D,-1            ; Flag "GOSUB" search
0CC7: CDA306   [29]             CALL    BAKSTK          ; Look "GOSUB" block
0CCA: F9       [35]             LD      SP,HL           ; Kill all FORs in subroutine
0CCB: FE8C     [42]             CP      ZGOSUB          ; Test for "GOSUB" token
0CCD: 1E04     [49]             LD      E,RG            ; ?RG Error
0CCF: C20E07   [59|59]          JP      NZ,ERROR        ; Error if no "GOSUB" found
0CD2: E1       [69]             POP     HL              ; Get RETURN line number
0CD3: 22A120   [85]             LD      (LINEAT),HL     ; Save as current
0CD6: 23       [91]             INC     HL              ; Was it from direct statement?
0CD7: 7C       [95]             LD      A,H
0CD8: B5       [99]             OR      L               ; Return to line
0CD9: C2E30C   [109|109]        JP      NZ,RETLIN       ; No - Return to line
0CDC: 3A1121   [122]            LD      A,(LSTBIN)      ; Any INPUT in subroutine?
0CDF: B7       [126]            OR      A               ; If so buffer is corrupted
0CE0: C24407   [136|136]        JP      NZ,POPNOK       ; Yes - Go to command mode
0CE3: 210B0B   [10]     RETLIN: LD      HL,RUNCNT       ; Execution driver loop
0CE6: E3       [29]             EX      (SP),HL         ; Into stack - Code string out
0CE7: 3E                        .BYTE      3EH             ; Skip "POP HL"
0CE8: E1       [10]     NXTDTA: POP     HL              ; Restore code string address
                        
0CE9: 013A              DATA:   .BYTE      01H,3AH         ; ':' End of statement
0CEB: 0E00     [ 7]     REM:    LD      C,0             ; 00  End of statement
0CED: 0600     [14]             LD      B,0
0CEF: 79       [ 4]     NXTSTL: LD      A,C             ; Statement and byte
0CF0: 48       [ 8]             LD      C,B
0CF1: 47       [12]             LD      B,A             ; Statement end byte
0CF2: 7E       [ 7]     NXTSTT: LD      A,(HL)          ; Get byte
0CF3: B7       [11]             OR      A               ; End of line?
0CF4: C8       [16|22]          RET     Z               ; Yes - Exit
0CF5: B8       [20]             CP      B               ; End of statement?
0CF6: C8       [25|31]          RET     Z               ; Yes - Exit
0CF7: 23       [31]             INC     HL              ; Next byte
0CF8: FE22     [38]             CP      '"'             ; Literal string?
0CFA: CAEF0C   [48|48]          JP      Z,NXTSTL        ; Yes - Look for another '"'
0CFD: C3F20C   [58]             JP      NXTSTT          ; Keep looking
                        
0D00: CDB511   [17]     LET:    CALL    GETVAR          ; Get variable name
0D03: CDC109   [34]             CALL    CHKSYN          ; Make sure "=" follows
0D06: B4                        .BYTE      ZEQUAL          ; "=" token
0D07: D5       [45]             PUSH    DE              ; Save address of variable
0D08: 3AF220   [58]             LD      A,(TYPE)        ; Get data type
0D0B: F5       [69]             PUSH    AF              ; Save type
0D0C: CDD10F   [86]             CALL    EVAL            ; Evaluate expression
0D0F: F1       [96]             POP     AF              ; Restore type
0D10: E3       [115]            EX      (SP),HL         ; Save code - Get var addr
0D11: 221321   [131]            LD      (BRKLIN),HL     ; Save address of variable
0D14: 1F       [135]            RRA                     ; Adjust type
0D15: CDC40F   [152]            CALL    CHKTYP          ; Check types are the same
0D18: CA530D   [162|162]        JP      Z,LETNUM        ; Numeric - Move value
0D1B: E5       [11]     LETSTR: PUSH    HL              ; Save address of string var
0D1C: 2A2921   [27]             LD      HL,(FPREG)      ; Pointer to string entry
0D1F: E5       [38]             PUSH    HL              ; Save it on stack
0D20: 23       [44]             INC     HL              ; Skip over length
0D21: 23       [50]             INC     HL
0D22: 5E       [57]             LD      E,(HL)          ; LSB of string address
0D23: 23       [63]             INC     HL
0D24: 56       [70]             LD      D,(HL)          ; MSB of string address
0D25: 2AA320   [86]             LD      HL,(BASTXT)     ; Point to start of program
0D28: CDBB09   [103]            CALL    CPDEHL          ; Is string before program?
0D2B: D2420D   [113|113]        JP      NC,CRESTR       ; Yes - Create string entry
0D2E: 2A9F20   [129]            LD      HL,(STRSPC)     ; Point to string space
0D31: CDBB09   [146]            CALL    CPDEHL          ; Is string literal in program?
0D34: D1       [156]            POP     DE              ; Restore address of string
0D35: D24A0D   [166|166]        JP      NC,MVSTPT       ; Yes - Set up pointer
0D38: 210421   [176]            LD      HL,TMPSTR       ; Temporary string pool
0D3B: CDBB09   [193]            CALL    CPDEHL          ; Is string in temporary pool?
0D3E: D24A0D   [203|203]        JP      NC,MVSTPT       ; No - Set up pointer
0D41: 3E                        .BYTE   3EH             ; Skip "POP DE"
0D42: D1       [10]     CRESTR: POP     DE              ; Restore address of string
0D43: CDF915   [27]             CALL    BAKTMP          ; Back to last tmp-str entry
0D46: EB       [31]             EX      DE,HL           ; Address of string entry
0D47: CD3214   [48]             CALL    SAVSTR          ; Save string in string area
0D4A: CDF915   [17]     MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
0D4D: E1       [27]             POP     HL              ; Get string pointer
0D4E: CDFC19   [44]             CALL    DETHL4          ; Move string pointer to var
0D51: E1       [54]             POP     HL              ; Restore code string address
0D52: C9       [64]             RET
                        
0D53: E5       [11]     LETNUM: PUSH    HL              ; Save address of variable
0D54: CDF919   [28]             CALL    FPTHL           ; Move value to variable
0D57: D1       [38]             POP     DE              ; Restore address of variable
0D58: E1       [48]             POP     HL              ; Restore code string address
0D59: C9       [58]             RET
                        
0D5A: CD2017   [17]     ON:     CALL    GETINT          ; Get integer 0-255
0D5D: 7E       [24]             LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
0D5E: 47       [28]             LD      B,A             ; Save in B
0D5F: FE8C     [35]             CP      ZGOSUB          ; "GOSUB" token?
0D61: CA690D   [45|45]          JP      Z,ONGO          ; Yes - Find line number
0D64: CDC109   [62]             CALL    CHKSYN          ; Make sure it's "GOTO"
0D67: 88                        .BYTE   ZGOTO           ; "GOTO" token
0D68: 2B       [68]             DEC     HL              ; Cancel increment
0D69: 4B       [ 4]     ONGO:   LD      C,E             ; Integer of branch value
0D6A: 0D       [ 4]     ONGOLP: DEC     C               ; Count branches
0D6B: 78       [ 8]             LD      A,B             ; Get "GOTO" or "GOSUB" token
0D6C: CA330B   [18|18]          JP      Z,ONJMP         ; Go to that line if right one
0D6F: CD1F0C   [35]             CALL    GETLN           ; Get line number to DE
0D72: FE2C     [42]             CP      ','             ; Another line number?
0D74: C0       [47|53]          RET     NZ              ; No - Drop through
0D75: C36A0D   [57]             JP      ONGOLP          ; Yes - loop
                        
0D78: CDD10F   [17]     IF:     CALL    EVAL            ; Evaluate expression
0D7B: 7E       [24]             LD      A,(HL)          ; Get token
0D7C: FE88     [31]             CP      ZGOTO           ; "GOTO" token?
0D7E: CA860D   [41|41]          JP      Z,IFGO          ; Yes - Get line
0D81: CDC109   [58]             CALL    CHKSYN          ; Make sure it's "THEN"
0D84: A9                        .BYTE      ZTHEN           ; "THEN" token
0D85: 2B       [64]             DEC     HL              ; Cancel increment
0D86: CDC20F   [17]     IFGO:   CALL    TSTNUM          ; Make sure it's numeric
0D89: CDA119   [34]             CALL    TSTSGN          ; Test state of expression
0D8C: CAEB0C   [44|44]          JP      Z,REM           ; False - Drop through
0D8F: CD4B0B   [61]             CALL    GETCHR          ; Get next character
0D92: DAA60C   [71|71]          JP      C,GOTO          ; Number - GOTO that line
0D95: C3320B   [81]             JP      IFJMP           ; Otherwise do statement
                        
0D98: 2B       [ 6]     MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
0D99: CD4B0B   [23]             CALL    GETCHR          ; Get next character
0D9C: CAFA0D   [10|10]  PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
0D9F: C8       [ 5|11]  PRNTLP: RET     Z               ; End of list - Exit
0DA0: FEA5     [12]             CP      ZTAB            ; "TAB(" token?
0DA2: CA2D0E   [22|22]          JP      Z,DOTAB         ; Yes - Do TAB routine
0DA5: FEA8     [29]             CP      ZSPC            ; "SPC(" token?
0DA7: CA2D0E   [39|39]          JP      Z,DOTAB         ; Yes - Do SPC routine
0DAA: E5       [50]             PUSH    HL              ; Save code string address
0DAB: FE2C     [57]             CP      ','             ; Comma?
0DAD: CA160E   [67|67]          JP      Z,DOCOM         ; Yes - Move to next zone
0DB0: FE3B     [74]             CP      59 ;";"         ; Semi-colon?
0DB2: CA500E   [84|84]          JP      Z,NEXITM        ; Do semi-colon routine
0DB5: C1       [94]             POP     BC              ; Code string address to BC
0DB6: CDD10F   [111]            CALL    EVAL            ; Evaluate expression
0DB9: E5       [122]            PUSH    HL              ; Save code string address
0DBA: 3AF220   [135]            LD      A,(TYPE)        ; Get variable type
0DBD: B7       [139]            OR      A               ; Is it a string variable?
0DBE: C2E60D   [149|149]        JP      NZ,PRNTST       ; Yes - Output string contents
0DC1: CD461B   [166]            CALL    NUMASC          ; Convert number to text
0DC4: CD5614   [183]            CALL    CRTST           ; Create temporary string
0DC7: 3620     [193]            LD      (HL),' '        ; Followed by a space
0DC9: 2A2921   [209]            LD      HL,(FPREG)      ; Get length of output
0DCC: 34       [220]            INC     (HL)            ; Plus 1 for the space
0DCD: 2A2921   [236]            LD      HL,(FPREG)      ; < Not needed >
0DD0: 3A8720   [249]            LD      A,(LWIDTH)      ; Get width of line
0DD3: 47       [253]            LD      B,A             ; To B
0DD4: 04       [257]            INC     B               ; Width 255 (No limit)?
0DD5: CAE20D   [267|267]        JP      Z,PRNTNB        ; Yes - Output number string
0DD8: 04       [271]            INC     B               ; Adjust it
0DD9: 3AF020   [284]            LD      A,(CURPOS)      ; Get cursor position
0DDC: 86       [291]            ADD     A,(HL)          ; Add length of string
0DDD: 3D       [295]            DEC     A               ; Adjust it
0DDE: B8       [299]            CP      B               ; Will output fit on this line?
0DDF: D4FA0D   [309|316]        CALL    NC,PRNTCRLF     ; No - CRLF first
0DE2: CD9B14   [17]     PRNTNB: CALL    PRS1            ; Output string at (HL)
0DE5: AF       [21]             XOR     A               ; Skip CALL by setting 'z' flag
0DE6: C49B14   [10|17]  PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
0DE9: E1       [20]             POP     HL              ; Restore code string address
0DEA: C3980D   [30]             JP      MRPRNT          ; See if more to PRINT
                        
0DED: 3AF020   [13]     STTLIN: LD      A,(CURPOS)      ; Make sure on new line
0DF0: B7       [17]             OR      A               ; Already at start?
0DF1: C8       [22|28]          RET     Z               ; Yes - Do nothing
0DF2: C3FA0D   [32]             JP      PRNTCRLF        ; Start a new line
                        
0DF5: 3600     [10]     ENDINP: LD      (HL),0          ; Mark end of buffer
0DF7: 21A520   [20]             LD      HL,BUFFER-1     ; Point to buffer
0DFA: 3E0D     [ 7]     PRNTCRLF: LD    A,CR            ; Load a CR
0DFC: CDCC09   [24]             CALL    OUTC            ; Output character
0DFF: 3E0A     [31]             LD      A,LF            ; Load a LF
0E01: CDCC09   [48]             CALL    OUTC            ; Output character
0E04: AF       [ 4]     DONULL: XOR     A               ; Set to position 0
0E05: 32F020   [17]             LD      (CURPOS),A      ; Store it
0E08: 3A8620   [30]             LD      A,(NULLS)       ; Get number of nulls
0E0B: 3D       [ 4]     NULLP:  DEC     A               ; Count them
0E0C: C8       [ 9|15]          RET     Z               ; Return if done
0E0D: F5       [20]             PUSH    AF              ; Save count
0E0E: AF       [24]             XOR     A               ; Load a null
0E0F: CDCC09   [41]             CALL    OUTC            ; Output it
0E12: F1       [51]             POP     AF              ; Restore count
0E13: C30B0E   [61]             JP      NULLP           ; Keep counting
                        
0E16: 3A8820   [13]     DOCOM:  LD      A,(COMMAN)      ; Get comma width
0E19: 47       [17]             LD      B,A             ; Save in B
0E1A: 3AF020   [30]             LD      A,(CURPOS)      ; Get current position
0E1D: B8       [34]             CP      B               ; Within the limit?
0E1E: D4FA0D   [44|51]          CALL    NC,PRNTCRLF     ; No - output CRLF
0E21: D2500E   [54|54]          JP      NC,NEXITM       ; Get next item
0E24: D60E     [ 7]     ZONELP: SUB     14              ; Next zone of 14 characters
0E26: D2240E   [17|17]          JP      NC,ZONELP       ; Repeat if more zones
0E29: 2F       [21]             CPL                     ; Number of spaces to output
0E2A: C3450E   [31]             JP      ASPCS           ; Output them
                        
0E2D: F5       [11]     DOTAB:  PUSH    AF              ; Save token
0E2E: CD1D17   [28]             CALL    FNDNUM          ; Evaluate expression
0E31: CDC109   [45]             CALL    CHKSYN          ; Make sure ")" follows
0E34: 29                        .BYTE   ")"
0E35: 2B       [51]             DEC     HL              ; Back space on to ")"
0E36: F1       [61]             POP     AF              ; Restore token
0E37: D6A8     [68]             SUB     ZSPC            ; Was it "SPC(" ?
0E39: E5       [79]             PUSH    HL              ; Save code string address
0E3A: CA400E   [89|89]          JP      Z,DOSPC         ; Yes - Do 'E' spaces
0E3D: 3AF020   [102]            LD      A,(CURPOS)      ; Get current position
0E40: 2F       [ 4]     DOSPC:  CPL                     ; Number of spaces to print to
0E41: 83       [ 8]             ADD     A,E             ; Total number to print
0E42: D2500E   [18|18]          JP      NC,NEXITM       ; TAB < Current POS(X)
0E45: 3C       [ 4]     ASPCS:  INC     A               ; Output A spaces
0E46: 47       [ 8]             LD      B,A             ; Save number to print
0E47: 3E20     [15]             LD      A,' '           ; Space
0E49: CDCC09   [17]     SPCLP:  CALL    OUTC            ; Output character in A
0E4C: 05       [21]             DEC     B               ; Count them
0E4D: C2490E   [31|31]          JP      NZ,SPCLP        ; Repeat if more
0E50: E1       [10]     NEXITM: POP     HL              ; Restore code string address
0E51: CD4B0B   [27]             CALL    GETCHR          ; Get next character
0E54: C39F0D   [37]             JP      PRNTLP          ; More to print
                        
0E57: 3F526564          REDO:   .BYTE   "?Redo from start",CR,LF,0
0E5B: 6F206672          
0E5F: 6F6D2073          
0E63: 74617274          
0E67: 0D0A00            
                        
0E6A: 3A1221   [13]     BADINP: LD      A,(READFG)      ; READ or INPUT?
0E6D: B7       [17]             OR      A
0E6E: C2F406   [27|27]          JP      NZ,DATSNR       ; READ - ?SN Error
0E71: C1       [37]             POP     BC              ; Throw away code string addr
0E72: 21570E   [47]             LD      HL,REDO         ; "Redo from start" message
0E75: CD9814   [64]             CALL    PRS             ; Output string
0E78: C34508   [74]             JP      DOAGN           ; Do last INPUT again
                        
0E7B: CD0314   [17]     INPUT:  CALL    IDTEST          ; Test for illegal direct
0E7E: 7E       [24]             LD      A,(HL)          ; Get character after "INPUT"
0E7F: FE22     [31]             CP      '"'             ; Is there a prompt string?
0E81: 3E00     [38]             LD      A,0             ; Clear A and leave flags
0E83: 328A20   [51]             LD      (CTLOFG),A      ; Enable output
0E86: C2950E   [61|61]          JP      NZ,NOPMPT       ; No prompt - get input
0E89: CD5714   [78]             CALL    QTSTR           ; Get string terminated by '"'
0E8C: CDC109   [95]             CALL    CHKSYN          ; Check for ';' after prompt
0E8F: 3B                        .BYTE   ';'
0E90: E5       [106]            PUSH    HL              ; Save code string address
0E91: CD9B14   [123]            CALL    PRS1            ; Output prompt string
0E94: 3E                        .BYTE   3EH             ; Skip "PUSH HL"
0E95: E5       [11]     NOPMPT: PUSH    HL              ; Save code string address
0E96: CD4908   [28]             CALL    PROMPT          ; Get input with "? " prompt
0E99: C1       [38]             POP     BC              ; Restore code string address
0E9A: DAA10B   [48|48]          JP      C,INPBRK        ; Break pressed - Exit
0E9D: 23       [54]             INC     HL              ; Next byte
0E9E: 7E       [61]             LD      A,(HL)          ; Get it
0E9F: B7       [65]             OR      A               ; End of line?
0EA0: 2B       [71]             DEC     HL              ; Back again
0EA1: C5       [82]             PUSH    BC              ; Re-save code string address
0EA2: CAE80C   [92|92]          JP      Z,NXTDTA        ; Yes - Find next DATA stmt
0EA5: 362C     [102]            LD      (HL),','        ; Store comma as separator
0EA7: C3AF0E   [112]            JP      NXTITM          ; Get next item
                        
0EAA: E5       [11]     READ:   PUSH    HL              ; Save code string address
0EAB: 2A2121   [27]             LD      HL,(NXTDAT)     ; Next DATA statement
0EAE: F6                        .BYTE   0F6H            ; Flag "READ"
0EAF: AF       [ 4]     NXTITM: XOR     A               ; Flag "INPUT"
0EB0: 321221   [17]             LD      (READFG),A      ; Save "READ"/"INPUT" flag
0EB3: E3       [36]             EX      (SP),HL         ; Get code str' , Save pointer
0EB4: C3BB0E   [46]             JP      GTVLUS          ; Get values
                        
0EB7: CDC109   [17]     NEDMOR: CALL    CHKSYN          ; Check for comma between items
0EBA: 2C                        .BYTE      ','
0EBB: CDB511   [17]     GTVLUS: CALL    GETVAR          ; Get variable name
0EBE: E3       [36]             EX      (SP),HL         ; Save code str" , Get pointer
0EBF: D5       [47]             PUSH    DE              ; Save variable address
0EC0: 7E       [54]             LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
0EC1: FE2C     [61]             CP      ','             ; Comma?
0EC3: CAE30E   [71|71]          JP      Z,ANTVLU        ; Yes - Get another value
0EC6: 3A1221   [84]             LD      A,(READFG)      ; Is it READ?
0EC9: B7       [88]             OR      A
0ECA: C2500F   [98|98]          JP      NZ,FDTLP        ; Yes - Find next DATA stmt
0ECD: 3E3F     [105]            LD      A,'?'           ; More INPUT needed
0ECF: CDCC09   [122]            CALL    OUTC            ; Output character
0ED2: CD4908   [139]            CALL    PROMPT          ; Get INPUT with prompt
0ED5: D1       [149]            POP     DE              ; Variable address
0ED6: C1       [159]            POP     BC              ; Code string address
0ED7: DAA10B   [169|169]        JP      C,INPBRK        ; Break pressed
0EDA: 23       [175]            INC     HL              ; Point to next DATA byte
0EDB: 7E       [182]            LD      A,(HL)          ; Get byte
0EDC: B7       [186]            OR      A               ; Is it zero (No input) ?
0EDD: 2B       [192]            DEC     HL              ; Back space INPUT pointer
0EDE: C5       [203]            PUSH    BC              ; Save code string address
0EDF: CAE80C   [213|213]        JP      Z,NXTDTA        ; Find end of buffer
0EE2: D5       [224]            PUSH    DE              ; Save variable address
0EE3: 3AF220   [13]     ANTVLU: LD      A,(TYPE)        ; Check data type
0EE6: B7       [17]             OR      A               ; Is it numeric?
0EE7: CA0D0F   [27|27]          JP      Z,INPBIN        ; Yes - Convert to binary
0EEA: CD4B0B   [44]             CALL    GETCHR          ; Get next character
0EED: 57       [48]             LD      D,A             ; Save input character
0EEE: 47       [52]             LD      B,A             ; Again
0EEF: FE22     [59]             CP      '"'             ; Start of literal sting?
0EF1: CA010F   [69|69]          JP      Z,STRENT        ; Yes - Create string entry
0EF4: 3A1221   [82]             LD      A,(READFG)      ; "READ" or "INPUT" ?
0EF7: B7       [86]             OR      A
0EF8: 57       [90]             LD      D,A             ; Save 00 if "INPUT"
0EF9: CAFE0E   [100|100]        JP      Z,ITMSEP        ; "INPUT" - End with 00
0EFC: 163A     [107]            LD      D,':'           ; "DATA" - End with 00 or ':'
0EFE: 062C     [ 7]     ITMSEP: LD      B,','           ; Item separator
0F00: 2B       [13]             DEC     HL              ; Back space for DTSTR
0F01: CD5A14   [17]     STRENT: CALL    DTSTR           ; Get string terminated by D
0F04: EB       [21]             EX      DE,HL           ; String address to DE
0F05: 21180F   [31]             LD      HL,LTSTND       ; Where to go after LETSTR
0F08: E3       [50]             EX      (SP),HL         ; Save HL , get input pointer
0F09: D5       [61]             PUSH    DE              ; Save address of string
0F0A: C31B0D   [71]             JP      LETSTR          ; Assign string to variable
                        
0F0D: CD4B0B   [17]     INPBIN: CALL    GETCHR          ; Get next character
0F10: CDA81A   [34]             CALL    ASCTFP          ; Convert ASCII to FP number
0F13: E3       [53]             EX      (SP),HL         ; Save input ptr, Get var addr
0F14: CDF919   [70]             CALL    FPTHL           ; Move FPREG to variable
0F17: E1       [80]             POP     HL              ; Restore input pointer
0F18: 2B       [ 6]     LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
0F19: CD4B0B   [23]             CALL    GETCHR          ; Get next character
0F1C: CA240F   [33|33]          JP      Z,MORDT         ; End of line - More needed?
0F1F: FE2C     [40]             CP      ','             ; Another value?
0F21: C26A0E   [50|50]          JP      NZ,BADINP       ; No - Bad input
0F24: E3       [19]     MORDT:  EX      (SP),HL         ; Get code string address
0F25: 2B       [25]             DEC     HL              ; DEC 'cos GETCHR INCs
0F26: CD4B0B   [42]             CALL    GETCHR          ; Get next character
0F29: C2B70E   [52|52]          JP      NZ,NEDMOR       ; More needed - Get it
0F2C: D1       [62]             POP     DE              ; Restore DATA pointer
0F2D: 3A1221   [75]             LD      A,(READFG)      ; "READ" or "INPUT" ?
0F30: B7       [79]             OR      A
0F31: EB       [83]             EX      DE,HL           ; DATA pointer to HL
0F32: C2710B   [93|93]          JP      NZ,UPDATA       ; Update DATA pointer if "READ"
0F35: D5       [104]            PUSH    DE              ; Save code string address
0F36: B6       [111]            OR      (HL)            ; More input given?
0F37: 213F0F   [121]            LD      HL,EXTIG        ; "?Extra ignored" message
0F3A: C49814   [131|138]        CALL    NZ,PRS          ; Output string if extra given
0F3D: E1       [141]            POP     HL              ; Restore code string address
0F3E: C9       [151]            RET
                        
0F3F: 3F457874          EXTIG:  .BYTE   "?Extra ignored",CR,LF,0
0F43: 72612069          
0F47: 676E6F72          
0F4B: 65640D0A          
0F4F: 00                
                        
0F50: CDE90C   [17]     FDTLP:  CALL    DATA            ; Get next statement
0F53: B7       [21]             OR      A               ; End of line?
0F54: C2690F   [31|31]          JP      NZ,FANDT        ; No - See if DATA statement
0F57: 23       [37]             INC     HL
0F58: 7E       [44]             LD      A,(HL)          ; End of program?
0F59: 23       [50]             INC     HL
0F5A: B6       [57]             OR      (HL)            ; 00 00 Ends program
0F5B: 1E06     [64]             LD      E,OD            ; ?OD Error
0F5D: CA0E07   [74|74]          JP      Z,ERROR         ; Yes - Out of DATA
0F60: 23       [80]             INC     HL
0F61: 5E       [87]             LD      E,(HL)          ; LSB of line number
0F62: 23       [93]             INC     HL
0F63: 56       [100]            LD      D,(HL)          ; MSB of line number
0F64: EB       [104]            EX      DE,HL
0F65: 220E21   [120]            LD      (DATLIN),HL     ; Set line of current DATA item
0F68: EB       [124]            EX      DE,HL
0F69: CD4B0B   [17]     FANDT:  CALL    GETCHR          ; Get next character
0F6C: FE83     [24]             CP      ZDATA           ; "DATA" token
0F6E: C2500F   [34|34]          JP      NZ,FDTLP        ; No "DATA" - Keep looking
0F71: C3E30E   [44]             JP      ANTVLU          ; Found - Convert input
                        
0F74: 110000   [10]     NEXT:   LD      DE,0            ; In case no index given
0F77: C4B511   [10|17]  NEXT1:  CALL    NZ,GETVAR       ; Get index address
0F7A: 221321   [26]             LD      (BRKLIN),HL     ; Save code string address
0F7D: CDA306   [43]             CALL    BAKSTK          ; Look for "FOR" block
0F80: C20007   [53|53]          JP      NZ,NFERR        ; No "FOR" - ?NF Error
0F83: F9       [59]             LD      SP,HL           ; Clear nested loops
0F84: D5       [70]             PUSH    DE              ; Save index address
0F85: 7E       [77]             LD      A,(HL)          ; Get sign of STEP
0F86: 23       [83]             INC     HL
0F87: F5       [94]             PUSH    AF              ; Save sign of STEP
0F88: D5       [105]            PUSH    DE              ; Save index address
0F89: CDDF19   [122]            CALL    PHLTFP          ; Move index value to FPREG
0F8C: E3       [141]            EX      (SP),HL         ; Save address of TO value
0F8D: E5       [152]            PUSH    HL              ; Save address of index
0F8E: CD4C17   [169]            CALL    ADDPHL          ; Add STEP to index value
0F91: E1       [179]            POP     HL              ; Restore address of index
0F92: CDF919   [196]            CALL    FPTHL           ; Move value to index variable
0F95: E1       [206]            POP     HL              ; Restore address of TO value
0F96: CDF019   [223]            CALL    LOADFP          ; Move TO value to BCDE
0F99: E5       [234]            PUSH    HL              ; Save address of line of FOR
0F9A: CD1C1A   [251]            CALL    CMPNUM          ; Compare index with TO value
0F9D: E1       [261]            POP     HL              ; Restore address of line num
0F9E: C1       [271]            POP     BC              ; Address of sign of STEP
0F9F: 90       [275]            SUB     B               ; Compare with expected sign
0FA0: CDF019   [292]            CALL    LOADFP          ; BC = Loop stmt,DE = Line num
0FA3: CAAF0F   [302|302]        JP      Z,KILFOR        ; Loop finished - Terminate it
0FA6: EB       [306]            EX      DE,HL           ; Loop statement line number
0FA7: 22A120   [322]            LD      (LINEAT),HL     ; Set loop line number
0FAA: 69       [326]            LD      L,C             ; Set code string to loop
0FAB: 60       [330]            LD      H,B
0FAC: C3070B   [340]            JP      PUTFID          ; Put back "FOR" and continue
                        
0FAF: F9       [ 6]     KILFOR: LD      SP,HL           ; Remove "FOR" block
0FB0: 2A1321   [22]             LD      HL,(BRKLIN)     ; Code string after "NEXT"
0FB3: 7E       [29]             LD      A,(HL)          ; Get next byte in code string
0FB4: FE2C     [36]             CP      ','             ; More NEXTs ?
0FB6: C20B0B   [46|46]          JP      NZ,RUNCNT       ; No - Do next statement
0FB9: CD4B0B   [63]             CALL    GETCHR          ; Position to index name
0FBC: CD770F   [80]             CALL    NEXT1           ; Re-enter NEXT routine
                        ; < will not RETurn to here , Exit to RUNCNT or Loop >
                        
0FBF: CDD10F   [17]     GETNUM: CALL    EVAL            ; Get a numeric expression
0FC2: F6                TSTNUM: .BYTE      0F6H            ; Clear carry (numeric)
0FC3: 37       [ 4]     TSTSTR: SCF                     ; Set carry (string)
0FC4: 3AF220   [13]     CHKTYP: LD      A,(TYPE)        ; Check types match
0FC7: 8F       [17]             ADC     A,A             ; Expected + actual
0FC8: B7       [21]             OR      A               ; Clear carry , set parity
0FC9: E8       [26|32]          RET     PE              ; Even parity - Types match
0FCA: C30C07   [36]             JP      TMERR           ; Different types - Error
                        
0FCD: CDC109   [17]     OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
0FD0: 28                        .BYTE   "("
0FD1: 2B       [ 6]     EVAL:   DEC     HL              ; Evaluate expression & save
0FD2: 1600     [13]             LD      D,0             ; Precedence value
0FD4: D5       [11]     EVAL1:  PUSH    DE              ; Save precedence
0FD5: 0E01     [18]             LD      C,1
0FD7: CDD706   [35]             CALL    CHKSTK          ; Check for 1 level of stack
0FDA: CD4810   [52]             CALL    OPRND           ; Get next expression value
0FDD: 221521   [16]     EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
0FE0: 2A1521   [16]     EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
0FE3: C1       [26]             POP     BC              ; Precedence value and operator
0FE4: 78       [30]             LD      A,B             ; Get precedence value
0FE5: FE78     [37]             CP      78H             ; "AND" or "OR" ?
0FE7: D4C20F   [47|54]          CALL    NC,TSTNUM       ; No - Make sure it's a number
0FEA: 7E       [54]             LD      A,(HL)          ; Get next operator / function
0FEB: 1600     [61]             LD      D,0             ; Clear Last relation
0FED: D6B3     [ 7]     RLTLP:  SUB     ZGTR            ; ">" Token
0FEF: DA0910   [17|17]          JP      C,FOPRND        ; + - * / ^ AND OR - Test it
0FF2: FE03     [24]             CP      ZLTH+1-ZGTR     ; < = >
0FF4: D20910   [34|34]          JP      NC,FOPRND       ; Function - Call it
0FF7: FE01     [41]             CP      ZEQUAL-ZGTR     ; "="
0FF9: 17       [45]             RLA                     ; <- Test for legal
0FFA: AA       [49]             XOR     D               ; <- combinations of < = >
0FFB: BA       [53]             CP      D               ; <- by combining last token
0FFC: 57       [57]             LD      D,A             ; <- with current one
0FFD: DAFA06   [67|67]          JP      C,SNERR         ; Error if "<<' '==" or ">>"
1000: 220A21   [83]             LD      (CUROPR),HL     ; Save address of current token
1003: CD4B0B   [100]            CALL    GETCHR          ; Get next character
1006: C3ED0F   [110]            JP      RLTLP           ; Treat the two as one
                        
1009: 7A       [ 4]     FOPRND: LD      A,D             ; < = > found ?
100A: B7       [ 8]             OR      A
100B: C23011   [18|18]          JP      NZ,TSTRED       ; Yes - Test for reduction
100E: 7E       [25]             LD      A,(HL)          ; Get operator token
100F: 220A21   [41]             LD      (CUROPR),HL     ; Save operator address
1012: D6AC     [48]             SUB     ZPLUS           ; Operator or function?
1014: D8       [53|59]          RET     C               ; Neither - Exit
1015: FE07     [60]             CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
1017: D0       [65|71]          RET     NC              ; No - Exit
1018: 5F       [69]             LD      E,A             ; Coded operator
1019: 3AF220   [82]             LD      A,(TYPE)        ; Get data type
101C: 3D       [86]             DEC     A               ; FF = numeric , 00 = string
101D: B3       [90]             OR      E               ; Combine with coded operator
101E: 7B       [94]             LD      A,E             ; Get coded operator
101F: CA8E15   [104|104]        JP      Z,CONCAT        ; String concatenation
1022: 07       [108]            RLCA                    ; Times 2
1023: 83       [112]            ADD     A,E             ; Times 3
1024: 5F       [116]            LD      E,A             ; To DE (D is 0)
1025: 21EC05   [126]            LD      HL,PRITAB       ; Precedence table
1028: 19       [137]            ADD     HL,DE           ; To the operator concerned
1029: 78       [141]            LD      A,B             ; Last operator precedence
102A: 56       [148]            LD      D,(HL)          ; Get evaluation precedence
102B: BA       [152]            CP      D               ; Compare with eval precedence
102C: D0       [157|163]        RET     NC              ; Exit if higher precedence
102D: 23       [163]            INC     HL              ; Point to routine address
102E: CDC20F   [180]            CALL    TSTNUM          ; Make sure it's a number
                        
1031: C5       [11]     STKTHS: PUSH    BC              ; Save last precedence & token
1032: 01E00F   [21]             LD      BC,EVAL3        ; Where to go on prec' break
1035: C5       [32]             PUSH    BC              ; Save on stack for return
1036: 43       [36]             LD      B,E             ; Save operator
1037: 4A       [40]             LD      C,D             ; Save precedence
1038: CDD219   [57]             CALL    STAKFP          ; Move value to stack
103B: 58       [61]             LD      E,B             ; Restore operator
103C: 51       [65]             LD      D,C             ; Restore precedence
103D: 4E       [72]             LD      C,(HL)          ; Get LSB of routine address
103E: 23       [78]             INC     HL
103F: 46       [85]             LD      B,(HL)          ; Get MSB of routine address
1040: 23       [91]             INC     HL
1041: C5       [102]            PUSH    BC              ; Save routine address
1042: 2A0A21   [118]            LD      HL,(CUROPR)     ; Address of current operator
1045: C3D40F   [128]            JP      EVAL1           ; Loop until prec' break
                        
1048: AF       [ 4]     OPRND:  XOR     A               ; Get operand routine
1049: 32F220   [17]             LD      (TYPE),A        ; Set numeric expected
104C: CD4B0B   [34]             CALL    GETCHR          ; Get next character
104F: 1E24     [41]             LD      E,MO            ; ?MO Error
1051: CA0E07   [51|51]          JP      Z,ERROR         ; No operand - Error
1054: DAA81A   [61|61]          JP      C,ASCTFP        ; Number - Get value
1057: CDF00B   [78]             CALL    CHKLTR          ; See if a letter
105A: D2AF10   [88|88]          JP      NC,CONVAR       ; Letter - Find variable
105D: FE26     [95]             CP		'&'				; &H = HEX, &B = BINARY
105F: 2012     [102|107]        JR		NZ, NOTAMP
1061: CD4B0B   [119]            CALL    GETCHR          ; Get next character
1064: FE48     [126]            CP      'H'             ; Hex number indicated? [function added]
1066: CAF21E   [136|136]        JP      Z,HEXTFP        ; Convert Hex to FPREG
1069: FE42     [143]            CP      'B'             ; Binary number indicated? [function added]
106B: CA621F   [153|153]        JP      Z,BINTFP        ; Convert Bin to FPREG
106E: 1E02     [160]            LD      E,SN            ; If neither then a ?SN Error
1070: CA0E07   [170|170]        JP      Z,ERROR         ; 
1073: FEAC     [ 7]     NOTAMP: CP      ZPLUS           ; '+' Token ?
1075: CA4810   [17|17]          JP      Z,OPRND         ; Yes - Look for operand
1078: FE2E     [24]             CP      '.'             ; '.' ?
107A: CAA81A   [34|34]          JP      Z,ASCTFP        ; Yes - Create FP number
107D: FEAD     [41]             CP      ZMINUS          ; '-' Token ?
107F: CA9E10   [51|51]          JP      Z,MINUS         ; Yes - Do minus
1082: FE22     [58]             CP      '"'             ; Literal string ?
1084: CA5714   [68|68]          JP      Z,QTSTR         ; Get string terminated by '"'
1087: FEAA     [75]             CP      ZNOT            ; "NOT" Token ?
1089: CA9011   [85|85]          JP      Z,EVNOT         ; Yes - Eval NOT expression
108C: FEA7     [92]             CP      ZFN             ; "FN" Token ?
108E: CABB13   [102|102]        JP      Z,DOFN          ; Yes - Do FN routine
1091: D6B6     [109]            SUB     ZSGN            ; Is it a function?
1093: D2C010   [119|119]        JP      NC,FNOFST       ; Yes - Evaluate function
1096: CDCD0F   [17]     EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
1099: CDC109   [34]             CALL    CHKSYN          ; Make sure ")" follows
109C: 29                        .BYTE   ")"
109D: C9       [44]             RET
                        
109E: 167D     [ 7]     MINUS:  LD      D,7DH           ; '-' precedence
10A0: CDD40F   [24]             CALL    EVAL1           ; Evaluate until prec' break
10A3: 2A1521   [40]             LD      HL,(NXTOPR)     ; Get next operator address
10A6: E5       [51]             PUSH    HL              ; Save next operator address
10A7: CDCA19   [68]             CALL    INVSGN          ; Negate value
10AA: CDC20F   [17]     RETNUM: CALL    TSTNUM          ; Make sure it's a number
10AD: E1       [27]             POP     HL              ; Restore next operator address
10AE: C9       [37]             RET
                        
10AF: CDB511   [17]     CONVAR: CALL    GETVAR          ; Get variable address to DE
10B2: E5       [11]     FRMEVL: PUSH    HL              ; Save code string address
10B3: EB       [15]             EX      DE,HL           ; Variable address to HL
10B4: 222921   [31]             LD      (FPREG),HL      ; Save address of variable
10B7: 3AF220   [44]             LD      A,(TYPE)        ; Get type
10BA: B7       [48]             OR      A               ; Numeric?
10BB: CCDF19   [58|65]          CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
10BE: E1       [68]             POP     HL              ; Restore code string address
10BF: C9       [78]             RET
                        
10C0: 0600     [ 7]     FNOFST: LD      B,0             ; Get address of function
10C2: 07       [11]             RLCA                    ; Double function offset
10C3: 4F       [15]             LD      C,A             ; BC = Offset in function table
10C4: C5       [26]             PUSH    BC              ; Save adjusted token value
10C5: CD4B0B   [43]             CALL    GETCHR          ; Get next character
10C8: 79       [47]             LD      A,C             ; Get adjusted token value
10C9: FE31     [54]             CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
10CB: DAE710   [64|64]          JP      C,FNVAL         ; No - Do function
10CE: CDCD0F   [81]             CALL    OPNPAR          ; Evaluate expression  (X,...
10D1: CDC109   [98]             CALL    CHKSYN          ; Make sure ',' follows
10D4: 2C                        .BYTE      ','
10D5: CDC30F   [115]            CALL    TSTSTR          ; Make sure it's a string
10D8: EB       [119]            EX      DE,HL           ; Save code string address
10D9: 2A2921   [135]            LD      HL,(FPREG)      ; Get address of string
10DC: E3       [154]            EX      (SP),HL         ; Save address of string
10DD: E5       [165]            PUSH    HL              ; Save adjusted token value
10DE: EB       [169]            EX      DE,HL           ; Restore code string address
10DF: CD2017   [186]            CALL    GETINT          ; Get integer 0-255
10E2: EB       [190]            EX      DE,HL           ; Save code string address
10E3: E3       [209]            EX      (SP),HL         ; Save integer,HL = adj' token
10E4: C3EF10   [219]            JP      GOFUNC          ; Jump to string function
                        
10E7: CD9610   [17]     FNVAL:  CALL    EVLPAR          ; Evaluate expression
10EA: E3       [36]             EX      (SP),HL         ; HL = Adjusted token value
10EB: 11AA10   [46]             LD      DE,RETNUM       ; Return number from function
10EE: D5       [57]             PUSH    DE              ; Save on stack
10EF: 014B04   [10]     GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
10F2: 09       [21]             ADD     HL,BC           ; Point to right address
10F3: 4E       [28]             LD      C,(HL)          ; Get LSB of address
10F4: 23       [34]             INC     HL              ;
10F5: 66       [41]             LD      H,(HL)          ; Get MSB of address
10F6: 69       [45]             LD      L,C             ; Address to HL
10F7: E9       [49]             JP      (HL)            ; Jump to function
                        
10F8: 15       [ 4]     SGNEXP: DEC     D               ; Dee to flag negative exponent
10F9: FEAD     [11]             CP      ZMINUS          ; '-' token ?
10FB: C8       [16|22]          RET     Z               ; Yes - Return
10FC: FE2D     [23]             CP      '-'             ; '-' ASCII ?
10FE: C8       [28|34]          RET     Z               ; Yes - Return
10FF: 14       [32]             INC     D               ; Inc to flag positive exponent
1100: FE2B     [39]             CP      '+'             ; '+' ASCII ?
1102: C8       [44|50]          RET     Z               ; Yes - Return
1103: FEAC     [51]             CP      ZPLUS           ; '+' token ?
1105: C8       [56|62]          RET     Z               ; Yes - Return
1106: 2B       [62]             DEC     HL              ; DEC 'cos GETCHR INCs
1107: C9       [72]             RET                     ; Return "NZ"
                        
1108: F6                POR:    .BYTE      0F6H            ; Flag "OR"
1109: AF       [ 4]     PAND:   XOR     A               ; Flag "AND"
110A: F5       [15]             PUSH    AF              ; Save "AND" / "OR" flag
110B: CDC20F   [32]             CALL    TSTNUM          ; Make sure it's a number
110E: CD040C   [49]             CALL    DEINT           ; Get integer -32768 to 32767
1111: F1       [59]             POP     AF              ; Restore "AND" / "OR" flag
1112: EB       [63]             EX      DE,HL           ; <- Get last
1113: C1       [73]             POP     BC              ; <-  value
1114: E3       [92]             EX      (SP),HL         ; <-  from
1115: EB       [96]             EX      DE,HL           ; <-  stack
1116: CDE219   [113]            CALL    FPBCDE          ; Move last value to FPREG
1119: F5       [124]            PUSH    AF              ; Save "AND" / "OR" flag
111A: CD040C   [141]            CALL    DEINT           ; Get integer -32768 to 32767
111D: F1       [151]            POP     AF              ; Restore "AND" / "OR" flag
111E: C1       [161]            POP     BC              ; Get value
111F: 79       [165]            LD      A,C             ; Get LSB
1120: 217913   [175]            LD      HL,ACPASS       ; Address of save AC as current
1123: C22B11   [185|185]        JP      NZ,POR1         ; Jump if OR
1126: A3       [189]            AND     E               ; "AND" LSBs
1127: 4F       [193]            LD      C,A             ; Save LSB
1128: 78       [197]            LD      A,B             ; Get MBS
1129: A2       [201]            AND     D               ; "AND" MSBs
112A: E9       [205]            JP      (HL)            ; Save AC as current (ACPASS)
                        
112B: B3       [ 4]     POR1:   OR      E               ; "OR" LSBs
112C: 4F       [ 8]             LD      C,A             ; Save LSB
112D: 78       [12]             LD      A,B             ; Get MSB
112E: B2       [16]             OR      D               ; "OR" MSBs
112F: E9       [20]             JP      (HL)            ; Save AC as current (ACPASS)
                        
1130: 214211   [10]     TSTRED: LD      HL,CMPLOG       ; Logical compare routine
1133: 3AF220   [23]             LD      A,(TYPE)        ; Get data type
1136: 1F       [27]             RRA                     ; Carry set = string
1137: 7A       [31]             LD      A,D             ; Get last precedence value
1138: 17       [35]             RLA                     ; Times 2 plus carry
1139: 5F       [39]             LD      E,A             ; To E
113A: 1664     [46]             LD      D,64H           ; Relational precedence
113C: 78       [50]             LD      A,B             ; Get current precedence
113D: BA       [54]             CP      D               ; Compare with last
113E: D0       [59|65]          RET     NC              ; Eval if last was rel' or log'
113F: C33110   [69]             JP      STKTHS          ; Stack this one and get next
                        
1142: 4411              CMPLOG: .WORD   CMPLG1          ; Compare two values / strings
1144: 79       [ 4]     CMPLG1: LD      A,C             ; Get data type
1145: B7       [ 8]             OR      A
1146: 1F       [12]             RRA
1147: C1       [22]             POP     BC              ; Get last expression to BCDE
1148: D1       [32]             POP     DE
1149: F5       [43]             PUSH    AF              ; Save status
114A: CDC40F   [60]             CALL    CHKTYP          ; Check that types match
114D: 218611   [70]             LD      HL,CMPRES       ; Result to comparison
1150: E5       [81]             PUSH    HL              ; Save for RETurn
1151: CA1C1A   [91|91]          JP      Z,CMPNUM        ; Compare values if numeric
1154: AF       [95]             XOR     A               ; Compare two strings
1155: 32F220   [108]            LD      (TYPE),A        ; Set type to numeric
1158: D5       [119]            PUSH    DE              ; Save string name
1159: CDDB15   [136]            CALL    GSTRCU          ; Get current string
115C: 7E       [143]            LD      A,(HL)          ; Get length of string
115D: 23       [149]            INC     HL
115E: 23       [155]            INC     HL
115F: 4E       [162]            LD      C,(HL)          ; Get LSB of address
1160: 23       [168]            INC     HL
1161: 46       [175]            LD      B,(HL)          ; Get MSB of address
1162: D1       [185]            POP     DE              ; Restore string name
1163: C5       [196]            PUSH    BC              ; Save address of string
1164: F5       [207]            PUSH    AF              ; Save length of string
1165: CDDF15   [224]            CALL    GSTRDE          ; Get second string
1168: CDF019   [241]            CALL    LOADFP          ; Get address of second string
116B: F1       [251]            POP     AF              ; Restore length of string 1
116C: 57       [255]            LD      D,A             ; Length to D
116D: E1       [265]            POP     HL              ; Restore address of string 1
116E: 7B       [ 4]     CMPSTR: LD      A,E             ; Bytes of string 2 to do
116F: B2       [ 8]             OR      D               ; Bytes of string 1 to do
1170: C8       [13|19]          RET     Z               ; Exit if all bytes compared
1171: 7A       [17]             LD      A,D             ; Get bytes of string 1 to do
1172: D601     [24]             SUB     1
1174: D8       [29|35]          RET     C               ; Exit if end of string 1
1175: AF       [33]             XOR     A
1176: BB       [37]             CP      E               ; Bytes of string 2 to do
1177: 3C       [41]             INC     A
1178: D0       [46|52]          RET     NC              ; Exit if end of string 2
1179: 15       [50]             DEC     D               ; Count bytes in string 1
117A: 1D       [54]             DEC     E               ; Count bytes in string 2
117B: 0A       [61]             LD      A,(BC)          ; Byte in string 2
117C: BE       [68]             CP      (HL)            ; Compare to byte in string 1
117D: 23       [74]             INC     HL              ; Move up string 1
117E: 03       [80]             INC     BC              ; Move up string 2
117F: CA6E11   [90|90]          JP      Z,CMPSTR        ; Same - Try next bytes
1182: 3F       [94]             CCF                     ; Flag difference (">" or "<")
1183: C3AC19   [104]            JP      FLGDIF          ; "<" gives -1 , ">" gives +1
                        
1186: 3C       [ 4]     CMPRES: INC     A               ; Increment current value
1187: 8F       [ 8]             ADC     A,A             ; Double plus carry
1188: C1       [18]             POP     BC              ; Get other value
1189: A0       [22]             AND     B               ; Combine them
118A: C6FF     [29]             ADD     A,-1            ; Carry set if different
118C: 9F       [33]             SBC     A,A             ; 00 - Equal , FF - Different
118D: C3B319   [43]             JP      FLGREL          ; Set current value & continue
                        
1190: 165A     [ 7]     EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
1192: CDD40F   [24]             CALL    EVAL1           ; Eval until precedence break
1195: CDC20F   [41]             CALL    TSTNUM          ; Make sure it's a number
1198: CD040C   [58]             CALL    DEINT           ; Get integer -32768 - 32767
119B: 7B       [62]             LD      A,E             ; Get LSB
119C: 2F       [66]             CPL                     ; Invert LSB
119D: 4F       [70]             LD      C,A             ; Save "NOT" of LSB
119E: 7A       [74]             LD      A,D             ; Get MSB
119F: 2F       [78]             CPL                     ; Invert MSB
11A0: CD7913   [95]             CALL    ACPASS          ; Save AC as current
11A3: C1       [105]            POP     BC              ; Clean up stack
11A4: C3E00F   [115]            JP      EVAL3           ; Continue evaluation
                        
11A7: 2B       [ 6]     DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
11A8: CD4B0B   [23]             CALL    GETCHR          ; Get next character
11AB: C8       [28|34]          RET     Z               ; End of DIM statement
11AC: CDC109   [45]             CALL    CHKSYN          ; Make sure ',' follows
11AF: 2C                        .BYTE      ','
11B0: 01A711   [10]     DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
11B3: C5       [21]             PUSH    BC              ; Save on stack
11B4: F6                        .BYTE      0F6H            ; Flag "Create" variable
11B5: AF       [ 4]     GETVAR: XOR     A               ; Find variable address,to DE
11B6: 32F120   [17]             LD      (LCRFLG),A      ; Set locate / create flag
11B9: 46       [24]             LD      B,(HL)          ; Get First byte of name
11BA: CDF00B   [17]     GTFNAM: CALL    CHKLTR          ; See if a letter
11BD: DAFA06   [27|27]          JP      C,SNERR         ; ?SN Error if not a letter
11C0: AF       [31]             XOR     A
11C1: 4F       [35]             LD      C,A             ; Clear second byte of name
11C2: 32F220   [48]             LD      (TYPE),A        ; Set type to numeric
11C5: CD4B0B   [65]             CALL    GETCHR          ; Get next character
11C8: DAD111   [75|75]          JP      C,SVNAM2        ; Numeric - Save in name
11CB: CDF00B   [92]             CALL    CHKLTR          ; See if a letter
11CE: DADE11   [102|102]        JP      C,CHARTY        ; Not a letter - Check type
11D1: 4F       [ 4]     SVNAM2: LD      C,A             ; Save second byte of name
11D2: CD4B0B   [17]     ENDNAM: CALL    GETCHR          ; Get next character
11D5: DAD211   [27|27]          JP      C,ENDNAM        ; Numeric - Get another
11D8: CDF00B   [44]             CALL    CHKLTR          ; See if a letter
11DB: D2D211   [54|54]          JP      NC,ENDNAM       ; Letter - Get another
11DE: D624     [ 7]     CHARTY: SUB     '$'             ; String variable?
11E0: C2ED11   [17|17]          JP      NZ,NOTSTR       ; No - Numeric variable
11E3: 3C       [21]             INC     A               ; A = 1 (string type)
11E4: 32F220   [34]             LD      (TYPE),A        ; Set type to string
11E7: 0F       [38]             RRCA                    ; A = 80H , Flag for string
11E8: 81       [42]             ADD     A,C             ; 2nd byte of name has bit 7 on
11E9: 4F       [46]             LD      C,A             ; Resave second byte on name
11EA: CD4B0B   [63]             CALL    GETCHR          ; Get next character
11ED: 3A1021   [13]     NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
11F0: 3D       [17]             DEC     A
11F1: CA9A12   [27|27]          JP      Z,ARLDSV        ; Yes - Get array name
11F4: F2FD11   [37|37]          JP      P,NSCFOR        ; No array with "FOR" or "FN"
11F7: 7E       [44]             LD      A,(HL)          ; Get byte again
11F8: D628     [51]             SUB     '('             ; Subscripted variable?
11FA: CA7212   [61|61]          JP      Z,SBSCPT        ; Yes - Sort out subscript
                        
11FD: AF       [ 4]     NSCFOR: XOR     A               ; Simple variable
11FE: 321021   [17]             LD      (FORFLG),A      ; Clear "FOR" flag
1201: E5       [28]             PUSH    HL              ; Save code string address
1202: 50       [32]             LD      D,B             ; DE = Variable name to find
1203: 59       [36]             LD      E,C
1204: 2A2321   [52]             LD      HL,(FNRGNM)     ; FN argument name
1207: CDBB09   [69]             CALL    CPDEHL          ; Is it the FN argument?
120A: 112521   [79]             LD      DE,FNARG        ; Point to argument value
120D: CAE218   [89|89]          JP      Z,POPHRT        ; Yes - Return FN argument value
1210: 2A1D21   [105]            LD      HL,(VAREND)     ; End of variables
1213: EB       [109]            EX      DE,HL           ; Address of end of search
1214: 2A1B21   [125]            LD      HL,(PROGND)     ; Start of variables address
1217: CDBB09   [17]     FNDVAR: CALL    CPDEHL          ; End of variable list table?
121A: CA3012   [27|27]          JP      Z,CFEVAL        ; Yes - Called from EVAL?
121D: 79       [31]             LD      A,C             ; Get second byte of name
121E: 96       [38]             SUB     (HL)            ; Compare with name in list
121F: 23       [44]             INC     HL              ; Move on to first byte
1220: C22512   [54|54]          JP      NZ,FNTHR        ; Different - Find another
1223: 78       [58]             LD      A,B             ; Get first byte of name
1224: 96       [65]             SUB     (HL)            ; Compare with name in list
1225: 23       [ 6]     FNTHR:  INC     HL              ; Move on to LSB of value
1226: CA6412   [16|16]          JP      Z,RETADR        ; Found - Return address
1229: 23       [22]             INC     HL              ; <- Skip
122A: 23       [28]             INC     HL              ; <- over
122B: 23       [34]             INC     HL              ; <- F.P.
122C: 23       [40]             INC     HL              ; <- value
122D: C31712   [50]             JP      FNDVAR          ; Keep looking
                        
1230: E1       [10]     CFEVAL: POP     HL              ; Restore code string address
1231: E3       [29]             EX      (SP),HL         ; Get return address
1232: D5       [40]             PUSH    DE              ; Save address of variable
1233: 11B210   [50]             LD      DE,FRMEVL       ; Return address in EVAL
1236: CDBB09   [67]             CALL    CPDEHL          ; Called from EVAL ?
1239: D1       [77]             POP     DE              ; Restore address of variable
123A: CA6712   [87|87]          JP      Z,RETNUL        ; Yes - Return null variable
123D: E3       [106]            EX      (SP),HL         ; Put back return
123E: E5       [117]            PUSH    HL              ; Save code string address
123F: C5       [128]            PUSH    BC              ; Save variable name
1240: 010600   [138]            LD      BC,6            ; 2 byte name plus 4 byte data
1243: 2A1F21   [154]            LD      HL,(ARREND)     ; End of arrays
1246: E5       [165]            PUSH    HL              ; Save end of arrays
1247: 09       [176]            ADD     HL,BC           ; Move up 6 bytes
1248: C1       [186]            POP     BC              ; Source address in BC
1249: E5       [197]            PUSH    HL              ; Save new end address
124A: CDC606   [214]            CALL    MOVUP           ; Move arrays up
124D: E1       [224]            POP     HL              ; Restore new end address
124E: 221F21   [240]            LD      (ARREND),HL     ; Set new end address
1251: 60       [244]            LD      H,B             ; End of variables to HL
1252: 69       [248]            LD      L,C
1253: 221D21   [264]            LD      (VAREND),HL     ; Set new end address
                        
1256: 2B       [ 6]     ZEROLP: DEC     HL              ; Back through to zero variable
1257: 3600     [16]             LD      (HL),0          ; Zero byte in variable
1259: CDBB09   [33]             CALL    CPDEHL          ; Done them all?
125C: C25612   [43|43]          JP      NZ,ZEROLP       ; No - Keep on going
125F: D1       [53]             POP     DE              ; Get variable name
1260: 73       [60]             LD      (HL),E          ; Store second character
1261: 23       [66]             INC     HL
1262: 72       [73]             LD      (HL),D          ; Store first character
1263: 23       [79]             INC     HL
1264: EB       [ 4]     RETADR: EX      DE,HL           ; Address of variable in DE
1265: E1       [14]             POP     HL              ; Restore code string address
1266: C9       [24]             RET
                        
1267: 322C21   [13]     RETNUL: LD      (FPEXP),A       ; Set result to zero
126A: 219606   [23]             LD      HL,ZERBYT       ; Also set a null string
126D: 222921   [39]             LD      (FPREG),HL      ; Save for EVAL
1270: E1       [49]             POP     HL              ; Restore code string address
1271: C9       [59]             RET
                        
1272: E5       [11]     SBSCPT: PUSH    HL              ; Save code string address
1273: 2AF120   [27]             LD      HL,(LCRFLG)     ; Locate/Create and Type
1276: E3       [46]             EX      (SP),HL         ; Save and get code string
1277: 57       [50]             LD      D,A             ; Zero number of dimensions
1278: D5       [11]     SCPTLP: PUSH    DE              ; Save number of dimensions
1279: C5       [22]             PUSH    BC              ; Save array name
127A: CDF80B   [39]             CALL    FPSINT          ; Get subscript (0-32767)
127D: C1       [49]             POP     BC              ; Restore array name
127E: F1       [59]             POP     AF              ; Get number of dimensions
127F: EB       [63]             EX      DE,HL
1280: E3       [82]             EX      (SP),HL         ; Save subscript value
1281: E5       [93]             PUSH    HL              ; Save LCRFLG and TYPE
1282: EB       [97]             EX      DE,HL
1283: 3C       [101]            INC     A               ; Count dimensions
1284: 57       [105]            LD      D,A             ; Save in D
1285: 7E       [112]            LD      A,(HL)          ; Get next byte in code string
1286: FE2C     [119]            CP      ','             ; Comma (more to come)?
1288: CA7812   [129|129]        JP      Z,SCPTLP        ; Yes - More subscripts
128B: CDC109   [146]            CALL    CHKSYN          ; Make sure ")" follows
128E: 29                        .BYTE      ")"
128F: 221521   [162]            LD      (NXTOPR),HL     ; Save code string address
1292: E1       [172]            POP     HL              ; Get LCRFLG and TYPE
1293: 22F120   [188]            LD      (LCRFLG),HL     ; Restore Locate/create & type
1296: 1E00     [195]            LD      E,0             ; Flag not CSAVE* or CLOAD*
1298: D5       [206]            PUSH    DE              ; Save number of dimensions (D)
1299: 11                        .BYTE      11H             ; Skip "PUSH HL" and "PUSH AF'
                        
129A: E5       [11]     ARLDSV: PUSH    HL              ; Save code string address
129B: F5       [22]             PUSH    AF              ; A = 00 , Flags set = Z,N
129C: 2A1D21   [38]             LD      HL,(VAREND)     ; Start of arrays
129F: 3E                        .BYTE      3EH             ; Skip "ADD HL,DE"
12A0: 19       [11]     FNDARY: ADD     HL,DE           ; Move to next array start
12A1: EB       [15]             EX      DE,HL
12A2: 2A1F21   [31]             LD      HL,(ARREND)     ; End of arrays
12A5: EB       [35]             EX      DE,HL           ; Current array pointer
12A6: CDBB09   [52]             CALL    CPDEHL          ; End of arrays found?
12A9: CAD212   [62|62]          JP      Z,CREARY        ; Yes - Create array
12AC: 7E       [69]             LD      A,(HL)          ; Get second byte of name
12AD: B9       [73]             CP      C               ; Compare with name given
12AE: 23       [79]             INC     HL              ; Move on
12AF: C2B412   [89|89]          JP      NZ,NXTARY       ; Different - Find next array
12B2: 7E       [96]             LD      A,(HL)          ; Get first byte of name
12B3: B8       [100]            CP      B               ; Compare with name given
12B4: 23       [ 6]     NXTARY: INC     HL              ; Move on
12B5: 5E       [13]             LD      E,(HL)          ; Get LSB of next array address
12B6: 23       [19]             INC     HL
12B7: 56       [26]             LD      D,(HL)          ; Get MSB of next array address
12B8: 23       [32]             INC     HL
12B9: C2A012   [42|42]          JP      NZ,FNDARY       ; Not found - Keep looking
12BC: 3AF120   [55]             LD      A,(LCRFLG)      ; Found Locate or Create it?
12BF: B7       [59]             OR      A
12C0: C20307   [69|69]          JP      NZ,DDERR        ; Create - ?DD Error
12C3: F1       [79]             POP     AF              ; Locate - Get number of dim'ns
12C4: 44       [83]             LD      B,H             ; BC Points to array dim'ns
12C5: 4D       [87]             LD      C,L
12C6: CAE218   [97|97]          JP      Z,POPHRT        ; Jump if array load/save
12C9: 96       [104]            SUB     (HL)            ; Same number of dimensions?
12CA: CA3013   [114|114]        JP      Z,FINDEL        ; Yes - Find element
12CD: 1E10     [ 7]     BSERR:  LD      E,BS            ; ?BS Error
12CF: C30E07   [17]             JP      ERROR           ; Output error
                        
12D2: 110400   [10]     CREARY: LD      DE,4            ; 4 Bytes per entry
12D5: F1       [20]             POP     AF              ; Array to save or 0 dim'ns?
12D6: CA190C   [30|30]          JP      Z,FCERR         ; Yes - ?FC Error
12D9: 71       [37]             LD      (HL),C          ; Save second byte of name
12DA: 23       [43]             INC     HL
12DB: 70       [50]             LD      (HL),B          ; Save first byte of name
12DC: 23       [56]             INC     HL
12DD: 4F       [60]             LD      C,A             ; Number of dimensions to C
12DE: CDD706   [77]             CALL    CHKSTK          ; Check if enough memory
12E1: 23       [83]             INC     HL              ; Point to number of dimensions
12E2: 23       [89]             INC     HL
12E3: 220A21   [105]            LD      (CUROPR),HL     ; Save address of pointer
12E6: 71       [112]            LD      (HL),C          ; Set number of dimensions
12E7: 23       [118]            INC     HL
12E8: 3AF120   [131]            LD      A,(LCRFLG)      ; Locate of Create?
12EB: 17       [135]            RLA                     ; Carry set = Create
12EC: 79       [139]            LD      A,C             ; Get number of dimensions
12ED: 010B00   [10]     CRARLP: LD      BC,10+1         ; Default dimension size 10
12F0: D2F512   [20|20]          JP      NC,DEFSIZ       ; Locate - Set default size
12F3: C1       [30]             POP     BC              ; Get specified dimension size
12F4: 03       [36]             INC     BC              ; Include zero element
12F5: 71       [ 7]     DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
12F6: 23       [13]             INC     HL
12F7: 70       [20]             LD      (HL),B          ; Save MSB of dimension size
12F8: 23       [26]             INC     HL
12F9: F5       [37]             PUSH    AF              ; Save num' of dim'ns an status
12FA: E5       [48]             PUSH    HL              ; Save address of dim'n size
12FB: CD8D1A   [65]             CALL    MLDEBC          ; Multiply DE by BC to find
12FE: EB       [69]             EX      DE,HL           ; amount of mem needed (to DE)
12FF: E1       [79]             POP     HL              ; Restore address of dimension
1300: F1       [89]             POP     AF              ; Restore number of dimensions
1301: 3D       [93]             DEC     A               ; Count them
1302: C2ED12   [103|103]        JP      NZ,CRARLP       ; Do next dimension if more
1305: F5       [114]            PUSH    AF              ; Save locate/create flag
1306: 42       [118]            LD      B,D             ; MSB of memory needed
1307: 4B       [122]            LD      C,E             ; LSB of memory needed
1308: EB       [126]            EX      DE,HL
1309: 19       [137]            ADD     HL,DE           ; Add bytes to array start
130A: DAEF06   [147|147]        JP      C,OMERR         ; Too big - Error
130D: CDE006   [164]            CALL    ENFMEM          ; See if enough memory
1310: 221F21   [180]            LD      (ARREND),HL     ; Save new end of array
                        
1313: 2B       [ 6]     ZERARY: DEC     HL              ; Back through array data
1314: 3600     [16]             LD      (HL),0          ; Set array element to zero
1316: CDBB09   [33]             CALL    CPDEHL          ; All elements zeroed?
1319: C21313   [43|43]          JP      NZ,ZERARY       ; No - Keep on going
131C: 03       [49]             INC     BC              ; Number of bytes + 1
131D: 57       [53]             LD      D,A             ; A=0
131E: 2A0A21   [69]             LD      HL,(CUROPR)     ; Get address of array
1321: 5E       [76]             LD      E,(HL)          ; Number of dimensions
1322: EB       [80]             EX      DE,HL           ; To HL
1323: 29       [91]             ADD     HL,HL           ; Two bytes per dimension size
1324: 09       [102]            ADD     HL,BC           ; Add number of bytes
1325: EB       [106]            EX      DE,HL           ; Bytes needed to DE
1326: 2B       [112]            DEC     HL
1327: 2B       [118]            DEC     HL
1328: 73       [125]            LD      (HL),E          ; Save LSB of bytes needed
1329: 23       [131]            INC     HL
132A: 72       [138]            LD      (HL),D          ; Save MSB of bytes needed
132B: 23       [144]            INC     HL
132C: F1       [154]            POP     AF              ; Locate / Create?
132D: DA5413   [164|164]        JP      C,ENDDIM        ; A is 0 , End if create
1330: 47       [ 4]     FINDEL: LD      B,A             ; Find array element
1331: 4F       [ 8]             LD      C,A
1332: 7E       [15]             LD      A,(HL)          ; Number of dimensions
1333: 23       [21]             INC     HL
1334: 16                        .BYTE      16H             ; Skip "POP HL"
1335: E1       [10]     FNDELP: POP     HL              ; Address of next dim' size
1336: 5E       [17]             LD      E,(HL)          ; Get LSB of dim'n size
1337: 23       [23]             INC     HL
1338: 56       [30]             LD      D,(HL)          ; Get MSB of dim'n size
1339: 23       [36]             INC     HL
133A: E3       [55]             EX      (SP),HL         ; Save address - Get index
133B: F5       [66]             PUSH    AF              ; Save number of dim'ns
133C: CDBB09   [83]             CALL    CPDEHL          ; Dimension too large?
133F: D2CD12   [93|93]          JP      NC,BSERR        ; Yes - ?BS Error
1342: E5       [104]            PUSH    HL              ; Save index
1343: CD8D1A   [121]            CALL    MLDEBC          ; Multiply previous by size
1346: D1       [131]            POP     DE              ; Index supplied to DE
1347: 19       [142]            ADD     HL,DE           ; Add index to pointer
1348: F1       [152]            POP     AF              ; Number of dimensions
1349: 3D       [156]            DEC     A               ; Count them
134A: 44       [160]            LD      B,H             ; MSB of pointer
134B: 4D       [164]            LD      C,L             ; LSB of pointer
134C: C23513   [174|174]        JP      NZ,FNDELP       ; More - Keep going
134F: 29       [185]            ADD     HL,HL           ; 4 Bytes per element
1350: 29       [196]            ADD     HL,HL
1351: C1       [206]            POP     BC              ; Start of array
1352: 09       [217]            ADD     HL,BC           ; Point to element
1353: EB       [221]            EX      DE,HL           ; Address of element to DE
1354: 2A1521   [16]     ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
1357: C9       [26]             RET
                        
1358: 2A1F21   [16]     FRE:    LD      HL,(ARREND)     ; Start of free memory
135B: EB       [20]             EX      DE,HL           ; To DE
135C: 210000   [30]             LD      HL,0            ; End of free memory
135F: 39       [41]             ADD     HL,SP           ; Current stack value
1360: 3AF220   [54]             LD      A,(TYPE)        ; Dummy argument type
1363: B7       [58]             OR      A
1364: CA7413   [68|68]          JP      Z,FRENUM        ; Numeric - Free variable space
1367: CDDB15   [85]             CALL    GSTRCU          ; Current string to pool
136A: CDDB14   [102]            CALL    GARBGE          ; Garbage collection
136D: 2A9F20   [118]            LD      HL,(STRSPC)     ; Bottom of string space in use
1370: EB       [122]            EX      DE,HL           ; To DE
1371: 2A0821   [138]            LD      HL,(STRBOT)     ; Bottom of string space
1374: 7D       [ 4]     FRENUM: LD      A,L             ; Get LSB of end
1375: 93       [ 8]             SUB     E               ; Subtract LSB of beginning
1376: 4F       [12]             LD      C,A             ; Save difference if C
1377: 7C       [16]             LD      A,H             ; Get MSB of end
1378: 9A       [20]             SBC     A,D             ; Subtract MSB of beginning
1379: 41       [ 4]     ACPASS: LD      B,C             ; Return integer AC
137A: 50       [ 4]     ABPASS: LD      D,B             ; Return integer AB
137B: 1E00     [11]             LD      E,0
137D: 21F220   [21]             LD      HL,TYPE         ; Point to type
1380: 73       [28]             LD      (HL),E          ; Set type to numeric
1381: 0690     [35]             LD      B,80H+16        ; 16 bit integer
1383: C3B819   [45]             JP      RETINT          ; Return the integr
                        
1386: 3AF020   [13]     POS:    LD      A,(CURPOS)      ; Get cursor position
1389: 47       [ 4]     PASSA:  LD      B,A             ; Put A into AB
138A: AF       [ 8]             XOR     A               ; Zero A
138B: C37A13   [18]             JP      ABPASS          ; Return integer AB
                        
138E: CD1114   [17]     DEF:    CALL    CHEKFN          ; Get "FN" and name
1391: CD0314   [34]             CALL    IDTEST          ; Test for illegal direct
1394: 01E90C   [44]             LD      BC,DATA         ; To get next statement
1397: C5       [55]             PUSH    BC              ; Save address for RETurn
1398: D5       [66]             PUSH    DE              ; Save address of function ptr
1399: CDC109   [83]             CALL    CHKSYN          ; Make sure "(" follows
139C: 28                        .BYTE      "("
139D: CDB511   [100]            CALL    GETVAR          ; Get argument variable name
13A0: E5       [111]            PUSH    HL              ; Save code string address
13A1: EB       [115]            EX      DE,HL           ; Argument address to HL
13A2: 2B       [121]            DEC     HL
13A3: 56       [128]            LD      D,(HL)          ; Get first byte of arg name
13A4: 2B       [134]            DEC     HL
13A5: 5E       [141]            LD      E,(HL)          ; Get second byte of arg name
13A6: E1       [151]            POP     HL              ; Restore code string address
13A7: CDC20F   [168]            CALL    TSTNUM          ; Make sure numeric argument
13AA: CDC109   [185]            CALL    CHKSYN          ; Make sure ")" follows
13AD: 29                        .BYTE      ")"
13AE: CDC109   [202]            CALL    CHKSYN          ; Make sure "=" follows
13B1: B4                        .BYTE      ZEQUAL          ; "=" token
13B2: 44       [206]            LD      B,H             ; Code string address to BC
13B3: 4D       [210]            LD      C,L
13B4: E3       [229]            EX      (SP),HL         ; Save code str , Get FN ptr
13B5: 71       [236]            LD      (HL),C          ; Save LSB of FN code string
13B6: 23       [242]            INC     HL
13B7: 70       [249]            LD      (HL),B          ; Save MSB of FN code string
13B8: C35014   [259]            JP      SVSTAD          ; Save address and do function
                        
13BB: CD1114   [17]     DOFN:   CALL    CHEKFN          ; Make sure FN follows
13BE: D5       [28]             PUSH    DE              ; Save function pointer address
13BF: CD9610   [45]             CALL    EVLPAR          ; Evaluate expression in "()"
13C2: CDC20F   [62]             CALL    TSTNUM          ; Make sure numeric result
13C5: E3       [81]             EX      (SP),HL         ; Save code str , Get FN ptr
13C6: 5E       [88]             LD      E,(HL)          ; Get LSB of FN code string
13C7: 23       [94]             INC     HL
13C8: 56       [101]            LD      D,(HL)          ; Get MSB of FN code string
13C9: 23       [107]            INC     HL
13CA: 7A       [111]            LD      A,D             ; And function DEFined?
13CB: B3       [115]            OR      E
13CC: CA0607   [125|125]        JP      Z,UFERR         ; No - ?UF Error
13CF: 7E       [132]            LD      A,(HL)          ; Get LSB of argument address
13D0: 23       [138]            INC     HL
13D1: 66       [145]            LD      H,(HL)          ; Get MSB of argument address
13D2: 6F       [149]            LD      L,A             ; HL = Arg variable address
13D3: E5       [160]            PUSH    HL              ; Save it
13D4: 2A2321   [176]            LD      HL,(FNRGNM)     ; Get old argument name
13D7: E3       [195]            EX      (SP),HL ;       ; Save old , Get new
13D8: 222321   [211]            LD      (FNRGNM),HL     ; Set new argument name
13DB: 2A2721   [227]            LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
13DE: E5       [238]            PUSH    HL              ; Save it
13DF: 2A2521   [254]            LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
13E2: E5       [265]            PUSH    HL              ; Save it
13E3: 212521   [275]            LD      HL,FNARG        ; HL = Value of argument
13E6: D5       [286]            PUSH    DE              ; Save FN code string address
13E7: CDF919   [303]            CALL    FPTHL           ; Move FPREG to argument
13EA: E1       [313]            POP     HL              ; Get FN code string address
13EB: CDBF0F   [330]            CALL    GETNUM          ; Get value from function
13EE: 2B       [336]            DEC     HL              ; DEC 'cos GETCHR INCs
13EF: CD4B0B   [353]            CALL    GETCHR          ; Get next character
13F2: C2FA06   [363|363]        JP      NZ,SNERR        ; Bad character in FN - Error
13F5: E1       [373]            POP     HL              ; Get MSB,EXP of old arg
13F6: 222521   [389]            LD      (FNARG),HL      ; Restore it
13F9: E1       [399]            POP     HL              ; Get LSB,NLSB of old arg
13FA: 222721   [415]            LD      (FNARG+2),HL    ; Restore it
13FD: E1       [425]            POP     HL              ; Get name of old arg
13FE: 222321   [441]            LD      (FNRGNM),HL     ; Restore it
1401: E1       [451]            POP     HL              ; Restore code string address
1402: C9       [461]            RET
                        
1403: E5       [11]     IDTEST: PUSH    HL              ; Save code string address
1404: 2AA120   [27]             LD      HL,(LINEAT)     ; Get current line number
1407: 23       [33]             INC     HL              ; -1 means direct statement
1408: 7C       [37]             LD      A,H
1409: B5       [41]             OR      L
140A: E1       [51]             POP     HL              ; Restore code string address
140B: C0       [56|62]          RET     NZ              ; Return if in program
140C: 1E16     [63]             LD      E,ID            ; ?ID Error
140E: C30E07   [73]             JP      ERROR
                        
1411: CDC109   [17]     CHEKFN: CALL    CHKSYN          ; Make sure FN follows
1414: A7                        .BYTE      ZFN             ; "FN" token
1415: 3E80     [24]             LD      A,80H
1417: 321021   [37]             LD      (FORFLG),A      ; Flag FN name to find
141A: B6       [44]             OR      (HL)            ; FN name has bit 7 set
141B: 47       [48]             LD      B,A             ; in first byte of name
141C: CDBA11   [65]             CALL    GTFNAM          ; Get FN name
141F: C3C20F   [75]             JP      TSTNUM          ; Make sure numeric function
                        
1422: CDC20F   [17]     STR:    CALL    TSTNUM          ; Make sure it's a number
1425: CD461B   [34]             CALL    NUMASC          ; Turn number into text
1428: CD5614   [17]     STR1:   CALL    CRTST           ; Create string entry for it
142B: CDDB15   [34]             CALL    GSTRCU          ; Current string to pool
142E: 013616   [44]             LD      BC,TOPOOL       ; Save in string pool
1431: C5       [55]             PUSH    BC              ; Save address on stack
                        
1432: 7E       [ 7]     SAVSTR: LD      A,(HL)          ; Get string length
1433: 23       [13]             INC     HL
1434: 23       [19]             INC     HL
1435: E5       [30]             PUSH    HL              ; Save pointer to string
1436: CDB114   [47]             CALL    TESTR           ; See if enough string space
1439: E1       [57]             POP     HL              ; Restore pointer to string
143A: 4E       [64]             LD      C,(HL)          ; Get LSB of address
143B: 23       [70]             INC     HL
143C: 46       [77]             LD      B,(HL)          ; Get MSB of address
143D: CD4A14   [94]             CALL    CRTMST          ; Create string entry
1440: E5       [105]            PUSH    HL              ; Save pointer to MSB of addr
1441: 6F       [109]            LD      L,A             ; Length of string
1442: CDCE15   [126]            CALL    TOSTRA          ; Move to string area
1445: D1       [136]            POP     DE              ; Restore pointer to MSB
1446: C9       [146]            RET
                        
1447: CDB114   [17]     MKTMST: CALL    TESTR           ; See if enough string space
144A: 210421   [10]     CRTMST: LD      HL,TMPSTR       ; Temporary string
144D: E5       [21]             PUSH    HL              ; Save it
144E: 77       [28]             LD      (HL),A          ; Save length of string
144F: 23       [34]             INC     HL
1450: 23       [ 6]     SVSTAD: INC     HL
1451: 73       [13]             LD      (HL),E          ; Save LSB of address
1452: 23       [19]             INC     HL
1453: 72       [26]             LD      (HL),D          ; Save MSB of address
1454: E1       [36]             POP     HL              ; Restore pointer
1455: C9       [46]             RET
                        
1456: 2B       [ 6]     CRTST:  DEC     HL              ; DEC - INCed after
1457: 0622     [ 7]     QTSTR:  LD      B,'"'           ; Terminating quote
1459: 50       [11]             LD      D,B             ; Quote to D
145A: E5       [11]     DTSTR:  PUSH    HL              ; Save start
145B: 0EFF     [18]             LD      C,-1            ; Set counter to -1
145D: 23       [ 6]     QTSTLP: INC     HL              ; Move on
145E: 7E       [13]             LD      A,(HL)          ; Get byte
145F: 0C       [17]             INC     C               ; Count bytes
1460: B7       [21]             OR      A               ; End of line?
1461: CA6C14   [31|31]          JP      Z,CRTSTE        ; Yes - Create string entry
1464: BA       [35]             CP      D               ; Terminator D found?
1465: CA6C14   [45|45]          JP      Z,CRTSTE        ; Yes - Create string entry
1468: B8       [49]             CP      B               ; Terminator B found?
1469: C25D14   [59|59]          JP      NZ,QTSTLP       ; No - Keep looking
146C: FE22     [ 7]     CRTSTE: CP      '"'             ; End with '"'?
146E: CC4B0B   [17|24]          CALL    Z,GETCHR        ; Yes - Get next character
1471: E3       [36]             EX      (SP),HL         ; Starting quote
1472: 23       [42]             INC     HL              ; First byte of string
1473: EB       [46]             EX      DE,HL           ; To DE
1474: 79       [50]             LD      A,C             ; Get length
1475: CD4A14   [67]             CALL    CRTMST          ; Create string entry
1478: 110421   [10]     TSTOPL: LD      DE,TMPSTR       ; Temporary string
147B: 2AF620   [26]             LD      HL,(TMSTPT)     ; Temporary string pool pointer
147E: 222921   [42]             LD      (FPREG),HL      ; Save address of string ptr
1481: 3E01     [49]             LD      A,1
1483: 32F220   [62]             LD      (TYPE),A        ; Set type to string
1486: CDFC19   [79]             CALL    DETHL4          ; Move string to pool
1489: CDBB09   [96]             CALL    CPDEHL          ; Out of string pool?
148C: 22F620   [112]            LD      (TMSTPT),HL     ; Save new pointer
148F: E1       [122]            POP     HL              ; Restore code string address
1490: 7E       [129]            LD      A,(HL)          ; Get next code byte
1491: C0       [134|140]        RET     NZ              ; Return if pool OK
1492: 1E1E     [141]            LD      E,ST            ; ?ST Error
1494: C30E07   [151]            JP      ERROR           ; String pool overflow
                        
1497: 23       [ 6]     PRNUMS: INC     HL              ; Skip leading space
1498: CD5614   [17]     PRS:    CALL    CRTST           ; Create string entry for it
149B: CDDB15   [17]     PRS1:   CALL    GSTRCU          ; Current string to pool
149E: CDF019   [34]             CALL    LOADFP          ; Move string block to BCDE
14A1: 1C       [38]             INC     E               ; Length + 1
14A2: 1D       [ 4]     PRSLP:  DEC     E               ; Count characters
14A3: C8       [ 9|15]          RET     Z               ; End of string
14A4: 0A       [16]             LD      A,(BC)          ; Get byte to output
14A5: CDCC09   [33]             CALL    OUTC            ; Output character in A
14A8: FE0D     [40]             CP      CR              ; Return?
14AA: CC040E   [50|57]          CALL    Z,DONULL        ; Yes - Do nulls
14AD: 03       [56]             INC     BC              ; Next byte in string
14AE: C3A214   [66]             JP      PRSLP           ; More characters to output
                        
14B1: B7       [ 4]     TESTR:  OR      A               ; Test if enough room
14B2: 0E                        .BYTE      0EH             ; No garbage collection done
14B3: F1       [10]     GRBDON: POP     AF              ; Garbage collection done
14B4: F5       [21]             PUSH    AF              ; Save status
14B5: 2A9F20   [37]             LD      HL,(STRSPC)     ; Bottom of string space in use
14B8: EB       [41]             EX      DE,HL           ; To DE
14B9: 2A0821   [57]             LD      HL,(STRBOT)     ; Bottom of string area
14BC: 2F       [61]             CPL                     ; Negate length (Top down)
14BD: 4F       [65]             LD      C,A             ; -Length to BC
14BE: 06FF     [72]             LD      B,-1            ; BC = -ve length of string
14C0: 09       [83]             ADD     HL,BC           ; Add to bottom of space in use
14C1: 23       [89]             INC     HL              ; Plus one for 2's complement
14C2: CDBB09   [106]            CALL    CPDEHL          ; Below string RAM area?
14C5: DACF14   [116|116]        JP      C,TESTOS        ; Tidy up if not done else err
14C8: 220821   [132]            LD      (STRBOT),HL     ; Save new bottom of area
14CB: 23       [138]            INC     HL              ; Point to first byte of string
14CC: EB       [142]            EX      DE,HL           ; Address to DE
14CD: F1       [10]     POPAF:  POP     AF              ; Throw away status push
14CE: C9       [20]             RET
                        
14CF: F1       [10]     TESTOS: POP     AF              ; Garbage collect been done?
14D0: 1E1A     [17]             LD      E,OS            ; ?OS Error
14D2: CA0E07   [27|27]          JP      Z,ERROR         ; Yes - Not enough string apace
14D5: BF       [31]             CP      A               ; Flag garbage collect done
14D6: F5       [42]             PUSH    AF              ; Save status
14D7: 01B314   [52]             LD      BC,GRBDON       ; Garbage collection done
14DA: C5       [63]             PUSH    BC              ; Save for RETurn
14DB: 2AF420   [16]     GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
14DE: 220821   [16]     GARBLP: LD      (STRBOT),HL     ; Reset string pointer
14E1: 210000   [26]             LD      HL,0
14E4: E5       [37]             PUSH    HL              ; Flag no string found
14E5: 2A9F20   [53]             LD      HL,(STRSPC)     ; Get bottom of string space
14E8: E5       [64]             PUSH    HL              ; Save bottom of string space
14E9: 21F820   [74]             LD      HL,TMSTPL       ; Temporary string pool
14EC: EB       [ 4]     GRBLP:  EX      DE,HL
14ED: 2AF620   [20]             LD      HL,(TMSTPT)     ; Temporary string pool pointer
14F0: EB       [24]             EX      DE,HL
14F1: CDBB09   [41]             CALL    CPDEHL          ; Temporary string pool done?
14F4: 01EC14   [51]             LD      BC,GRBLP        ; Loop until string pool done
14F7: C24015   [61|61]          JP      NZ,STPOOL       ; No - See if in string area
14FA: 2A1B21   [77]             LD      HL,(PROGND)     ; Start of simple variables
14FD: EB       [ 4]     SMPVAR: EX      DE,HL
14FE: 2A1D21   [20]             LD      HL,(VAREND)     ; End of simple variables
1501: EB       [24]             EX      DE,HL
1502: CDBB09   [41]             CALL    CPDEHL          ; All simple strings done?
1505: CA1315   [51|51]          JP      Z,ARRLP         ; Yes - Do string arrays
1508: 7E       [58]             LD      A,(HL)          ; Get type of variable
1509: 23       [64]             INC     HL
150A: 23       [70]             INC     HL
150B: B7       [74]             OR      A               ; "S" flag set if string
150C: CD4315   [91]             CALL    STRADD          ; See if string in string area
150F: C3FD14   [101]            JP      SMPVAR          ; Loop until simple ones done
                        
1512: C1       [10]     GNXARY: POP     BC              ; Scrap address of this array
1513: EB       [ 4]     ARRLP:  EX      DE,HL
1514: 2A1F21   [20]             LD      HL,(ARREND)     ; End of string arrays
1517: EB       [24]             EX      DE,HL
1518: CDBB09   [41]             CALL    CPDEHL          ; All string arrays done?
151B: CA6915   [51|51]          JP      Z,SCNEND        ; Yes - Move string if found
151E: CDF019   [68]             CALL    LOADFP          ; Get array name to BCDE
1521: 7B       [72]             LD      A,E             ; Get type of array     
1522: E5       [83]             PUSH    HL              ; Save address of num of dim'ns
1523: 09       [94]             ADD     HL,BC           ; Start of next array
1524: B7       [98]             OR      A               ; Test type of array
1525: F21215   [108|108]        JP      P,GNXARY        ; Numeric array - Ignore it
1528: 220A21   [124]            LD      (CUROPR),HL     ; Save address of next array
152B: E1       [134]            POP     HL              ; Get address of num of dim'ns
152C: 4E       [141]            LD      C,(HL)          ; BC = Number of dimensions
152D: 0600     [148]            LD      B,0
152F: 09       [159]            ADD     HL,BC           ; Two bytes per dimension size
1530: 09       [170]            ADD     HL,BC
1531: 23       [176]            INC     HL              ; Plus one for number of dim'ns
1532: EB       [ 4]     GRBARY: EX      DE,HL
1533: 2A0A21   [20]             LD      HL,(CUROPR)     ; Get address of next array
1536: EB       [24]             EX      DE,HL
1537: CDBB09   [41]             CALL    CPDEHL          ; Is this array finished?
153A: CA1315   [51|51]          JP      Z,ARRLP         ; Yes - Get next one
153D: 013215   [61]             LD      BC,GRBARY       ; Loop until array all done
1540: C5       [11]     STPOOL: PUSH    BC              ; Save return address
1541: F680     [18]             OR      80H             ; Flag string type
1543: 7E       [ 7]     STRADD: LD      A,(HL)          ; Get string length
1544: 23       [13]             INC     HL
1545: 23       [19]             INC     HL
1546: 5E       [26]             LD      E,(HL)          ; Get LSB of string address
1547: 23       [32]             INC     HL
1548: 56       [39]             LD      D,(HL)          ; Get MSB of string address
1549: 23       [45]             INC     HL
154A: F0       [50|56]          RET     P               ; Not a string - Return
154B: B7       [54]             OR      A               ; Set flags on string length
154C: C8       [59|65]          RET     Z               ; Null string - Return
154D: 44       [63]             LD      B,H             ; Save variable pointer
154E: 4D       [67]             LD      C,L
154F: 2A0821   [83]             LD      HL,(STRBOT)     ; Bottom of new area
1552: CDBB09   [100]            CALL    CPDEHL          ; String been done?
1555: 60       [104]            LD      H,B             ; Restore variable pointer
1556: 69       [108]            LD      L,C
1557: D8       [113|119]        RET     C               ; String done - Ignore
1558: E1       [123]            POP     HL              ; Return address
1559: E3       [142]            EX      (SP),HL         ; Lowest available string area
155A: CDBB09   [159]            CALL    CPDEHL          ; String within string area?
155D: E3       [178]            EX      (SP),HL         ; Lowest available string area
155E: E5       [189]            PUSH    HL              ; Re-save return address
155F: 60       [193]            LD      H,B             ; Restore variable pointer
1560: 69       [197]            LD      L,C
1561: D0       [202|208]        RET     NC              ; Outside string area - Ignore
1562: C1       [212]            POP     BC              ; Get return , Throw 2 away
1563: F1       [222]            POP     AF              ; 
1564: F1       [232]            POP     AF              ; 
1565: E5       [243]            PUSH    HL              ; Save variable pointer
1566: D5       [254]            PUSH    DE              ; Save address of current
1567: C5       [265]            PUSH    BC              ; Put back return address
1568: C9       [275]            RET                     ; Go to it
                        
1569: D1       [10]     SCNEND: POP     DE              ; Addresses of strings
156A: E1       [20]             POP     HL              ; 
156B: 7D       [24]             LD      A,L             ; HL = 0 if no more to do
156C: B4       [28]             OR      H
156D: C8       [33|39]          RET     Z               ; No more to do - Return
156E: 2B       [39]             DEC     HL
156F: 46       [46]             LD      B,(HL)          ; MSB of address of string
1570: 2B       [52]             DEC     HL
1571: 4E       [59]             LD      C,(HL)          ; LSB of address of string
1572: E5       [70]             PUSH    HL              ; Save variable address
1573: 2B       [76]             DEC     HL
1574: 2B       [82]             DEC     HL
1575: 6E       [89]             LD      L,(HL)          ; HL = Length of string
1576: 2600     [96]             LD      H,0
1578: 09       [107]            ADD     HL,BC           ; Address of end of string+1
1579: 50       [111]            LD      D,B             ; String address to DE
157A: 59       [115]            LD      E,C
157B: 2B       [121]            DEC     HL              ; Last byte in string
157C: 44       [125]            LD      B,H             ; Address to BC
157D: 4D       [129]            LD      C,L
157E: 2A0821   [145]            LD      HL,(STRBOT)     ; Current bottom of string area
1581: CDC906   [162]            CALL    MOVSTR          ; Move string to new address
1584: E1       [172]            POP     HL              ; Restore variable address
1585: 71       [179]            LD      (HL),C          ; Save new LSB of address
1586: 23       [185]            INC     HL
1587: 70       [192]            LD      (HL),B          ; Save new MSB of address
1588: 69       [196]            LD      L,C             ; Next string area+1 to HL
1589: 60       [200]            LD      H,B
158A: 2B       [206]            DEC     HL              ; Next string area address
158B: C3DE14   [216]            JP      GARBLP          ; Look for more strings
                        
158E: C5       [11]     CONCAT: PUSH    BC              ; Save prec' opr & code string
158F: E5       [22]             PUSH    HL              ; 
1590: 2A2921   [38]             LD      HL,(FPREG)      ; Get first string
1593: E3       [57]             EX      (SP),HL         ; Save first string
1594: CD4810   [74]             CALL    OPRND           ; Get second string
1597: E3       [93]             EX      (SP),HL         ; Restore first string
1598: CDC30F   [110]            CALL    TSTSTR          ; Make sure it's a string
159B: 7E       [117]            LD      A,(HL)          ; Get length of second string
159C: E5       [128]            PUSH    HL              ; Save first string
159D: 2A2921   [144]            LD      HL,(FPREG)      ; Get second string
15A0: E5       [155]            PUSH    HL              ; Save second string
15A1: 86       [162]            ADD     A,(HL)          ; Add length of second string
15A2: 1E1C     [169]            LD      E,LS            ; ?LS Error
15A4: DA0E07   [179|179]        JP      C,ERROR         ; String too long - Error
15A7: CD4714   [196]            CALL    MKTMST          ; Make temporary string
15AA: D1       [206]            POP     DE              ; Get second string to DE
15AB: CDDF15   [223]            CALL    GSTRDE          ; Move to string pool if needed
15AE: E3       [242]            EX      (SP),HL         ; Get first string
15AF: CDDE15   [259]            CALL    GSTRHL          ; Move to string pool if needed
15B2: E5       [270]            PUSH    HL              ; Save first string
15B3: 2A0621   [286]            LD      HL,(TMPSTR+2)   ; Temporary string address
15B6: EB       [290]            EX      DE,HL           ; To DE
15B7: CDC515   [307]            CALL    SSTSA           ; First string to string area
15BA: CDC515   [324]            CALL    SSTSA           ; Second string to string area
15BD: 21DD0F   [334]            LD      HL,EVAL2        ; Return to evaluation loop
15C0: E3       [353]            EX      (SP),HL         ; Save return,get code string
15C1: E5       [364]            PUSH    HL              ; Save code string address
15C2: C37814   [374]            JP      TSTOPL          ; To temporary string to pool
                        
15C5: E1       [10]     SSTSA:  POP     HL              ; Return address
15C6: E3       [29]             EX      (SP),HL         ; Get string block,save return
15C7: 7E       [36]             LD      A,(HL)          ; Get length of string
15C8: 23       [42]             INC     HL
15C9: 23       [48]             INC     HL
15CA: 4E       [55]             LD      C,(HL)          ; Get LSB of string address
15CB: 23       [61]             INC     HL
15CC: 46       [68]             LD      B,(HL)          ; Get MSB of string address
15CD: 6F       [72]             LD      L,A             ; Length to L
15CE: 2C       [ 4]     TOSTRA: INC     L               ; INC - DECed after
15CF: 2D       [ 4]     TSALP:  DEC     L               ; Count bytes moved
15D0: C8       [ 9|15]          RET     Z               ; End of string - Return
15D1: 0A       [16]             LD      A,(BC)          ; Get source
15D2: 12       [23]             LD      (DE),A          ; Save destination
15D3: 03       [29]             INC     BC              ; Next source
15D4: 13       [35]             INC     DE              ; Next destination
15D5: C3CF15   [45]             JP      TSALP           ; Loop until string moved
                        
15D8: CDC30F   [17]     GETSTR: CALL    TSTSTR          ; Make sure it's a string
15DB: 2A2921   [16]     GSTRCU: LD      HL,(FPREG)      ; Get current string
15DE: EB       [ 4]     GSTRHL: EX      DE,HL           ; Save DE
15DF: CDF915   [17]     GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
15E2: EB       [21]             EX      DE,HL           ; Restore DE
15E3: C0       [26|32]          RET     NZ              ; No - Return
15E4: D5       [37]             PUSH    DE              ; Save string
15E5: 50       [41]             LD      D,B             ; String block address to DE
15E6: 59       [45]             LD      E,C
15E7: 1B       [51]             DEC     DE              ; Point to length
15E8: 4E       [58]             LD      C,(HL)          ; Get string length
15E9: 2A0821   [74]             LD      HL,(STRBOT)     ; Current bottom of string area
15EC: CDBB09   [91]             CALL    CPDEHL          ; Last one in string area?
15EF: C2F715   [101|101]        JP      NZ,POPHL        ; No - Return
15F2: 47       [105]            LD      B,A             ; Clear B (A=0)
15F3: 09       [116]            ADD     HL,BC           ; Remove string from str' area
15F4: 220821   [132]            LD      (STRBOT),HL     ; Save new bottom of str' area
15F7: E1       [10]     POPHL:  POP     HL              ; Restore string
15F8: C9       [20]             RET
                        
15F9: 2AF620   [16]     BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
15FC: 2B       [22]             DEC     HL              ; Back
15FD: 46       [29]             LD      B,(HL)          ; Get MSB of address
15FE: 2B       [35]             DEC     HL              ; Back
15FF: 4E       [42]             LD      C,(HL)          ; Get LSB of address
1600: 2B       [48]             DEC     HL              ; Back
1601: 2B       [54]             DEC     HL              ; Back
1602: CDBB09   [71]             CALL    CPDEHL          ; String last in string pool?
1605: C0       [76|82]          RET     NZ              ; Yes - Leave it
1606: 22F620   [92]             LD      (TMSTPT),HL     ; Save new string pool top
1609: C9       [102]            RET
                        
160A: 018913   [10]     LEN:    LD      BC,PASSA        ; To return integer A
160D: C5       [21]             PUSH    BC              ; Save address
160E: CDD815   [17]     GETLEN: CALL    GETSTR          ; Get string and its length
1611: AF       [21]             XOR     A
1612: 57       [25]             LD      D,A             ; Clear D
1613: 32F220   [38]             LD      (TYPE),A        ; Set type to numeric
1616: 7E       [45]             LD      A,(HL)          ; Get length of string
1617: B7       [49]             OR      A               ; Set status flags
1618: C9       [59]             RET
                        
1619: 018913   [10]     ASC:    LD      BC,PASSA        ; To return integer A
161C: C5       [21]             PUSH    BC              ; Save address
161D: CD0E16   [17]     GTFLNM: CALL    GETLEN          ; Get length of string
1620: CA190C   [27|27]          JP      Z,FCERR         ; Null string - Error
1623: 23       [33]             INC     HL
1624: 23       [39]             INC     HL
1625: 5E       [46]             LD      E,(HL)          ; Get LSB of address
1626: 23       [52]             INC     HL
1627: 56       [59]             LD      D,(HL)          ; Get MSB of address
1628: 1A       [66]             LD      A,(DE)          ; Get first byte of string
1629: C9       [76]             RET
                        
162A: 3E01     [ 7]     CHR:    LD      A,1             ; One character string
162C: CD4714   [24]             CALL    MKTMST          ; Make a temporary string
162F: CD2317   [41]             CALL    MAKINT          ; Make it integer A
1632: 2A0621   [57]             LD      HL,(TMPSTR+2)   ; Get address of string
1635: 73       [64]             LD      (HL),E          ; Save character
1636: C1       [10]     TOPOOL: POP     BC              ; Clean up stack
1637: C37814   [20]             JP      TSTOPL          ; Temporary string to pool
                        
163A: CDD316   [17]     LEFT:   CALL    LFRGNM          ; Get number and ending ")"
163D: AF       [21]             XOR     A               ; Start at first byte in string
163E: E3       [19]     RIGHT1: EX      (SP),HL         ; Save code string,Get string
163F: 4F       [23]             LD      C,A             ; Starting position in string
1640: E5       [11]     MID1:   PUSH    HL              ; Save string block address
1641: 7E       [18]             LD      A,(HL)          ; Get length of string
1642: B8       [22]             CP      B               ; Compare with number given
1643: DA4816   [32|32]          JP      C,ALLFOL        ; All following bytes required
1646: 78       [36]             LD      A,B             ; Get new length
1647: 11                        .BYTE      11H             ; Skip "LD C,0"
1648: 0E00     [ 7]     ALLFOL: LD      C,0             ; First byte of string
164A: C5       [18]             PUSH    BC              ; Save position in string
164B: CDB114   [35]             CALL    TESTR           ; See if enough string space
164E: C1       [45]             POP     BC              ; Get position in string
164F: E1       [55]             POP     HL              ; Restore string block address
1650: E5       [66]             PUSH    HL              ; And re-save it
1651: 23       [72]             INC     HL
1652: 23       [78]             INC     HL
1653: 46       [85]             LD      B,(HL)          ; Get LSB of address
1654: 23       [91]             INC     HL
1655: 66       [98]             LD      H,(HL)          ; Get MSB of address
1656: 68       [102]            LD      L,B             ; HL = address of string
1657: 0600     [109]            LD      B,0             ; BC = starting address
1659: 09       [120]            ADD     HL,BC           ; Point to that byte
165A: 44       [124]            LD      B,H             ; BC = source string
165B: 4D       [128]            LD      C,L
165C: CD4A14   [145]            CALL    CRTMST          ; Create a string entry
165F: 6F       [149]            LD      L,A             ; Length of new string
1660: CDCE15   [166]            CALL    TOSTRA          ; Move string to string area
1663: D1       [176]            POP     DE              ; Clear stack
1664: CDDF15   [193]            CALL    GSTRDE          ; Move to string pool if needed
1667: C37814   [203]            JP      TSTOPL          ; Temporary string to pool
                        
166A: CDD316   [17]     RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
166D: D1       [27]             POP     DE              ; Get string length
166E: D5       [38]             PUSH    DE              ; And re-save
166F: 1A       [45]             LD      A,(DE)          ; Get length
1670: 90       [49]             SUB     B               ; Move back N bytes
1671: C33E16   [59]             JP      RIGHT1          ; Go and get sub-string
                        
1674: EB       [ 4]     MID:    EX      DE,HL           ; Get code string address
1675: 7E       [11]             LD      A,(HL)          ; Get next byte ',' or ")"
1676: CDD816   [28]             CALL    MIDNUM          ; Get number supplied
1679: 04       [32]             INC     B               ; Is it character zero?
167A: 05       [36]             DEC     B
167B: CA190C   [46|46]          JP      Z,FCERR         ; Yes - Error
167E: C5       [57]             PUSH    BC              ; Save starting position
167F: 1EFF     [64]             LD      E,255           ; All of string
1681: FE29     [71]             CP      ')'             ; Any length given?
1683: CA8D16   [81|81]          JP      Z,RSTSTR        ; No - Rest of string
1686: CDC109   [98]             CALL    CHKSYN          ; Make sure ',' follows
1689: 2C                        .BYTE      ','
168A: CD2017   [115]            CALL    GETINT          ; Get integer 0-255
168D: CDC109   [17]     RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
1690: 29                        .BYTE      ")"
1691: F1       [27]             POP     AF              ; Restore starting position
1692: E3       [46]             EX      (SP),HL         ; Get string,8ave code string
1693: 014016   [56]             LD      BC,MID1         ; Continuation of MID$ routine
1696: C5       [67]             PUSH    BC              ; Save for return
1697: 3D       [71]             DEC     A               ; Starting position-1
1698: BE       [78]             CP      (HL)            ; Compare with length
1699: 0600     [85]             LD      B,0             ; Zero bytes length
169B: D0       [90|96]          RET     NC              ; Null string if start past end
169C: 4F       [94]             LD      C,A             ; Save starting position-1
169D: 7E       [101]            LD      A,(HL)          ; Get length of string
169E: 91       [105]            SUB     C               ; Subtract start
169F: BB       [109]            CP      E               ; Enough string for it?
16A0: 47       [113]            LD      B,A             ; Save maximum length available
16A1: D8       [118|124]        RET     C               ; Truncate string if needed
16A2: 43       [122]            LD      B,E             ; Set specified length
16A3: C9       [132]            RET                     ; Go and create string
                        
16A4: CD0E16   [17]     VAL:    CALL    GETLEN          ; Get length of string
16A7: CAC117   [27|27]          JP      Z,RESZER        ; Result zero
16AA: 5F       [31]             LD      E,A             ; Save length
16AB: 23       [37]             INC     HL
16AC: 23       [43]             INC     HL
16AD: 7E       [50]             LD      A,(HL)          ; Get LSB of address
16AE: 23       [56]             INC     HL
16AF: 66       [63]             LD      H,(HL)          ; Get MSB of address
16B0: 6F       [67]             LD      L,A             ; HL = String address
16B1: E5       [78]             PUSH    HL              ; Save string address
16B2: 19       [89]             ADD     HL,DE
16B3: 46       [96]             LD      B,(HL)          ; Get end of string+1 byte
16B4: 72       [103]            LD      (HL),D          ; Zero it to terminate
16B5: E3       [122]            EX      (SP),HL         ; Save string end,get start
16B6: C5       [133]            PUSH    BC              ; Save end+1 byte
16B7: 7E       [140]            LD      A,(HL)          ; Get starting byte
16B8: FE24     [147]        CP	'$'		; Hex number indicated? [function added]
16BA: C2C216   [157|157]    JP	NZ,VAL1
16BD: CDF21E   [174]        CALL	HEXTFP		; Convert Hex to FPREG
16C0: 180D     [186]        JR	VAL3
16C2: FE25     [ 7]     VAL1:	CP	'%'		; Binary number indicated? [function added]
16C4: C2CC16   [17|17]      JP	NZ,VAL2
16C7: CD621F   [34]         CALL	BINTFP		; Convert Bin to FPREG
16CA: 1803     [46]         JR	VAL3
16CC: CDA81A   [17]     VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
16CF: C1       [10]     VAL3:   POP     BC              ; Restore end+1 byte
16D0: E1       [20]             POP     HL              ; Restore end+1 address
16D1: 70       [27]             LD      (HL),B          ; Put back original byte
16D2: C9       [37]             RET
                        
16D3: EB       [ 4]     LFRGNM: EX      DE,HL           ; Code string address to HL
16D4: CDC109   [21]             CALL    CHKSYN          ; Make sure ")" follows
16D7: 29                        .BYTE      ")"
16D8: C1       [10]     MIDNUM: POP     BC              ; Get return address
16D9: D1       [20]             POP     DE              ; Get number supplied
16DA: C5       [31]             PUSH    BC              ; Re-save return address
16DB: 43       [35]             LD      B,E             ; Number to B
16DC: C9       [45]             RET
                        
16DD: CD2317   [17]     INP:    CALL    MAKINT          ; Make it integer A
16E0: 328420   [30]             LD      (INPORT),A      ; Set input port
16E3: CD8320   [47]             CALL    INPSUB          ; Get input from port
16E6: C38913   [57]             JP      PASSA           ; Return integer A
                        
16E9: CD0D17   [17]     POUT:   CALL    SETIO           ; Set up port number
16EC: C34B20   [27]             JP      OUTSUB          ; Output data and return
                        
16EF: CD0D17   [17]     WAIT:   CALL    SETIO           ; Set up port number
16F2: F5       [28]             PUSH    AF              ; Save AND mask
16F3: 1E00     [35]             LD      E,0             ; Assume zero if none given
16F5: 2B       [41]             DEC     HL              ; DEC 'cos GETCHR INCs
16F6: CD4B0B   [58]             CALL    GETCHR          ; Get next character
16F9: CA0317   [68|68]          JP      Z,NOXOR         ; No XOR byte given
16FC: CDC109   [85]             CALL    CHKSYN          ; Make sure ',' follows
16FF: 2C                        .BYTE      ','
1700: CD2017   [102]            CALL    GETINT          ; Get integer 0-255 to XOR with
1703: C1       [10]     NOXOR:  POP     BC              ; Restore AND mask
1704: CD8320   [17]     WAITLP: CALL    INPSUB          ; Get input
1707: AB       [21]             XOR     E               ; Flip selected bits
1708: A0       [25]             AND     B               ; Result non-zero?
1709: CA0417   [35|35]          JP      Z,WAITLP        ; No = keep waiting
170C: C9       [45]             RET
                        
170D: CD2017   [17]     SETIO:  CALL    GETINT          ; Get integer 0-255
1710: 328420   [30]             LD      (INPORT),A      ; Set input port
1713: 324C20   [43]             LD      (OTPORT),A      ; Set output port
1716: CDC109   [60]             CALL    CHKSYN          ; Make sure ',' follows
1719: 2C                        .BYTE      ','
171A: C32017   [70]             JP      GETINT          ; Get integer 0-255 and return
                        
171D: CD4B0B   [17]     FNDNUM: CALL    GETCHR          ; Get next character
1720: CDBF0F   [17]     GETINT: CALL    GETNUM          ; Get a number from 0 to 255
1723: CDFE0B   [17]     MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
1726: 7A       [21]             LD      A,D             ; Get MSB of number
1727: B7       [25]             OR      A               ; Zero?
1728: C2190C   [35|35]          JP      NZ,FCERR        ; No - Error
172B: 2B       [41]             DEC     HL              ; DEC 'cos GETCHR INCs
172C: CD4B0B   [58]             CALL    GETCHR          ; Get next character
172F: 7B       [62]             LD      A,E             ; Get number to A
1730: C9       [72]             RET
                        
1731: CD040C   [17]     PEEK:   CALL    DEINT           ; Get memory address
1734: 1A       [24]             LD      A,(DE)          ; Get byte in memory
1735: C38913   [34]             JP      PASSA           ; Return integer A
                        
1738: CDBF0F   [17]     POKE:   CALL    GETNUM          ; Get memory address
173B: CD040C   [34]             CALL    DEINT           ; Get integer -32768 to 3276
173E: D5       [45]             PUSH    DE              ; Save memory address
173F: CDC109   [62]             CALL    CHKSYN          ; Make sure ',' follows
1742: 2C                        .BYTE      ','
1743: CD2017   [79]             CALL    GETINT          ; Get integer 0-255
1746: D1       [89]             POP     DE              ; Restore memory address
1747: 12       [96]             LD      (DE),A          ; Load it into memory
1748: C9       [106]            RET
                        
1749: 211F1C   [10]     ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
174C: CDF019   [17]     ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
174F: C35B17   [27]             JP      FPADD           ; Add BCDE to FPREG
                        
1752: CDF019   [17]     SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
1755: 21                        .BYTE      21H             ; Skip "POP BC" and "POP DE"
1756: C1       [10]     PSUB:   POP     BC              ; Get FP number from stack
1757: D1       [20]             POP     DE
1758: CDCA19   [17]     SUBCDE: CALL    INVSGN          ; Negate FPREG
175B: 78       [ 4]     FPADD:  LD      A,B             ; Get FP exponent
175C: B7       [ 8]             OR      A               ; Is number zero?
175D: C8       [13|19]          RET     Z               ; Yes - Nothing to add
175E: 3A2C21   [26]             LD      A,(FPEXP)       ; Get FPREG exponent
1761: B7       [30]             OR      A               ; Is this number zero?
1762: CAE219   [40|40]          JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
1765: 90       [44]             SUB     B               ; BCDE number larger?
1766: D27517   [54|54]          JP      NC,NOSWAP       ; No - Don't swap them
1769: 2F       [58]             CPL                     ; Two's complement
176A: 3C       [62]             INC     A               ;  FP exponent
176B: EB       [66]             EX      DE,HL
176C: CDD219   [83]             CALL    STAKFP          ; Put FPREG on stack
176F: EB       [87]             EX      DE,HL
1770: CDE219   [104]            CALL    FPBCDE          ; Move BCDE to FPREG
1773: C1       [114]            POP     BC              ; Restore number from stack
1774: D1       [124]            POP     DE
1775: FE19     [ 7]     NOSWAP: CP      24+1            ; Second number insignificant?
1777: D0       [12|18]          RET     NC              ; Yes - First number is result
1778: F5       [23]             PUSH    AF              ; Save number of bits to scale
1779: CD071A   [40]             CALL    SIGNS           ; Set MSBs & sign of result
177C: 67       [44]             LD      H,A             ; Save sign of result
177D: F1       [54]             POP     AF              ; Restore scaling factor
177E: CD2018   [71]             CALL    SCALE           ; Scale BCDE to same exponent
1781: B4       [75]             OR      H               ; Result to be positive?
1782: 212921   [85]             LD      HL,FPREG        ; Point to FPREG
1785: F29B17   [95|95]          JP      P,MINCDE        ; No - Subtract FPREG from CDE
1788: CD0018   [112]            CALL    PLUCDE          ; Add FPREG to CDE
178B: D2E117   [122|122]        JP      NC,RONDUP       ; No overflow - Round it up
178E: 23       [128]            INC     HL              ; Point to exponent
178F: 34       [139]            INC     (HL)            ; Increment it
1790: CA0907   [149|149]        JP      Z,OVERR         ; Number overflowed - Error
1793: 2E01     [156]            LD      L,1             ; 1 bit to shift right
1795: CD3618   [173]            CALL    SHRT1           ; Shift result right
1798: C3E117   [183]            JP      RONDUP          ; Round it up
                        
179B: AF       [ 4]     MINCDE: XOR     A               ; Clear A and carry
179C: 90       [ 8]             SUB     B               ; Negate exponent
179D: 47       [12]             LD      B,A             ; Re-save exponent
179E: 7E       [19]             LD      A,(HL)          ; Get LSB of FPREG
179F: 9B       [23]             SBC     A, E            ; Subtract LSB of BCDE
17A0: 5F       [27]             LD      E,A             ; Save LSB of BCDE
17A1: 23       [33]             INC     HL
17A2: 7E       [40]             LD      A,(HL)          ; Get NMSB of FPREG
17A3: 9A       [44]             SBC     A,D             ; Subtract NMSB of BCDE
17A4: 57       [48]             LD      D,A             ; Save NMSB of BCDE
17A5: 23       [54]             INC     HL
17A6: 7E       [61]             LD      A,(HL)          ; Get MSB of FPREG
17A7: 99       [65]             SBC     A,C             ; Subtract MSB of BCDE
17A8: 4F       [69]             LD      C,A             ; Save MSB of BCDE
17A9: DC0C18   [10|17]  CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
                        
17AC: 68       [ 4]     BNORM:  LD      L,B             ; L = Exponent
17AD: 63       [ 8]             LD      H,E             ; H = LSB
17AE: AF       [12]             XOR     A
17AF: 47       [ 4]     BNRMLP: LD      B,A             ; Save bit count
17B0: 79       [ 8]             LD      A,C             ; Get MSB
17B1: B7       [12]             OR      A               ; Is it zero?
17B2: C2CE17   [22|22]          JP      NZ,PNORM        ; No - Do it bit at a time
17B5: 4A       [26]             LD      C,D             ; MSB = NMSB
17B6: 54       [30]             LD      D,H             ; NMSB= LSB
17B7: 65       [34]             LD      H,L             ; LSB = VLSB
17B8: 6F       [38]             LD      L,A             ; VLSB= 0
17B9: 78       [42]             LD      A,B             ; Get exponent
17BA: D608     [49]             SUB     8               ; Count 8 bits
17BC: FEE0     [56]             CP      -24-8           ; Was number zero?
17BE: C2AF17   [66|66]          JP      NZ,BNRMLP       ; No - Keep normalising
17C1: AF       [ 4]     RESZER: XOR     A               ; Result is zero
17C2: 322C21   [13]     SAVEXP: LD      (FPEXP),A       ; Save result as zero
17C5: C9       [23]             RET
                        
17C6: 05       [ 4]     NORMAL: DEC     B               ; Count bits
17C7: 29       [15]             ADD     HL,HL           ; Shift HL left
17C8: 7A       [19]             LD      A,D             ; Get NMSB
17C9: 17       [23]             RLA                     ; Shift left with last bit
17CA: 57       [27]             LD      D,A             ; Save NMSB
17CB: 79       [31]             LD      A,C             ; Get MSB
17CC: 8F       [35]             ADC     A,A             ; Shift left with last bit
17CD: 4F       [39]             LD      C,A             ; Save MSB
17CE: F2C617   [10|10]  PNORM:  JP      P,NORMAL        ; Not done - Keep going
17D1: 78       [14]             LD      A,B             ; Number of bits shifted
17D2: 5C       [18]             LD      E,H             ; Save HL in EB
17D3: 45       [22]             LD      B,L
17D4: B7       [26]             OR      A               ; Any shifting done?
17D5: CAE117   [36|36]          JP      Z,RONDUP        ; No - Round it up
17D8: 212C21   [46]             LD      HL,FPEXP        ; Point to exponent
17DB: 86       [53]             ADD     A,(HL)          ; Add shifted bits
17DC: 77       [60]             LD      (HL),A          ; Re-save exponent
17DD: D2C117   [70|70]          JP      NC,RESZER       ; Underflow - Result is zero
17E0: C8       [75|81]          RET     Z               ; Result is zero
17E1: 78       [ 4]     RONDUP: LD      A,B             ; Get VLSB of number
17E2: 212C21   [10]     RONDB:  LD      HL,FPEXP        ; Point to exponent
17E5: B7       [14]             OR      A               ; Any rounding?
17E6: FCF317   [24|31]          CALL    M,FPROND        ; Yes - Round number up
17E9: 46       [31]             LD      B,(HL)          ; B = Exponent
17EA: 23       [37]             INC     HL
17EB: 7E       [44]             LD      A,(HL)          ; Get sign of result
17EC: E680     [51]             AND     10000000B       ; Only bit 7 needed
17EE: A9       [55]             XOR     C               ; Set correct sign
17EF: 4F       [59]             LD      C,A             ; Save correct sign in number
17F0: C3E219   [69]             JP      FPBCDE          ; Move BCDE to FPREG
                        
17F3: 1C       [ 4]     FPROND: INC     E               ; Round LSB
17F4: C0       [ 9|15]          RET     NZ              ; Return if ok
17F5: 14       [13]             INC     D               ; Round NMSB
17F6: C0       [18|24]          RET     NZ              ; Return if ok
17F7: 0C       [22]             INC     C               ; Round MSB
17F8: C0       [27|33]          RET     NZ              ; Return if ok
17F9: 0E80     [34]             LD      C,80H           ; Set normal value
17FB: 34       [45]             INC     (HL)            ; Increment exponent
17FC: C0       [50|56]          RET     NZ              ; Return if ok
17FD: C30907   [60]             JP      OVERR           ; Overflow error
                        
1800: 7E       [ 7]     PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
1801: 83       [11]             ADD     A,E             ; Add LSB of BCDE
1802: 5F       [15]             LD      E,A             ; Save LSB of BCDE
1803: 23       [21]             INC     HL
1804: 7E       [28]             LD      A,(HL)          ; Get NMSB of FPREG
1805: 8A       [32]             ADC     A,D             ; Add NMSB of BCDE
1806: 57       [36]             LD      D,A             ; Save NMSB of BCDE
1807: 23       [42]             INC     HL
1808: 7E       [49]             LD      A,(HL)          ; Get MSB of FPREG
1809: 89       [53]             ADC     A,C             ; Add MSB of BCDE
180A: 4F       [57]             LD      C,A             ; Save MSB of BCDE
180B: C9       [67]             RET
                        
180C: 212D21   [10]     COMPL:  LD      HL,SGNRES       ; Sign of result
180F: 7E       [17]             LD      A,(HL)          ; Get sign of result
1810: 2F       [21]             CPL                     ; Negate it
1811: 77       [28]             LD      (HL),A          ; Put it back
1812: AF       [32]             XOR     A
1813: 6F       [36]             LD      L,A             ; Set L to zero
1814: 90       [40]             SUB     B               ; Negate exponent,set carry
1815: 47       [44]             LD      B,A             ; Re-save exponent
1816: 7D       [48]             LD      A,L             ; Load zero
1817: 9B       [52]             SBC     A,E             ; Negate LSB
1818: 5F       [56]             LD      E,A             ; Re-save LSB
1819: 7D       [60]             LD      A,L             ; Load zero
181A: 9A       [64]             SBC     A,D             ; Negate NMSB
181B: 57       [68]             LD      D,A             ; Re-save NMSB
181C: 7D       [72]             LD      A,L             ; Load zero
181D: 99       [76]             SBC     A,C             ; Negate MSB
181E: 4F       [80]             LD      C,A             ; Re-save MSB
181F: C9       [90]             RET
                        
1820: 0600     [ 7]     SCALE:  LD      B,0             ; Clear underflow
1822: D608     [ 7]     SCALLP: SUB     8               ; 8 bits (a whole byte)?
1824: DA2F18   [17|17]          JP      C,SHRITE        ; No - Shift right A bits
1827: 43       [21]             LD      B,E             ; <- Shift
1828: 5A       [25]             LD      E,D             ; <- right
1829: 51       [29]             LD      D,C             ; <- eight
182A: 0E00     [36]             LD      C,0             ; <- bits
182C: C32218   [46]             JP      SCALLP          ; More bits to shift
                        
182F: C609     [ 7]     SHRITE: ADD     A,8+1           ; Adjust count
1831: 6F       [11]             LD      L,A             ; Save bits to shift
1832: AF       [ 4]     SHRLP:  XOR     A               ; Flag for all done
1833: 2D       [ 8]             DEC     L               ; All shifting done?
1834: C8       [13|19]          RET     Z               ; Yes - Return
1835: 79       [17]             LD      A,C             ; Get MSB
1836: 1F       [ 4]     SHRT1:  RRA                     ; Shift it right
1837: 4F       [ 8]             LD      C,A             ; Re-save
1838: 7A       [12]             LD      A,D             ; Get NMSB
1839: 1F       [16]             RRA                     ; Shift right with last bit
183A: 57       [20]             LD      D,A             ; Re-save it
183B: 7B       [24]             LD      A,E             ; Get LSB
183C: 1F       [28]             RRA                     ; Shift right with last bit
183D: 5F       [32]             LD      E,A             ; Re-save it
183E: 78       [36]             LD      A,B             ; Get underflow
183F: 1F       [40]             RRA                     ; Shift right with last bit
1840: 47       [44]             LD      B,A             ; Re-save underflow
1841: C33218   [54]             JP      SHRLP           ; More bits to do
                        
1844: 00000081          UNITY:  .BYTE       000H,000H,000H,081H    ; 1.00000
                        
1848: 03                LOGTAB: .BYTE      3                       ; Table used by LOG
1849: AA561980                  .BYTE      0AAH,056H,019H,080H     ; 0.59898
184D: F1227680                  .BYTE      0F1H,022H,076H,080H     ; 0.96147
1851: 45AA3882                  .BYTE      045H,0AAH,038H,082H     ; 2.88539
                        
1855: CDA119   [17]     LOG:    CALL    TSTSGN          ; Test sign of value
1858: B7       [21]             OR      A
1859: EA190C   [31|31]          JP      PE,FCERR        ; ?FC Error if <= zero
185C: 212C21   [41]             LD      HL,FPEXP        ; Point to exponent
185F: 7E       [48]             LD      A,(HL)          ; Get exponent
1860: 013580   [58]             LD      BC,8035H        ; BCDE = SQR(1/2)
1863: 11F304   [68]             LD      DE,04F3H
1866: 90       [72]             SUB     B               ; Scale value to be < 1
1867: F5       [83]             PUSH    AF              ; Save scale factor
1868: 70       [90]             LD      (HL),B          ; Save new exponent
1869: D5       [101]            PUSH    DE              ; Save SQR(1/2)
186A: C5       [112]            PUSH    BC
186B: CD5B17   [129]            CALL    FPADD           ; Add SQR(1/2) to value
186E: C1       [139]            POP     BC              ; Restore SQR(1/2)
186F: D1       [149]            POP     DE
1870: 04       [153]            INC     B               ; Make it SQR(2)
1871: CDF718   [170]            CALL    DVBCDE          ; Divide by SQR(2)
1874: 214418   [180]            LD      HL,UNITY        ; Point to 1.
1877: CD5217   [197]            CALL    SUBPHL          ; Subtract FPREG from 1
187A: 214818   [207]            LD      HL,LOGTAB       ; Coefficient table
187D: CDE91C   [224]            CALL    SUMSER          ; Evaluate sum of series
1880: 018080   [234]            LD      BC,8080H        ; BCDE = -0.5
1883: 110000   [244]            LD      DE,0000H
1886: CD5B17   [261]            CALL    FPADD           ; Subtract 0.5 from FPREG
1889: F1       [271]            POP     AF              ; Restore scale factor
188A: CD1C1B   [288]            CALL    RSCALE          ; Re-scale number
188D: 013180   [10]     MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
1890: 111872   [20]             LD      DE,7218H
1893: 21                        .BYTE      21H             ; Skip "POP BC" and "POP DE"
                        
1894: C1       [10]     MULT:   POP     BC              ; Get number from stack
1895: D1       [20]             POP     DE
1896: CDA119   [17]     FPMULT: CALL    TSTSGN          ; Test sign of FPREG
1899: C8       [22|28]          RET     Z               ; Return zero if zero
189A: 2E00     [29]             LD      L,0             ; Flag add exponents
189C: CD5F19   [46]             CALL    ADDEXP          ; Add exponents
189F: 79       [50]             LD      A,C             ; Get MSB of multiplier
18A0: 323B21   [63]             LD      (MULVAL),A      ; Save MSB of multiplier
18A3: EB       [67]             EX      DE,HL
18A4: 223C21   [83]             LD      (MULVAL+1),HL   ; Save rest of multiplier
18A7: 010000   [93]             LD      BC,0            ; Partial product (BCDE) = zero
18AA: 50       [97]             LD      D,B
18AB: 58       [101]            LD      E,B
18AC: 21AC17   [111]            LD      HL,BNORM        ; Address of normalise
18AF: E5       [122]            PUSH    HL              ; Save for return
18B0: 21B818   [132]            LD      HL,MULT8        ; Address of 8 bit multiply
18B3: E5       [143]            PUSH    HL              ; Save for NMSB,MSB
18B4: E5       [154]            PUSH    HL              ; 
18B5: 212921   [164]            LD      HL,FPREG        ; Point to number
18B8: 7E       [ 7]     MULT8:  LD      A,(HL)          ; Get LSB of number
18B9: 23       [13]             INC     HL              ; Point to NMSB
18BA: B7       [17]             OR      A               ; Test LSB
18BB: CAE418   [27|27]          JP      Z,BYTSFT        ; Zero - shift to next byte
18BE: E5       [38]             PUSH    HL              ; Save address of number
18BF: 2E08     [45]             LD      L,8             ; 8 bits to multiply by
18C1: 1F       [ 4]     MUL8LP: RRA                     ; Shift LSB right
18C2: 67       [ 8]             LD      H,A             ; Save LSB
18C3: 79       [12]             LD      A,C             ; Get MSB
18C4: D2D218   [22|22]          JP      NC,NOMADD       ; Bit was zero - Don't add
18C7: E5       [33]             PUSH    HL              ; Save LSB and count
18C8: 2A3C21   [49]             LD      HL,(MULVAL+1)   ; Get LSB and NMSB
18CB: 19       [60]             ADD     HL,DE           ; Add NMSB and LSB
18CC: EB       [64]             EX      DE,HL           ; Leave sum in DE
18CD: E1       [74]             POP     HL              ; Restore MSB and count
18CE: 3A3B21   [87]             LD      A,(MULVAL)      ; Get MSB of multiplier
18D1: 89       [91]             ADC     A,C             ; Add MSB
18D2: 1F       [ 4]     NOMADD: RRA                     ; Shift MSB right
18D3: 4F       [ 8]             LD      C,A             ; Re-save MSB
18D4: 7A       [12]             LD      A,D             ; Get NMSB
18D5: 1F       [16]             RRA                     ; Shift NMSB right
18D6: 57       [20]             LD      D,A             ; Re-save NMSB
18D7: 7B       [24]             LD      A,E             ; Get LSB
18D8: 1F       [28]             RRA                     ; Shift LSB right
18D9: 5F       [32]             LD      E,A             ; Re-save LSB
18DA: 78       [36]             LD      A,B             ; Get VLSB
18DB: 1F       [40]             RRA                     ; Shift VLSB right
18DC: 47       [44]             LD      B,A             ; Re-save VLSB
18DD: 2D       [48]             DEC     L               ; Count bits multiplied
18DE: 7C       [52]             LD      A,H             ; Get LSB of multiplier
18DF: C2C118   [62|62]          JP      NZ,MUL8LP       ; More - Do it
18E2: E1       [10]     POPHRT: POP     HL              ; Restore address of number
18E3: C9       [20]             RET
                        
18E4: 43       [ 4]     BYTSFT: LD      B,E             ; Shift partial product left
18E5: 5A       [ 8]             LD      E,D
18E6: 51       [12]             LD      D,C
18E7: 4F       [16]             LD      C,A
18E8: C9       [26]             RET
                        
18E9: CDD219   [17]     DIV10:  CALL    STAKFP          ; Save FPREG on stack
18EC: 012084   [27]             LD      BC,8420H        ; BCDE = 10.
18EF: 110000   [37]             LD      DE,0000H
18F2: CDE219   [54]             CALL    FPBCDE          ; Move 10 to FPREG
                        
18F5: C1       [10]     DIV:    POP     BC              ; Get number from stack
18F6: D1       [20]             POP     DE
18F7: CDA119   [17]     DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
18FA: CAFD06   [27|27]          JP      Z,DZERR         ; Error if division by zero
18FD: 2EFF     [34]             LD      L,-1            ; Flag subtract exponents
18FF: CD5F19   [51]             CALL    ADDEXP          ; Subtract exponents
1902: 34       [62]             INC     (HL)            ; Add 2 to exponent to adjust
1903: 34       [73]             INC     (HL)
1904: 2B       [79]             DEC     HL              ; Point to MSB
1905: 7E       [86]             LD      A,(HL)          ; Get MSB of dividend
1906: 325720   [99]             LD      (DIV3),A        ; Save for subtraction
1909: 2B       [105]            DEC     HL
190A: 7E       [112]            LD      A,(HL)          ; Get NMSB of dividend
190B: 325320   [125]            LD      (DIV2),A        ; Save for subtraction
190E: 2B       [131]            DEC     HL
190F: 7E       [138]            LD      A,(HL)          ; Get MSB of dividend
1910: 324F20   [151]            LD      (DIV1),A        ; Save for subtraction
1913: 41       [155]            LD      B,C             ; Get MSB
1914: EB       [159]            EX      DE,HL           ; NMSB,LSB to HL
1915: AF       [163]            XOR     A
1916: 4F       [167]            LD      C,A             ; Clear MSB of quotient
1917: 57       [171]            LD      D,A             ; Clear NMSB of quotient
1918: 5F       [175]            LD      E,A             ; Clear LSB of quotient
1919: 325A20   [188]            LD      (DIV4),A        ; Clear overflow count
191C: E5       [11]     DIVLP:  PUSH    HL              ; Save divisor
191D: C5       [22]             PUSH    BC
191E: 7D       [26]             LD      A,L             ; Get LSB of number
191F: CD4E20   [43]             CALL    DIVSUP          ; Subt' divisor from dividend
1922: DE00     [50]             SBC     A,0             ; Count for overflows
1924: 3F       [54]             CCF
1925: D22F19   [64|64]          JP      NC,RESDIV       ; Restore divisor if borrow
1928: 325A20   [77]             LD      (DIV4),A        ; Re-save overflow count
192B: F1       [87]             POP     AF              ; Scrap divisor
192C: F1       [97]             POP     AF
192D: 37       [101]            SCF                     ; Set carry to
192E: D2                        .BYTE      0D2H            ; Skip "POP BC" and "POP HL"
                        
192F: C1       [10]     RESDIV: POP     BC              ; Restore divisor
1930: E1       [20]             POP     HL
1931: 79       [24]             LD      A,C             ; Get MSB of quotient
1932: 3C       [28]             INC     A
1933: 3D       [32]             DEC     A
1934: 1F       [36]             RRA                     ; Bit 0 to bit 7
1935: FAE217   [46|46]          JP      M,RONDB         ; Done - Normalise result
1938: 17       [50]             RLA                     ; Restore carry
1939: 7B       [54]             LD      A,E             ; Get LSB of quotient
193A: 17       [58]             RLA                     ; Double it
193B: 5F       [62]             LD      E,A             ; Put it back
193C: 7A       [66]             LD      A,D             ; Get NMSB of quotient
193D: 17       [70]             RLA                     ; Double it
193E: 57       [74]             LD      D,A             ; Put it back
193F: 79       [78]             LD      A,C             ; Get MSB of quotient
1940: 17       [82]             RLA                     ; Double it
1941: 4F       [86]             LD      C,A             ; Put it back
1942: 29       [97]             ADD     HL,HL           ; Double NMSB,LSB of divisor
1943: 78       [101]            LD      A,B             ; Get MSB of divisor
1944: 17       [105]            RLA                     ; Double it
1945: 47       [109]            LD      B,A             ; Put it back
1946: 3A5A20   [122]            LD      A,(DIV4)        ; Get VLSB of quotient
1949: 17       [126]            RLA                     ; Double it
194A: 325A20   [139]            LD      (DIV4),A        ; Put it back
194D: 79       [143]            LD      A,C             ; Get MSB of quotient
194E: B2       [147]            OR      D               ; Merge NMSB
194F: B3       [151]            OR      E               ; Merge LSB
1950: C21C19   [161|161]        JP      NZ,DIVLP        ; Not done - Keep dividing
1953: E5       [172]            PUSH    HL              ; Save divisor
1954: 212C21   [182]            LD      HL,FPEXP        ; Point to exponent
1957: 35       [193]            DEC     (HL)            ; Divide by 2
1958: E1       [203]            POP     HL              ; Restore divisor
1959: C21C19   [213|213]        JP      NZ,DIVLP        ; Ok - Keep going
195C: C30907   [223]            JP      OVERR           ; Overflow error
                        
195F: 78       [ 4]     ADDEXP: LD      A,B             ; Get exponent of dividend
1960: B7       [ 8]             OR      A               ; Test it
1961: CA8319   [18|18]          JP      Z,OVTST3        ; Zero - Result zero
1964: 7D       [22]             LD      A,L             ; Get add/subtract flag
1965: 212C21   [32]             LD      HL,FPEXP        ; Point to exponent
1968: AE       [39]             XOR     (HL)            ; Add or subtract it
1969: 80       [43]             ADD     A,B             ; Add the other exponent
196A: 47       [47]             LD      B,A             ; Save new exponent
196B: 1F       [51]             RRA                     ; Test exponent for overflow
196C: A8       [55]             XOR     B
196D: 78       [59]             LD      A,B             ; Get exponent
196E: F28219   [69|69]          JP      P,OVTST2        ; Positive - Test for overflow
1971: C680     [76]             ADD     A,80H           ; Add excess 128
1973: 77       [83]             LD      (HL),A          ; Save new exponent
1974: CAE218   [93|93]          JP      Z,POPHRT        ; Zero - Result zero
1977: CD071A   [110]            CALL    SIGNS           ; Set MSBs and sign of result
197A: 77       [117]            LD      (HL),A          ; Save new exponent
197B: 2B       [123]            DEC     HL              ; Point to MSB
197C: C9       [133]            RET
                        
197D: CDA119   [17]     OVTST1: CALL    TSTSGN          ; Test sign of FPREG
1980: 2F       [21]             CPL                     ; Invert sign
1981: E1       [31]             POP     HL              ; Clean up stack
1982: B7       [ 4]     OVTST2: OR      A               ; Test if new exponent zero
1983: E1       [10]     OVTST3: POP     HL              ; Clear off return address
1984: F2C117   [20|20]          JP      P,RESZER        ; Result zero
1987: C30907   [30]             JP      OVERR           ; Overflow error
                        
198A: CDED19   [17]     MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
198D: 78       [21]             LD      A,B             ; Get exponent
198E: B7       [25]             OR      A               ; Is it zero?
198F: C8       [30|36]          RET     Z               ; Yes - Result is zero
1990: C602     [37]             ADD     A,2             ; Multiply by 4
1992: DA0907   [47|47]          JP      C,OVERR         ; Overflow - ?OV Error
1995: 47       [51]             LD      B,A             ; Re-save exponent
1996: CD5B17   [68]             CALL    FPADD           ; Add BCDE to FPREG (Times 5)
1999: 212C21   [78]             LD      HL,FPEXP        ; Point to exponent
199C: 34       [89]             INC     (HL)            ; Double number (Times 10)
199D: C0       [94|100]         RET     NZ              ; Ok - Return
199E: C30907   [104]            JP      OVERR           ; Overflow error
                        
19A1: 3A2C21   [13]     TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
19A4: B7       [17]             OR      A
19A5: C8       [22|28]          RET     Z               ; RETurn if number is zero
19A6: 3A2B21   [35]             LD      A,(FPREG+2)     ; Get MSB of FPREG
19A9: FE                        .BYTE      0FEH            ; Test sign
19AA: 2F       [ 4]     RETREL: CPL                     ; Invert sign
19AB: 17       [ 8]             RLA                     ; Sign bit to carry
19AC: 9F       [ 4]     FLGDIF: SBC     A,A             ; Carry to all bits of A
19AD: C0       [ 9|15]          RET     NZ              ; Return -1 if negative
19AE: 3C       [13]             INC     A               ; Bump to +1
19AF: C9       [23]             RET                     ; Positive - Return +1
                        
19B0: CDA119   [17]     SGN:    CALL    TSTSGN          ; Test sign of FPREG
19B3: 0688     [ 7]     FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
19B5: 110000   [17]             LD      DE,0            ; Zero NMSB and LSB
19B8: 212C21   [10]     RETINT: LD      HL,FPEXP        ; Point to exponent
19BB: 4F       [14]             LD      C,A             ; CDE = MSB,NMSB and LSB
19BC: 70       [21]             LD      (HL),B          ; Save exponent
19BD: 0600     [28]             LD      B,0             ; CDE = integer to normalise
19BF: 23       [34]             INC     HL              ; Point to sign of result
19C0: 3680     [44]             LD      (HL),80H        ; Set sign of result
19C2: 17       [48]             RLA                     ; Carry = sign of integer
19C3: C3A917   [58]             JP      CONPOS          ; Set sign of result
                        
19C6: CDA119   [17]     ABS:    CALL    TSTSGN          ; Test sign of FPREG
19C9: F0       [22|28]          RET     P               ; Return if positive
19CA: 212B21   [10]     INVSGN: LD      HL,FPREG+2      ; Point to MSB
19CD: 7E       [17]             LD      A,(HL)          ; Get sign of mantissa
19CE: EE80     [24]             XOR     80H             ; Invert sign of mantissa
19D0: 77       [31]             LD      (HL),A          ; Re-save sign of mantissa
19D1: C9       [41]             RET
                        
19D2: EB       [ 4]     STAKFP: EX      DE,HL           ; Save code string address
19D3: 2A2921   [20]             LD      HL,(FPREG)      ; LSB,NLSB of FPREG
19D6: E3       [39]             EX      (SP),HL         ; Stack them,get return
19D7: E5       [50]             PUSH    HL              ; Re-save return
19D8: 2A2B21   [66]             LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
19DB: E3       [85]             EX      (SP),HL         ; Stack them,get return
19DC: E5       [96]             PUSH    HL              ; Re-save return
19DD: EB       [100]            EX      DE,HL           ; Restore code string address
19DE: C9       [110]            RET
                        
19DF: CDF019   [17]     PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
19E2: EB       [ 4]     FPBCDE: EX      DE,HL           ; Save code string address
19E3: 222921   [20]             LD      (FPREG),HL      ; Save LSB,NLSB of number
19E6: 60       [24]             LD      H,B             ; Exponent of number
19E7: 69       [28]             LD      L,C             ; MSB of number
19E8: 222B21   [44]             LD      (FPREG+2),HL    ; Save MSB and exponent
19EB: EB       [48]             EX      DE,HL           ; Restore code string address
19EC: C9       [58]             RET
                        
19ED: 212921   [10]     BCDEFP: LD      HL,FPREG        ; Point to FPREG
19F0: 5E       [ 7]     LOADFP: LD      E,(HL)          ; Get LSB of number
19F1: 23       [13]             INC     HL
19F2: 56       [20]             LD      D,(HL)          ; Get NMSB of number
19F3: 23       [26]             INC     HL
19F4: 4E       [33]             LD      C,(HL)          ; Get MSB of number
19F5: 23       [39]             INC     HL
19F6: 46       [46]             LD      B,(HL)          ; Get exponent of number
19F7: 23       [ 6]     INCHL:  INC     HL              ; Used for conditional "INC HL"
19F8: C9       [16]             RET
                        
19F9: 112921   [10]     FPTHL:  LD      DE,FPREG        ; Point to FPREG
19FC: 0604     [ 7]     DETHL4: LD      B,4             ; 4 bytes to move
19FE: 1A       [ 7]     DETHLB: LD      A,(DE)          ; Get source
19FF: 77       [14]             LD      (HL),A          ; Save destination
1A00: 13       [20]             INC     DE              ; Next source
1A01: 23       [26]             INC     HL              ; Next destination
1A02: 05       [30]             DEC     B               ; Count bytes
1A03: C2FE19   [40|40]          JP      NZ,DETHLB       ; Loop if more
1A06: C9       [50]             RET
                        
1A07: 212B21   [10]     SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
1A0A: 7E       [17]             LD      A,(HL)          ; Get MSB
1A0B: 07       [21]             RLCA                    ; Old sign to carry
1A0C: 37       [25]             SCF                     ; Set MSBit
1A0D: 1F       [29]             RRA                     ; Set MSBit of MSB
1A0E: 77       [36]             LD      (HL),A          ; Save new MSB
1A0F: 3F       [40]             CCF                     ; Complement sign
1A10: 1F       [44]             RRA                     ; Old sign to carry
1A11: 23       [50]             INC     HL
1A12: 23       [56]             INC     HL
1A13: 77       [63]             LD      (HL),A          ; Set sign of result
1A14: 79       [67]             LD      A,C             ; Get MSB
1A15: 07       [71]             RLCA                    ; Old sign to carry
1A16: 37       [75]             SCF                     ; Set MSBit
1A17: 1F       [79]             RRA                     ; Set MSBit of MSB
1A18: 4F       [83]             LD      C,A             ; Save MSB
1A19: 1F       [87]             RRA
1A1A: AE       [94]             XOR     (HL)            ; New sign of result
1A1B: C9       [104]            RET
                        
1A1C: 78       [ 4]     CMPNUM: LD      A,B             ; Get exponent of number
1A1D: B7       [ 8]             OR      A
1A1E: CAA119   [18|18]          JP      Z,TSTSGN        ; Zero - Test sign of FPREG
1A21: 21AA19   [28]             LD      HL,RETREL       ; Return relation routine
1A24: E5       [39]             PUSH    HL              ; Save for return
1A25: CDA119   [56]             CALL    TSTSGN          ; Test sign of FPREG
1A28: 79       [60]             LD      A,C             ; Get MSB of number
1A29: C8       [65|71]          RET     Z               ; FPREG zero - Number's MSB
1A2A: 212B21   [75]             LD      HL,FPREG+2      ; MSB of FPREG
1A2D: AE       [82]             XOR     (HL)            ; Combine signs
1A2E: 79       [86]             LD      A,C             ; Get MSB of number
1A2F: F8       [91|97]          RET     M               ; Exit if signs different
1A30: CD361A   [108]            CALL    CMPFP           ; Compare FP numbers
1A33: 1F       [112]            RRA                     ; Get carry to sign
1A34: A9       [116]            XOR     C               ; Combine with MSB of number
1A35: C9       [126]            RET
                        
1A36: 23       [ 6]     CMPFP:  INC     HL              ; Point to exponent
1A37: 78       [10]             LD      A,B             ; Get exponent
1A38: BE       [17]             CP      (HL)            ; Compare exponents
1A39: C0       [22|28]          RET     NZ              ; Different
1A3A: 2B       [28]             DEC     HL              ; Point to MBS
1A3B: 79       [32]             LD      A,C             ; Get MSB
1A3C: BE       [39]             CP      (HL)            ; Compare MSBs
1A3D: C0       [44|50]          RET     NZ              ; Different
1A3E: 2B       [50]             DEC     HL              ; Point to NMSB
1A3F: 7A       [54]             LD      A,D             ; Get NMSB
1A40: BE       [61]             CP      (HL)            ; Compare NMSBs
1A41: C0       [66|72]          RET     NZ              ; Different
1A42: 2B       [72]             DEC     HL              ; Point to LSB
1A43: 7B       [76]             LD      A,E             ; Get LSB
1A44: 96       [83]             SUB     (HL)            ; Compare LSBs
1A45: C0       [88|94]          RET     NZ              ; Different
1A46: E1       [98]             POP     HL              ; Drop RETurn
1A47: E1       [108]            POP     HL              ; Drop another RETurn
1A48: C9       [118]            RET
                        
1A49: 47       [ 4]     FPINT:  LD      B,A             ; <- Move
1A4A: 4F       [ 8]             LD      C,A             ; <- exponent
1A4B: 57       [12]             LD      D,A             ; <- to all
1A4C: 5F       [16]             LD      E,A             ; <- bits
1A4D: B7       [20]             OR      A               ; Test exponent
1A4E: C8       [25|31]          RET     Z               ; Zero - Return zero
1A4F: E5       [36]             PUSH    HL              ; Save pointer to number
1A50: CDED19   [53]             CALL    BCDEFP          ; Move FPREG to BCDE
1A53: CD071A   [70]             CALL    SIGNS           ; Set MSBs & sign of result
1A56: AE       [77]             XOR     (HL)            ; Combine with sign of FPREG
1A57: 67       [81]             LD      H,A             ; Save combined signs
1A58: FC6D1A   [91|98]          CALL    M,DCBCDE        ; Negative - Decrement BCDE
1A5B: 3E98     [98]             LD      A,80H+24        ; 24 bits
1A5D: 90       [102]            SUB     B               ; Bits to shift
1A5E: CD2018   [119]            CALL    SCALE           ; Shift BCDE
1A61: 7C       [123]            LD      A,H             ; Get combined sign
1A62: 17       [127]            RLA                     ; Sign to carry
1A63: DCF317   [137|144]        CALL    C,FPROND        ; Negative - Round number up
1A66: 0600     [144]            LD      B,0             ; Zero exponent
1A68: DC0C18   [154|161]        CALL    C,COMPL         ; If negative make positive
1A6B: E1       [164]            POP     HL              ; Restore pointer to number
1A6C: C9       [174]            RET
                        
1A6D: 1B       [ 6]     DCBCDE: DEC     DE              ; Decrement BCDE
1A6E: 7A       [10]             LD      A,D             ; Test LSBs
1A6F: A3       [14]             AND     E
1A70: 3C       [18]             INC     A
1A71: C0       [23|29]          RET     NZ              ; Exit if LSBs not FFFF
1A72: 0B       [29]             DEC     BC              ; Decrement MSBs
1A73: C9       [39]             RET
                        
1A74: 212C21   [10]     INT:    LD      HL,FPEXP        ; Point to exponent
1A77: 7E       [17]             LD      A,(HL)          ; Get exponent
1A78: FE98     [24]             CP      80H+24          ; Integer accuracy only?
1A7A: 3A2921   [37]             LD      A,(FPREG)       ; Get LSB
1A7D: D0       [42|48]          RET     NC              ; Yes - Already integer
1A7E: 7E       [49]             LD      A,(HL)          ; Get exponent
1A7F: CD491A   [66]             CALL    FPINT           ; F.P to integer
1A82: 3698     [76]             LD      (HL),80H+24     ; Save 24 bit integer
1A84: 7B       [80]             LD      A,E             ; Get LSB of number
1A85: F5       [91]             PUSH    AF              ; Save LSB
1A86: 79       [95]             LD      A,C             ; Get MSB of number
1A87: 17       [99]             RLA                     ; Sign to carry
1A88: CDA917   [116]            CALL    CONPOS          ; Set sign of result
1A8B: F1       [126]            POP     AF              ; Restore LSB of number
1A8C: C9       [136]            RET
                        
1A8D: 210000   [10]     MLDEBC: LD      HL,0            ; Clear partial product
1A90: 78       [14]             LD      A,B             ; Test multiplier
1A91: B1       [18]             OR      C
1A92: C8       [23|29]          RET     Z               ; Return zero if zero
1A93: 3E10     [30]             LD      A,16            ; 16 bits
1A95: 29       [11]     MLDBLP: ADD     HL,HL           ; Shift P.P left
1A96: DACD12   [21|21]          JP      C,BSERR         ; ?BS Error if overflow
1A99: EB       [25]             EX      DE,HL
1A9A: 29       [36]             ADD     HL,HL           ; Shift multiplier left
1A9B: EB       [40]             EX      DE,HL
1A9C: D2A31A   [50|50]          JP      NC,NOMLAD       ; Bit was zero - No add
1A9F: 09       [61]             ADD     HL,BC           ; Add multiplicand
1AA0: DACD12   [71|71]          JP      C,BSERR         ; ?BS Error if overflow
1AA3: 3D       [ 4]     NOMLAD: DEC     A               ; Count bits
1AA4: C2951A   [14|14]          JP      NZ,MLDBLP       ; More
1AA7: C9       [24]             RET
                        
1AA8: FE2D     [ 7]     ASCTFP: CP      '-'             ; Negative?
1AAA: F5       [18]             PUSH    AF              ; Save it and flags
1AAB: CAB41A   [28|28]          JP      Z,CNVNUM        ; Yes - Convert number
1AAE: FE2B     [35]             CP      '+'             ; Positive?
1AB0: CAB41A   [45|45]          JP      Z,CNVNUM        ; Yes - Convert number
1AB3: 2B       [51]             DEC     HL              ; DEC 'cos GETCHR INCs
1AB4: CDC117   [17]     CNVNUM: CALL    RESZER          ; Set result to zero
1AB7: 47       [21]             LD      B,A             ; Digits after point counter
1AB8: 57       [25]             LD      D,A             ; Sign of exponent
1AB9: 5F       [29]             LD      E,A             ; Exponent of ten
1ABA: 2F       [33]             CPL
1ABB: 4F       [37]             LD      C,A             ; Before or after point flag
1ABC: CD4B0B   [17]     MANLP:  CALL    GETCHR          ; Get next character
1ABF: DA051B   [27|27]          JP      C,ADDIG         ; Digit - Add to number
1AC2: FE2E     [34]             CP      '.'
1AC4: CAE01A   [44|44]          JP      Z,DPOINT        ; '.' - Flag point
1AC7: FE45     [51]             CP      'E'
1AC9: C2E41A   [61|61]          JP      NZ,CONEXP       ; Not 'E' - Scale number
1ACC: CD4B0B   [78]             CALL    GETCHR          ; Get next character
1ACF: CDF810   [95]             CALL    SGNEXP          ; Get sign of exponent
1AD2: CD4B0B   [17]     EXPLP:  CALL    GETCHR          ; Get next character
1AD5: DA271B   [27|27]          JP      C,EDIGIT        ; Digit - Add to exponent
1AD8: 14       [31]             INC     D               ; Is sign negative?
1AD9: C2E41A   [41|41]          JP      NZ,CONEXP       ; No - Scale number
1ADC: AF       [45]             XOR     A
1ADD: 93       [49]             SUB     E               ; Negate exponent
1ADE: 5F       [53]             LD      E,A             ; And re-save it
1ADF: 0C       [57]             INC     C               ; Flag end of number
1AE0: 0C       [ 4]     DPOINT: INC     C               ; Flag point passed
1AE1: CABC1A   [14|14]          JP      Z,MANLP         ; Zero - Get another digit
1AE4: E5       [11]     CONEXP: PUSH    HL              ; Save code string address
1AE5: 7B       [15]             LD      A,E             ; Get exponent
1AE6: 90       [19]             SUB     B               ; Subtract digits after point
1AE7: F4FD1A   [10|17]  SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
1AEA: F2F31A   [20|20]          JP      P,ENDCON        ; Positive - All done
1AED: F5       [31]             PUSH    AF              ; Save number of times to /10
1AEE: CDE918   [48]             CALL    DIV10           ; Divide by 10
1AF1: F1       [58]             POP     AF              ; Restore count
1AF2: 3C       [62]             INC     A               ; Count divides
                        
1AF3: C2E71A   [10|10]  ENDCON: JP      NZ,SCALMI       ; More to do
1AF6: D1       [20]             POP     DE              ; Restore code string address
1AF7: F1       [30]             POP     AF              ; Restore sign of number
1AF8: CCCA19   [40|47]          CALL    Z,INVSGN        ; Negative - Negate number
1AFB: EB       [44]             EX      DE,HL           ; Code string address to HL
1AFC: C9       [54]             RET
                        
1AFD: C8       [ 5|11]  SCALPL: RET     Z               ; Exit if no scaling needed
1AFE: F5       [11]     MULTEN: PUSH    AF              ; Save count
1AFF: CD8A19   [28]             CALL    MLSP10          ; Multiply number by 10
1B02: F1       [38]             POP     AF              ; Restore count
1B03: 3D       [42]             DEC     A               ; Count multiplies
1B04: C9       [52]             RET
                        
1B05: D5       [11]     ADDIG:  PUSH    DE              ; Save sign of exponent
1B06: 57       [15]             LD      D,A             ; Save digit
1B07: 78       [19]             LD      A,B             ; Get digits after point
1B08: 89       [23]             ADC     A,C             ; Add one if after point
1B09: 47       [27]             LD      B,A             ; Re-save counter
1B0A: C5       [38]             PUSH    BC              ; Save point flags
1B0B: E5       [49]             PUSH    HL              ; Save code string address
1B0C: D5       [60]             PUSH    DE              ; Save digit
1B0D: CD8A19   [77]             CALL    MLSP10          ; Multiply number by 10
1B10: F1       [87]             POP     AF              ; Restore digit
1B11: D630     [94]             SUB     '0'             ; Make it absolute
1B13: CD1C1B   [111]            CALL    RSCALE          ; Re-scale number
1B16: E1       [121]            POP     HL              ; Restore code string address
1B17: C1       [131]            POP     BC              ; Restore point flags
1B18: D1       [141]            POP     DE              ; Restore sign of exponent
1B19: C3BC1A   [151]            JP      MANLP           ; Get another digit
                        
1B1C: CDD219   [17]     RSCALE: CALL    STAKFP          ; Put number on stack
1B1F: CDB319   [34]             CALL    FLGREL          ; Digit to add to FPREG
1B22: C1       [10]     PADD:   POP     BC              ; Restore number
1B23: D1       [20]             POP     DE
1B24: C35B17   [30]             JP      FPADD           ; Add BCDE to FPREG and return
                        
1B27: 7B       [ 4]     EDIGIT: LD      A,E             ; Get digit
1B28: 07       [ 8]             RLCA                    ; Times 2
1B29: 07       [12]             RLCA                    ; Times 4
1B2A: 83       [16]             ADD     A,E             ; Times 5
1B2B: 07       [20]             RLCA                    ; Times 10
1B2C: 86       [27]             ADD     A,(HL)          ; Add next digit
1B2D: D630     [34]             SUB     '0'             ; Make it absolute
1B2F: 5F       [38]             LD      E,A             ; Save new digit
1B30: C3D21A   [48]             JP      EXPLP           ; Look for another digit
                        
1B33: E5       [11]     LINEIN: PUSH    HL              ; Save code string address
1B34: 219206   [21]             LD      HL,INMSG        ; Output " in "
1B37: CD9814   [38]             CALL    PRS             ; Output string at HL
1B3A: E1       [48]             POP     HL              ; Restore code string address
1B3B: EB       [ 4]     PRNTHL: EX      DE,HL           ; Code string address to DE
1B3C: AF       [ 8]             XOR     A
1B3D: 0698     [15]             LD      B,80H+24        ; 24 bits
1B3F: CDB819   [32]             CALL    RETINT          ; Return the integer
1B42: 219714   [42]             LD      HL,PRNUMS       ; Print number string
1B45: E5       [53]             PUSH    HL              ; Save for return
1B46: 212E21   [10]     NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
1B49: E5       [21]             PUSH    HL              ; Save for return
1B4A: CDA119   [38]             CALL    TSTSGN          ; Test sign of FPREG
1B4D: 3620     [48]             LD      (HL),' '        ; Space at start
1B4F: F2541B   [58|58]          JP      P,SPCFST        ; Positive - Space to start
1B52: 362D     [68]             LD      (HL),'-'        ; '-' sign at start
1B54: 23       [ 6]     SPCFST: INC     HL              ; First byte of number
1B55: 3630     [16]             LD      (HL),'0'        ; '0' if zero
1B57: CA0A1C   [26|26]          JP      Z,JSTZER        ; Return '0' if zero
1B5A: E5       [37]             PUSH    HL              ; Save buffer address
1B5B: FCCA19   [47|54]          CALL    M,INVSGN        ; Negate FPREG if negative
1B5E: AF       [51]             XOR     A               ; Zero A
1B5F: F5       [62]             PUSH    AF              ; Save it
1B60: CD101C   [79]             CALL    RNGTST          ; Test number is in range
1B63: 014391   [10]     SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
1B66: 11F84F   [20]             LD      DE,4FF8H
1B69: CD1C1A   [37]             CALL    CMPNUM          ; Compare numbers
1B6C: B7       [41]             OR      A
1B6D: E2811B   [51|51]          JP      PO,INRNG        ; > 99999.9 - Sort it out
1B70: F1       [61]             POP     AF              ; Restore count
1B71: CDFE1A   [78]             CALL    MULTEN          ; Multiply by ten
1B74: F5       [89]             PUSH    AF              ; Re-save count
1B75: C3631B   [99]             JP      SIXDIG          ; Test it again
                        
1B78: CDE918   [17]     GTSIXD: CALL    DIV10           ; Divide by 10
1B7B: F1       [27]             POP     AF              ; Get count
1B7C: 3C       [31]             INC     A               ; Count divides
1B7D: F5       [42]             PUSH    AF              ; Re-save count
1B7E: CD101C   [59]             CALL    RNGTST          ; Test number is in range
1B81: CD4917   [17]     INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
1B84: 3C       [21]             INC     A
1B85: CD491A   [38]             CALL    FPINT           ; F.P to integer
1B88: CDE219   [55]             CALL    FPBCDE          ; Move BCDE to FPREG
1B8B: 010603   [65]             LD      BC,0306H        ; 1E+06 to 1E-03 range
1B8E: F1       [75]             POP     AF              ; Restore count
1B8F: 81       [79]             ADD     A,C             ; 6 digits before point
1B90: 3C       [83]             INC     A               ; Add one
1B91: FA9D1B   [93|93]          JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
1B94: FE08     [100]            CP      6+1+1           ; More than 999999 ?
1B96: D29D1B   [110|110]        JP      NC,MAKNUM       ; Yes - Do it in 'E' form
1B99: 3C       [114]            INC     A               ; Adjust for exponent
1B9A: 47       [118]            LD      B,A             ; Exponent of number
1B9B: 3E02     [125]            LD      A,2             ; Make it zero after
                        
1B9D: 3D       [ 4]     MAKNUM: DEC     A               ; Adjust for digits to do
1B9E: 3D       [ 8]             DEC     A
1B9F: E1       [18]             POP     HL              ; Restore buffer address
1BA0: F5       [29]             PUSH    AF              ; Save count
1BA1: 11231C   [39]             LD      DE,POWERS       ; Powers of ten
1BA4: 05       [43]             DEC     B               ; Count digits before point
1BA5: C2AE1B   [53|53]          JP      NZ,DIGTXT       ; Not zero - Do number
1BA8: 362E     [63]             LD      (HL),'.'        ; Save point
1BAA: 23       [69]             INC     HL              ; Move on
1BAB: 3630     [79]             LD      (HL),'0'        ; Save zero
1BAD: 23       [85]             INC     HL              ; Move on
1BAE: 05       [ 4]     DIGTXT: DEC     B               ; Count digits before point
1BAF: 362E     [14]             LD      (HL),'.'        ; Save point in case
1BB1: CCF719   [24|31]          CALL    Z,INCHL         ; Last digit - move on
1BB4: C5       [35]             PUSH    BC              ; Save digits before point
1BB5: E5       [46]             PUSH    HL              ; Save buffer address
1BB6: D5       [57]             PUSH    DE              ; Save powers of ten
1BB7: CDED19   [74]             CALL    BCDEFP          ; Move FPREG to BCDE
1BBA: E1       [84]             POP     HL              ; Powers of ten table
1BBB: 062F     [91]             LD      B, '0'-1        ; ASCII '0' - 1
1BBD: 04       [ 4]     TRYAGN: INC     B               ; Count subtractions
1BBE: 7B       [ 8]             LD      A,E             ; Get LSB
1BBF: 96       [15]             SUB     (HL)            ; Subtract LSB
1BC0: 5F       [19]             LD      E,A             ; Save LSB
1BC1: 23       [25]             INC     HL
1BC2: 7A       [29]             LD      A,D             ; Get NMSB
1BC3: 9E       [36]             SBC     A,(HL)          ; Subtract NMSB
1BC4: 57       [40]             LD      D,A             ; Save NMSB
1BC5: 23       [46]             INC     HL
1BC6: 79       [50]             LD      A,C             ; Get MSB
1BC7: 9E       [57]             SBC     A,(HL)          ; Subtract MSB
1BC8: 4F       [61]             LD      C,A             ; Save MSB
1BC9: 2B       [67]             DEC     HL              ; Point back to start
1BCA: 2B       [73]             DEC     HL
1BCB: D2BD1B   [83|83]          JP      NC,TRYAGN       ; No overflow - Try again
1BCE: CD0018   [100]            CALL    PLUCDE          ; Restore number
1BD1: 23       [106]            INC     HL              ; Start of next number
1BD2: CDE219   [123]            CALL    FPBCDE          ; Move BCDE to FPREG
1BD5: EB       [127]            EX      DE,HL           ; Save point in table
1BD6: E1       [137]            POP     HL              ; Restore buffer address
1BD7: 70       [144]            LD      (HL),B          ; Save digit in buffer
1BD8: 23       [150]            INC     HL              ; And move on
1BD9: C1       [160]            POP     BC              ; Restore digit count
1BDA: 0D       [164]            DEC     C               ; Count digits
1BDB: C2AE1B   [174|174]        JP      NZ,DIGTXT       ; More - Do them
1BDE: 05       [178]            DEC     B               ; Any decimal part?
1BDF: CAEE1B   [188|188]        JP      Z,DOEBIT        ; No - Do 'E' bit
1BE2: 2B       [ 6]     SUPTLZ: DEC     HL              ; Move back through buffer
1BE3: 7E       [13]             LD      A,(HL)          ; Get character
1BE4: FE30     [20]             CP      '0'             ; '0' character?
1BE6: CAE21B   [30|30]          JP      Z,SUPTLZ        ; Yes - Look back for more
1BE9: FE2E     [37]             CP      '.'             ; A decimal point?
1BEB: C4F719   [47|54]          CALL    NZ,INCHL        ; Move back over digit
                        
1BEE: F1       [10]     DOEBIT: POP     AF              ; Get 'E' flag
1BEF: CA0D1C   [20|20]          JP      Z,NOENED        ; No 'E' needed - End buffer
1BF2: 3645     [30]             LD      (HL),'E'        ; Put 'E' in buffer
1BF4: 23       [36]             INC     HL              ; And move on
1BF5: 362B     [46]             LD      (HL),'+'        ; Put '+' in buffer
1BF7: F2FE1B   [56|56]          JP      P,OUTEXP        ; Positive - Output exponent
1BFA: 362D     [66]             LD      (HL),'-'        ; Put '-' in buffer
1BFC: 2F       [70]             CPL                     ; Negate exponent
1BFD: 3C       [74]             INC     A
1BFE: 062F     [ 7]     OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
1C00: 04       [ 4]     EXPTEN: INC     B               ; Count subtractions
1C01: D60A     [11]             SUB     10              ; Tens digit
1C03: D2001C   [21|21]          JP      NC,EXPTEN       ; More to do
1C06: C63A     [28]             ADD     A,'0'+10        ; Restore and make ASCII
1C08: 23       [34]             INC     HL              ; Move on
1C09: 70       [41]             LD      (HL),B          ; Save MSB of exponent
1C0A: 23       [ 6]     JSTZER: INC     HL              ;
1C0B: 77       [13]             LD      (HL),A          ; Save LSB of exponent
1C0C: 23       [19]             INC     HL
1C0D: 71       [ 7]     NOENED: LD      (HL),C          ; Mark end of buffer
1C0E: E1       [17]             POP     HL              ; Restore code string address
1C0F: C9       [27]             RET
                        
1C10: 017494   [10]     RNGTST: LD      BC,9474H        ; BCDE = 999999.
1C13: 11F723   [20]             LD      DE,23F7H
1C16: CD1C1A   [37]             CALL    CMPNUM          ; Compare numbers
1C19: B7       [41]             OR      A
1C1A: E1       [51]             POP     HL              ; Return address to HL
1C1B: E2781B   [61|61]          JP      PO,GTSIXD       ; Too big - Divide by ten
1C1E: E9       [65]             JP      (HL)            ; Otherwise return to caller
                        
1C1F: 00000080          HALF:   .BYTE      00H,00H,00H,80H ; 0.5
                        
1C23: A08601            POWERS: .BYTE      0A0H,086H,001H  ; 100000
1C26: 102700                    .BYTE      010H,027H,000H  ;  10000
1C29: E80300                    .BYTE      0E8H,003H,000H  ;   1000
1C2C: 640000                    .BYTE      064H,000H,000H  ;    100
1C2F: 0A0000                    .BYTE      00AH,000H,000H  ;     10
1C32: 010000                    .BYTE      001H,000H,000H  ;      1
                        
1C35: 21CA19   [10]     NEGAFT: LD  HL,INVSGN           ; Negate result
1C38: E3       [29]             EX      (SP),HL         ; To be done after caller
1C39: E9       [33]             JP      (HL)            ; Return to caller
                        
1C3A: CDD219   [17]     SQR:    CALL    STAKFP          ; Put value on stack
1C3D: 211F1C   [27]             LD      HL,HALF         ; Set power to 1/2
1C40: CDDF19   [44]             CALL    PHLTFP          ; Move 1/2 to FPREG
                        
1C43: C1       [10]     POWER:  POP     BC              ; Get base
1C44: D1       [20]             POP     DE
1C45: CDA119   [37]             CALL    TSTSGN          ; Test sign of power
1C48: 78       [41]             LD      A,B             ; Get exponent of base
1C49: CA881C   [51|51]          JP      Z,EXP           ; Make result 1 if zero
1C4C: F2531C   [61|61]          JP      P,POWER1        ; Positive base - Ok
1C4F: B7       [65]             OR      A               ; Zero to negative power?
1C50: CAFD06   [75|75]          JP      Z,DZERR         ; Yes - ?/0 Error
1C53: B7       [ 4]     POWER1: OR      A               ; Base zero?
1C54: CAC217   [14|14]          JP      Z,SAVEXP        ; Yes - Return zero
1C57: D5       [25]             PUSH    DE              ; Save base
1C58: C5       [36]             PUSH    BC
1C59: 79       [40]             LD      A,C             ; Get MSB of base
1C5A: F67F     [47]             OR      01111111B       ; Get sign status
1C5C: CDED19   [64]             CALL    BCDEFP          ; Move power to BCDE
1C5F: F2701C   [74|74]          JP      P,POWER2        ; Positive base - Ok
1C62: D5       [85]             PUSH    DE              ; Save power
1C63: C5       [96]             PUSH    BC
1C64: CD741A   [113]            CALL    INT             ; Get integer of power
1C67: C1       [123]            POP     BC              ; Restore power
1C68: D1       [133]            POP     DE
1C69: F5       [144]            PUSH    AF              ; MSB of base
1C6A: CD1C1A   [161]            CALL    CMPNUM          ; Power an integer?
1C6D: E1       [171]            POP     HL              ; Restore MSB of base
1C6E: 7C       [175]            LD      A,H             ; but don't affect flags
1C6F: 1F       [179]            RRA                     ; Exponent odd or even?
1C70: E1       [10]     POWER2: POP     HL              ; Restore MSB and exponent
1C71: 222B21   [26]             LD      (FPREG+2),HL    ; Save base in FPREG
1C74: E1       [36]             POP     HL              ; LSBs of base
1C75: 222921   [52]             LD      (FPREG),HL      ; Save in FPREG
1C78: DC351C   [62|69]          CALL    C,NEGAFT        ; Odd power - Negate result
1C7B: CCCA19   [72|79]          CALL    Z,INVSGN        ; Negative base - Negate it
1C7E: D5       [83]             PUSH    DE              ; Save power
1C7F: C5       [94]             PUSH    BC
1C80: CD5518   [111]            CALL    LOG             ; Get LOG of base
1C83: C1       [121]            POP     BC              ; Restore power
1C84: D1       [131]            POP     DE
1C85: CD9618   [148]            CALL    FPMULT          ; Multiply LOG by power
                        
1C88: CDD219   [17]     EXP:    CALL    STAKFP          ; Put value on stack
1C8B: 013881   [27]             LD      BC,08138H       ; BCDE = 1/Ln(2)
1C8E: 113BAA   [37]             LD      DE,0AA3BH
1C91: CD9618   [54]             CALL    FPMULT          ; Multiply value by 1/LN(2)
1C94: 3A2C21   [67]             LD      A,(FPEXP)       ; Get exponent
1C97: FE88     [74]             CP      80H+8           ; Is it in range?
1C99: D27D19   [84|84]          JP      NC,OVTST1       ; No - Test for overflow
1C9C: CD741A   [101]            CALL    INT             ; Get INT of FPREG
1C9F: C680     [108]            ADD     A,80H           ; For excess 128
1CA1: C602     [115]            ADD     A,2             ; Exponent > 126?
1CA3: DA7D19   [125|125]        JP      C,OVTST1        ; Yes - Test for overflow
1CA6: F5       [136]            PUSH    AF              ; Save scaling factor
1CA7: 214418   [146]            LD      HL,UNITY        ; Point to 1.
1CAA: CD4C17   [163]            CALL    ADDPHL          ; Add 1 to FPREG
1CAD: CD8D18   [180]            CALL    MULLN2          ; Multiply by LN(2)
1CB0: F1       [190]            POP     AF              ; Restore scaling factor
1CB1: C1       [200]            POP     BC              ; Restore exponent
1CB2: D1       [210]            POP     DE
1CB3: F5       [221]            PUSH    AF              ; Save scaling factor
1CB4: CD5817   [238]            CALL    SUBCDE          ; Subtract exponent from FPREG
1CB7: CDCA19   [255]            CALL    INVSGN          ; Negate result
1CBA: 21C81C   [265]            LD      HL,EXPTAB       ; Coefficient table
1CBD: CDF81C   [282]            CALL    SMSER1          ; Sum the series
1CC0: 110000   [292]            LD      DE,0            ; Zero LSBs
1CC3: C1       [302]            POP     BC              ; Scaling factor
1CC4: 4A       [306]            LD      C,D             ; Zero MSB
1CC5: C39618   [316]            JP      FPMULT          ; Scale result to correct value
                        
1CC8: 08                EXPTAB: .BYTE      8                       ; Table used by EXP
1CC9: 402E9474                  .BYTE      040H,02EH,094H,074H     ; -1/7! (-1/5040)
1CCD: 704F2E77                  .BYTE      070H,04FH,02EH,077H     ;  1/6! ( 1/720)
1CD1: 6E02887A                  .BYTE      06EH,002H,088H,07AH     ; -1/5! (-1/120)
1CD5: E6A02A7C                  .BYTE      0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
1CD9: 50AAAA7E                  .BYTE      050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
1CDD: FFFF7F7F                  .BYTE      0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
1CE1: 00008081                  .BYTE      000H,000H,080H,081H     ; -1/1! (-1/1)
1CE5: 00000081                  .BYTE      000H,000H,000H,081H     ;  1/0! ( 1/1)
                        
1CE9: CDD219   [17]     SUMSER: CALL    STAKFP          ; Put FPREG on stack
1CEC: 119418   [27]             LD      DE,MULT         ; Multiply by "X"
1CEF: D5       [38]             PUSH    DE              ; To be done after
1CF0: E5       [49]             PUSH    HL              ; Save address of table
1CF1: CDED19   [66]             CALL    BCDEFP          ; Move FPREG to BCDE
1CF4: CD9618   [83]             CALL    FPMULT          ; Square the value
1CF7: E1       [93]             POP     HL              ; Restore address of table
1CF8: CDD219   [17]     SMSER1: CALL    STAKFP          ; Put value on stack
1CFB: 7E       [24]             LD      A,(HL)          ; Get number of coefficients
1CFC: 23       [30]             INC     HL              ; Point to start of table
1CFD: CDDF19   [47]             CALL    PHLTFP          ; Move coefficient to FPREG
1D00: 06                        .BYTE      06H             ; Skip "POP AF"
1D01: F1       [10]     SUMLP:  POP     AF              ; Restore count
1D02: C1       [20]             POP     BC              ; Restore number
1D03: D1       [30]             POP     DE
1D04: 3D       [34]             DEC     A               ; Cont coefficients
1D05: C8       [39|45]          RET     Z               ; All done
1D06: D5       [50]             PUSH    DE              ; Save number
1D07: C5       [61]             PUSH    BC
1D08: F5       [72]             PUSH    AF              ; Save count
1D09: E5       [83]             PUSH    HL              ; Save address in table
1D0A: CD9618   [100]            CALL    FPMULT          ; Multiply FPREG by BCDE
1D0D: E1       [110]            POP     HL              ; Restore address in table
1D0E: CDF019   [127]            CALL    LOADFP          ; Number at HL to BCDE
1D11: E5       [138]            PUSH    HL              ; Save address in table
1D12: CD5B17   [155]            CALL    FPADD           ; Add coefficient to FPREG
1D15: E1       [165]            POP     HL              ; Restore address in table
1D16: C3011D   [175]            JP      SUMLP           ; More coefficients
                        
1D19: CDA119   [17]     RND:    CALL    TSTSGN          ; Test sign of FPREG
1D1C: 215E20   [27]             LD      HL,SEED+2       ; Random number seed
1D1F: FA7A1D   [37|37]          JP      M,RESEED        ; Negative - Re-seed
1D22: 217F20   [47]             LD      HL,LSTRND       ; Last random number
1D25: CDDF19   [64]             CALL    PHLTFP          ; Move last RND to FPREG
1D28: 215E20   [74]             LD      HL,SEED+2       ; Random number seed
1D2B: C8       [79|85]          RET     Z               ; Return if RND(0)
1D2C: 86       [86]             ADD     A,(HL)          ; Add (SEED)+2)
1D2D: E607     [93]             AND     00000111B       ; 0 to 7
1D2F: 0600     [100]            LD      B,0
1D31: 77       [107]            LD      (HL),A          ; Re-save seed
1D32: 23       [113]            INC     HL              ; Move to coefficient table
1D33: 87       [117]            ADD     A,A             ; 4 bytes
1D34: 87       [121]            ADD     A,A             ; per entry
1D35: 4F       [125]            LD      C,A             ; BC = Offset into table
1D36: 09       [136]            ADD     HL,BC           ; Point to coefficient
1D37: CDF019   [153]            CALL    LOADFP          ; Coefficient to BCDE
1D3A: CD9618   [170]            CALL    FPMULT  ;       ; Multiply FPREG by coefficient
1D3D: 3A5D20   [183]            LD      A,(SEED+1)      ; Get (SEED+1)
1D40: 3C       [187]            INC     A               ; Add 1
1D41: E603     [194]            AND     00000011B       ; 0 to 3
1D43: 0600     [201]            LD      B,0
1D45: FE01     [208]            CP      1               ; Is it zero?
1D47: 88       [212]            ADC     A,B             ; Yes - Make it 1
1D48: 325D20   [225]            LD      (SEED+1),A      ; Re-save seed
1D4B: 217E1D   [235]            LD      HL,RNDTAB-4     ; Addition table
1D4E: 87       [239]            ADD     A,A             ; 4 bytes
1D4F: 87       [243]            ADD     A,A             ; per entry
1D50: 4F       [247]            LD      C,A             ; BC = Offset into table
1D51: 09       [258]            ADD     HL,BC           ; Point to value
1D52: CD4C17   [275]            CALL    ADDPHL          ; Add value to FPREG
1D55: CDED19   [17]     RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
1D58: 7B       [21]             LD      A,E             ; Get LSB
1D59: 59       [25]             LD      E,C             ; LSB = MSB
1D5A: EE4F     [32]             XOR     01001111B       ; Fiddle around
1D5C: 4F       [36]             LD      C,A             ; New MSB
1D5D: 3680     [46]             LD      (HL),80H        ; Set exponent
1D5F: 2B       [52]             DEC     HL              ; Point to MSB
1D60: 46       [59]             LD      B,(HL)          ; Get MSB
1D61: 3680     [69]             LD      (HL),80H        ; Make value -0.5
1D63: 215C20   [79]             LD      HL,SEED         ; Random number seed
1D66: 34       [90]             INC     (HL)            ; Count seed
1D67: 7E       [97]             LD      A,(HL)          ; Get seed
1D68: D6AB     [104]            SUB     171             ; Do it modulo 171
1D6A: C2711D   [114|114]        JP      NZ,RND2         ; Non-zero - Ok
1D6D: 77       [121]            LD      (HL),A          ; Zero seed
1D6E: 0C       [125]            INC     C               ; Fillde about
1D6F: 15       [129]            DEC     D               ; with the
1D70: 1C       [133]            INC     E               ; number
1D71: CDAC17   [17]     RND2:   CALL    BNORM           ; Normalise number
1D74: 217F20   [27]             LD      HL,LSTRND       ; Save random number
1D77: C3F919   [37]             JP      FPTHL           ; Move FPREG to last and return
                        
1D7A: 77       [ 7]     RESEED: LD      (HL),A          ; Re-seed random numbers
1D7B: 2B       [13]             DEC     HL
1D7C: 77       [20]             LD      (HL),A
1D7D: 2B       [26]             DEC     HL
1D7E: 77       [33]             LD      (HL),A
1D7F: C3551D   [43]             JP      RND1            ; Return RND seed
                        
1D82: 68B14668          RNDTAB: .BYTE   068H,0B1H,046H,068H     ; Table used by RND
1D86: 99E99269                  .BYTE   099H,0E9H,092H,069H
1D8A: 10D17568                  .BYTE   010H,0D1H,075H,068H
                        
1D8E: 21D81D   [10]     COS:    LD      HL,HALFPI       ; Point to PI/2
1D91: CD4C17   [27]             CALL    ADDPHL          ; Add it to PPREG
1D94: CDD219   [17]     SIN:    CALL    STAKFP          ; Put angle on stack
1D97: 014983   [27]             LD      BC,8349H        ; BCDE = 2 PI
1D9A: 11DB0F   [37]             LD      DE,0FDBH
1D9D: CDE219   [54]             CALL    FPBCDE          ; Move 2 PI to FPREG
1DA0: C1       [64]             POP     BC              ; Restore angle
1DA1: D1       [74]             POP     DE
1DA2: CDF718   [91]             CALL    DVBCDE          ; Divide angle by 2 PI
1DA5: CDD219   [108]            CALL    STAKFP          ; Put it on stack
1DA8: CD741A   [125]            CALL    INT             ; Get INT of result
1DAB: C1       [135]            POP     BC              ; Restore number
1DAC: D1       [145]            POP     DE
1DAD: CD5817   [162]            CALL    SUBCDE          ; Make it 0 <= value < 1
1DB0: 21DC1D   [172]            LD      HL,QUARTR       ; Point to 0.25
1DB3: CD5217   [189]            CALL    SUBPHL          ; Subtract value from 0.25
1DB6: CDA119   [206]            CALL    TSTSGN          ; Test sign of value
1DB9: 37       [210]            SCF                     ; Flag positive
1DBA: F2C41D   [220|220]        JP      P,SIN1          ; Positive - Ok
1DBD: CD4917   [237]            CALL    ROUND           ; Add 0.5 to value
1DC0: CDA119   [254]            CALL    TSTSGN          ; Test sign of value
1DC3: B7       [258]            OR      A               ; Flag negative
1DC4: F5       [11]     SIN1:   PUSH    AF              ; Save sign
1DC5: F4CA19   [21|28]          CALL    P,INVSGN        ; Negate value if positive
1DC8: 21DC1D   [31]             LD      HL,QUARTR       ; Point to 0.25
1DCB: CD4C17   [48]             CALL    ADDPHL          ; Add 0.25 to value
1DCE: F1       [58]             POP     AF              ; Restore sign
1DCF: D4CA19   [68|75]          CALL    NC,INVSGN       ; Negative - Make positive
1DD2: 21E01D   [78]             LD      HL,SINTAB       ; Coefficient table
1DD5: C3E91C   [88]             JP      SUMSER          ; Evaluate sum of series
                        
1DD8: DB0F4981          HALFPI: .BYTE   0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
                        
1DDC: 0000007F          QUARTR: .BYTE   000H,000H,000H,07FH     ; 0.25
                        
1DE0: 05                SINTAB: .BYTE   5                       ; Table used by SIN
1DE1: BAD71E86                  .BYTE   0BAH,0D7H,01EH,086H     ; 39.711
1DE5: 64269987                  .BYTE   064H,026H,099H,087H     ;-76.575
1DE9: 58342387                  .BYTE   058H,034H,023H,087H     ; 81.602
1DED: E05DA586                  .BYTE   0E0H,05DH,0A5H,086H     ;-41.342
1DF1: DA0F4983                  .BYTE   0DAH,00FH,049H,083H     ;  6.2832
                        
1DF5: CDD219   [17]     TAN:    CALL    STAKFP          ; Put angle on stack
1DF8: CD941D   [34]             CALL    SIN             ; Get SIN of angle
1DFB: C1       [44]             POP     BC              ; Restore angle
1DFC: E1       [54]             POP     HL
1DFD: CDD219   [71]             CALL    STAKFP          ; Save SIN of angle
1E00: EB       [75]             EX      DE,HL           ; BCDE = Angle
1E01: CDE219   [92]             CALL    FPBCDE          ; Angle to FPREG
1E04: CD8E1D   [109]            CALL    COS             ; Get COS of angle
1E07: C3F518   [119]            JP      DIV             ; TAN = SIN / COS
                        
1E0A: CDA119   [17]     ATN:    CALL    TSTSGN          ; Test sign of value
1E0D: FC351C   [27|34]          CALL    M,NEGAFT        ; Negate result after if -ve
1E10: FCCA19   [37|44]          CALL    M,INVSGN        ; Negate value if -ve
1E13: 3A2C21   [50]             LD      A,(FPEXP)       ; Get exponent
1E16: FE81     [57]             CP      81H             ; Number less than 1?
1E18: DA271E   [67|67]          JP      C,ATN1          ; Yes - Get arc tangnt
1E1B: 010081   [77]             LD      BC,8100H        ; BCDE = 1
1E1E: 51       [81]             LD      D,C
1E1F: 59       [85]             LD      E,C
1E20: CDF718   [102]            CALL    DVBCDE          ; Get reciprocal of number
1E23: 215217   [112]            LD      HL,SUBPHL       ; Sub angle from PI/2
1E26: E5       [123]            PUSH    HL              ; Save for angle > 1
1E27: 21311E   [10]     ATN1:   LD      HL,ATNTAB       ; Coefficient table
1E2A: CDE91C   [27]             CALL    SUMSER          ; Evaluate sum of series
1E2D: 21D81D   [37]             LD      HL,HALFPI       ; PI/2 - angle in case > 1
1E30: C9       [47]             RET                     ; Number > 1 - Sub from PI/2
                        
1E31: 09                ATNTAB: .BYTE   9                       ; Table used by ATN
1E32: 4AD73B78                  .BYTE   04AH,0D7H,03BH,078H     ; 1/17
1E36: 026E847B                  .BYTE   002H,06EH,084H,07BH     ;-1/15
1E3A: FEC12F7C                  .BYTE   0FEH,0C1H,02FH,07CH     ; 1/13
1E3E: 74319A7D                  .BYTE   074H,031H,09AH,07DH     ;-1/11
1E42: 843D5A7D                  .BYTE   084H,03DH,05AH,07DH     ; 1/9
1E46: C87F917E                  .BYTE   0C8H,07FH,091H,07EH     ;-1/7
1E4A: E4BB4C7E                  .BYTE   0E4H,0BBH,04CH,07EH     ; 1/5
1E4E: 6CAAAA7F                  .BYTE   06CH,0AAH,0AAH,07FH     ;-1/3
1E52: 00000081                  .BYTE   000H,000H,000H,081H     ; 1/1
                        
                        
1E56:                   GETINP:			        ; input a character
                        #local
1E56:                   waitRX:				; wait for an input character
1E56: DB22     [11]         in	    a, (PORT_SIOACTL)
1E58: CB47     [19]         bit	    SIORR0_IDX_RCA, a
1E5A: 28FA     [26|31]      jr	    z, waitRX
1E5C: DB20     [37]         in	    a, (PORT_SIOADAT)	; read input character
1E5E: C9       [47]         ret
                        #endlocal
                        
1E5F:                   CLS: 
1E5F: 3E0C     [ 7]             LD      A,CS            ; ASCII Clear screen
1E61: C3921F   [17]             JP      MONOUT          ; Output character
                        
1E64: CD2017   [17]     WIDTH:  CALL    GETINT          ; Get integer 0-255
1E67: 7B       [21]             LD      A,E             ; Width to A
1E68: 328720   [34]             LD      (LWIDTH),A      ; Set width
1E6B: C9       [44]             RET
                        
1E6C: CDBF0F   [17]     LINES:  CALL    GETNUM          ; Get a number
1E6F: CD040C   [34]             CALL    DEINT           ; Get integer -32768 to 32767
1E72: ED538B20 [54]             LD      (LINESC),DE     ; Set lines counter
1E76: ED538D20 [74]             LD      (LINESN),DE     ; Set lines number
1E7A: C9       [84]             RET
                        
1E7B: CD040C   [17]     DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
1E7E: D5       [28]             PUSH    DE              ; Save number
1E7F: E1       [38]             POP     HL              ; Number to HL
1E80: 46       [45]             LD      B,(HL)          ; Get LSB of contents
1E81: 23       [51]             INC     HL
1E82: 7E       [58]             LD      A,(HL)          ; Get MSB of contents
1E83: C37A13   [68]             JP      ABPASS          ; Return integer AB
                        
1E86: CDBF0F   [17]     DOKE:   CALL    GETNUM          ; Get a number
1E89: CD040C   [34]             CALL    DEINT           ; Get integer -32768 to 32767
1E8C: D5       [45]             PUSH    DE              ; Save address
1E8D: CDC109   [62]             CALL    CHKSYN          ; Make sure ',' follows
1E90: 2C                        .BYTE      ','
1E91: CDBF0F   [79]             CALL    GETNUM          ; Get a number
1E94: CD040C   [96]             CALL    DEINT           ; Get integer -32768 to 32767
1E97: E3       [115]            EX      (SP),HL         ; Save value,get address
1E98: 73       [122]            LD      (HL),E          ; Save LSB of value
1E99: 23       [128]            INC     HL
1E9A: 72       [135]            LD      (HL),D          ; Save MSB of value
1E9B: E1       [145]            POP     HL              ; Restore code string address
1E9C: C9       [155]            RET
                        
                        
                        ; HEX$(nn) Convert 16 bit number to Hexadecimal string
                        
1E9D: CDC20F   [17]     HEX: 	CALL	TSTNUM          ; Verify it's a number
1EA0: CD040C   [34]             CALL	DEINT           ; Get integer -32768 to 32767
1EA3: C5       [45]             PUSH	BC              ; Save contents of BC
1EA4: 212E21   [55]             LD	    HL,PBUFF
1EA7: 7A       [59]             LD	    A,D             ; Get high order into A
1EA8: FE00     [66]             CP      $0
1EAA: 280C     [73|78]  		JR      Z,HEX2          ; Skip output if both high digits are zero
1EAC: CDD51E   [90]             CALL    BYT2ASC         ; Convert D to ASCII
1EAF: 78       [94]     		LD      A,B
1EB0: FE30     [101]    		CP      '0'
1EB2: 2802     [108|113]		JR      Z,HEX1          ; Don't store high digit if zero
1EB4: 70       [115]            LD	    (HL),B          ; Store it to PBUFF
1EB5: 23       [121]            INC	    HL              ; Next location
1EB6: 71       [ 7]     HEX1:   LD	    (HL),C          ; Store C to PBUFF+1
1EB7: 23       [13]             INC     HL              ; Next location
1EB8: 7B       [ 4]     HEX2:   LD	    A,E             ; Get lower byte
1EB9: CDD51E   [21]             CALL    BYT2ASC         ; Convert E to ASCII
1EBC: 7A       [25]     		LD      A,D
1EBD: FE00     [32]             CP      $0
1EBF: 2005     [39|44]  		JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
1EC1: 78       [43]     		LD      A,B
1EC2: FE30     [50]     		CP      '0'             ; If high digit of lower byte is zero then don't print
1EC4: 2802     [57|62]  		JR      Z,HEX4
1EC6: 70       [ 7]     HEX3:   LD      (HL),B          ; to PBUFF+2
1EC7: 23       [13]             INC     HL              ; Next location
1EC8: 71       [ 7]     HEX4:   LD      (HL),C          ; to PBUFF+3
1EC9: 23       [13]             INC     HL              ; PBUFF+4 to zero
1ECA: AF       [17]             XOR     A               ; Terminating character
1ECB: 77       [24]             LD      (HL),A          ; Store zero to terminate
1ECC: 23       [30]             INC     HL              ; Make sure PBUFF is terminated
1ECD: 77       [37]             LD      (HL),A          ; Store the double zero there
1ECE: C1       [47]             POP     BC              ; Get BC back
1ECF: 212E21   [57]             LD      HL,PBUFF        ; Reset to start of PBUFF
1ED2: C32814   [67]             JP      STR1            ; Convert the PBUFF to a string and return it
                        
1ED5: 47       [ 4]     BYT2ASC	LD      B,A             ; Save original value
1ED6: E60F     [11]             AND     $0F             ; Strip off upper nybble
1ED8: FE0A     [18]             CP      $0A             ; 0-9?
1EDA: 3802     [25|30]          JR      C,ADD30         ; If A-F, add 7 more
1EDC: C607     [32]             ADD     A,$07           ; Bring value up to ASCII A-F
1EDE: C630     [ 7]     ADD30	ADD     A,$30           ; And make ASCII
1EE0: 4F       [11]             LD      C,A             ; Save converted char to C
1EE1: 78       [15]             LD      A,B             ; Retrieve original value
1EE2: 0F       [19]             RRCA                    ; and Rotate it right
1EE3: 0F       [23]             RRCA
1EE4: 0F       [27]             RRCA
1EE5: 0F       [31]             RRCA
1EE6: E60F     [38]             AND     $0F             ; Mask off upper nybble
1EE8: FE0A     [45]             CP      $0A             ; 0-9? < A hex?
1EEA: 3802     [52|57]          JR      C,ADD301        ; Skip Add 7
1EEC: C607     [59]             ADD     A,$07           ; Bring it up to ASCII A-F
1EEE: C630     [ 7]     ADD301	ADD     A,$30           ; And make it full ASCII
1EF0: 47       [11]             LD      B,A             ; Store high order byte
1EF1: C9       [21]             RET	
                        
                        ; Convert "&Hnnnn" to FPREG
                        ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
                        ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
1EF2: EB       [ 4]     HEXTFP  EX      DE,HL           ; Move code string pointer to DE
1EF3: 210000   [14]             LD      HL,$0000        ; Zero out the value
1EF6: CD0B1F   [31]             CALL    GETHEX          ; Check the number for valid hex
1EF9: DA2B1F   [41|41]          JP      C,HXERR         ; First value wasn't hex, HX error
1EFC: 1805     [53]             JR      HEXLP1          ; Convert first character
1EFE: CD0B1F   [17]     HEXLP   CALL    GETHEX          ; Get second and addtional characters
1F01: 381F     [24|29]          JR      C,HEXIT         ; Exit if not a hex character
1F03: 29       [11]     HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
1F04: 29       [22]             ADD     HL,HL
1F05: 29       [33]             ADD     HL,HL
1F06: 29       [44]             ADD     HL,HL
1F07: B5       [48]             OR      L               ; Add in D0-D3 into L
1F08: 6F       [52]             LD      L,A             ; Save new value
1F09: 18F3     [64]             JR      HEXLP           ; And continue until all hex characters are in
                        
1F0B: 13       [ 6]     GETHEX  INC     DE              ; Next location
1F0C: 1A       [13]             LD      A,(DE)          ; Load character at pointer
1F0D: FE20     [20]             CP      ' '
1F0F: CA0B1F   [30|30]          JP      Z,GETHEX        ; Skip spaces
1F12: D630     [37]             SUB     $30             ; Get absolute value
1F14: D8       [42|48]          RET     C               ; < "0", error
1F15: FE0A     [49]             CP      $0A
1F17: 3805     [56|61]          JR      C,NOSUB7        ; Is already in the range 0-9
1F19: D607     [63]             SUB     $07             ; Reduce to A-F
1F1B: FE0A     [70]             CP      $0A             ; Value should be $0A-$0F at this point
1F1D: D8       [75|81]          RET     C               ; CY set if was :            ; < = > ? @
1F1E: FE10     [ 7]     NOSUB7  CP      $10             ; > Greater than "F"?
1F20: 3F       [11]             CCF
1F21: C9       [21]             RET                     ; CY set if it wasn't valid hex
                            
1F22: EB       [ 4]     HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
1F23: 7A       [ 8]             LD      A,D             ; Load DE into AC
1F24: 4B       [12]             LD      C,E             ; For prep to 
1F25: E5       [23]             PUSH    HL
1F26: CD7913   [40]             CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
1F29: E1       [50]             POP     HL
1F2A: C9       [60]             RET
                        
1F2B: 1E26     [ 7]     HXERR:  LD      E,HX            ; ?HEX Error
1F2D: C30E07   [17]             JP      ERROR
                        
                        ; BIN$(NN) Convert integer to a 1-16 char binary string
1F30: CDC20F   [17]     BIN:    CALL    TSTNUM          ; Verify it's a number
1F33: CD040C   [34]             CALL    DEINT           ; Get integer -32768 to 32767
1F36: C5       [11]     BIN2:   PUSH    BC              ; Save contents of BC
1F37: 212E21   [21]             LD      HL,PBUFF
1F3A: 0611     [28]             LD      B,17            ; One higher than max char count
1F3C:                   ZEROSUP:                        ; Suppress leading zeros
1F3C: 05       [ 4]             DEC     B               ; Max 16 chars
1F3D: 78       [ 8]             LD      A,B
1F3E: FE01     [15]             CP      $01
1F40: 2808     [22|27]          JR      Z,BITOUT        ; Always output at least one character
1F42: CB13     [30]             RL      E
1F44: CB12     [38]             RL      D
1F46: 30F4     [45|50]          JR      NC,ZEROSUP
1F48: 1804     [57]             JR      BITOUT2
1F4A:                   BITOUT:      
1F4A: CB13     [ 8]             RL      E
1F4C: CB12     [16]             RL      D               ; Top bit now in carry
1F4E:                   BITOUT2:
1F4E: 3E30     [ 7]             LD      A,'0'           ; Char for '0'
1F50: CE00     [14]             ADC     A,0             ; If carry set then '0' --> '1'
1F52: 77       [21]             LD      (HL),A
1F53: 23       [27]             INC     HL
1F54: 05       [31]             DEC     B
1F55: 20F3     [38|43]          JR      NZ,BITOUT
1F57: AF       [42]             XOR     A               ; Terminating character
1F58: 77       [49]             LD      (HL),A          ; Store zero to terminate
1F59: 23       [55]             INC     HL              ; Make sure PBUFF is terminated
1F5A: 77       [62]             LD      (HL),A          ; Store the double zero there
1F5B: C1       [72]             POP     BC
1F5C: 212E21   [82]             LD      HL,PBUFF
1F5F: C32814   [92]             JP      STR1
                        
                        ; Convert "&Bnnnn" to FPREG
                        ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
1F62: EB       [ 4]     BINTFP: EX      DE,HL           ; Move code string pointer to DE
1F63: 210000   [14]             LD      HL,$0000        ; Zero out the value
1F66: CD7F1F   [31]             CALL    CHKBIN          ; Check the number for valid bin
1F69: DA8D1F   [41|41]          JP      C,BINERR        ; First value wasn't bin, HX error
1F6C: D630     [ 7]     BINIT:  SUB     '0'
1F6E: 29       [18]             ADD     HL,HL           ; Rotate HL left
1F6F: B5       [22]             OR      L
1F70: 6F       [26]             LD      L,A
1F71: CD7F1F   [43]             CALL    CHKBIN          ; Get second and addtional characters
1F74: 30F6     [50|55]          JR      NC,BINIT        ; Process if a bin character
1F76: EB       [54]             EX      DE,HL           ; Value into DE, Code string into HL
1F77: 7A       [58]             LD      A,D             ; Load DE into AC
1F78: 4B       [62]             LD      C,E             ; For prep to 
1F79: E5       [73]             PUSH    HL
1F7A: CD7913   [90]             CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
1F7D: E1       [100]            POP     HL
1F7E: C9       [110]            RET
                        
                        ; Char is in A, NC if char is 0 or 1
1F7F: 13       [ 6]     CHKBIN: INC     DE
1F80: 1A       [13]             LD      A,(DE)
1F81: FE20     [20]             CP      ' '
1F83: CA7F1F   [30|30]          JP      Z,CHKBIN        ; Skip spaces
1F86: FE30     [37]             CP      '0'             ; Set C if < '0'
1F88: D8       [42|48]          RET     C
1F89: FE32     [49]             CP      '2'
1F8B: 3F       [53]             CCF                     ; Set C if > '1'
1F8C: C9       [63]             RET
                        
1F8D: 1E28     [ 7]     BINERR: LD      E,BN            ; ?BIN Error
1F8F: C30E07   [17]             JP      ERROR
                        
1F92:                   MONOUT:				; output a char
                        #local
1F92: F5       [11]         push    af
1F93:                   waitTX:
                            ; wait until transmitter is idle
1F93: DB22     [11]         in	    a, (PORT_SIOACTL)
1F95: CB57     [19]         bit	    SIORR0_IDX_TBE, a
1F97: 28FA     [26|31]      jr	    z, waitTX
1F99: F1       [36]         pop	    af
                            ; write output character
1F9A: D320     [47]         out	    (PORT_SIOADAT), a	; send byte out serial port
1F9C: C9       [57]         ret
                        #endlocal
                        
1F9D:                   MONITR: 
1F9D: C7       [11]             RST	$00		; Restart (Normally Monitor Start)
                        
                        
                        ; Remaining 56KB and 64KB segments to fill up ROM image
0000:                   #code FILLER1, 0, 0xE000
0000:                   #code FILLER2, 0, 0x10000


total time: 0.0373 sec.
no errors
