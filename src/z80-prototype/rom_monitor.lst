                        ; --------------------------------------
                        ; zasm: assemble "rom_monitor.asm"
                        ; date: 2019-10-01 13:08:24
                        ; --------------------------------------


                        ; Calling convention used in this program
                        ; ---------------------------------------
                        ;
                        ; Unless otherwise noted, the first parameter, and the return value are stored as follows:
                        ; 8 bits: L
                        ; 16 bits: HL
                        ; 32 bits: DEHL
                        ;
                        ; Additional parameters are passed on the stack, left-to-right.
                        ; Parameters and return values larger than 32 bits are passed on the stack (return value
                        ; space set up by caller as a hidden first argument).
                        ; Callee saves/restores any modified registers.
                        ; Caller pops arguments after call returns.
                        ; AF registers are scratch (caller preserves, if needed).
                        
                        ; same as 'bin', except that the default fill byte for 'defs' etc. is 0xff
                        #target rom
                        
                        #include "z80.inc"
                        ; Macros and definitions related to the Z80 and its instruction set
                        
                        M_deref_hl	macro
                            ; hl = (hl)
                            ; destroys a
                            ld	    a, (hl)
                            inc	    hl
                            ld	    h, (hl)
                            ld	    l, a
                            endm
                        #include "7segdisp.inc"
0000:                   PORT_SEG0	equ 0x00	    ; port address for first 7-segment display element
0010:                   PORT_SEG1	equ 0x10	    ; port address for second 7-segment display element
                        
                        ; 7-segment display map
                        ;      A
                        ;  +-------+
                        ;  |       |
                        ; F|       |B
                        ;  |   G   |
                        ;  +-------+
                        ;  |       |
                        ; E|       |C
                        ;  |   D   |
                        ;  +-------+  .DP
                        
                        ; These values are the bit masks.
0001:                   SEG_A		equ 0x01	; segment A
0002:                   SEG_B		equ 0x02	; segment B
0004:                   SEG_C		equ 0x04	; segment C
0008:                   SEG_D		equ 0x08	; segment D
0010:                   SEG_E		equ 0x10	; segment E
0020:                   SEG_F		equ 0x20	; segment F
0040:                   SEG_G		equ 0x40	; segment G
0080:                   SEG_DP		equ 0x80	; decimal point
                        
                        ; These are the bit numbers (useful for bit, set, and res instructions).
0000:                   SEG_IDX_A	equ 0
0001:                   SEG_IDX_B	equ 1
0002:                   SEG_IDX_C	equ 2
0003:                   SEG_IDX_D	equ 3
0004:                   SEG_IDX_E	equ 4
0005:                   SEG_IDX_F	equ 5
0006:                   SEG_IDX_G	equ 6
0007:                   SEG_IDX_DP	equ 7
                        #include "joystick.inc"
0000:                   PORT_JOY0	equ 0x00	    ; port address for first joystick (read-only)
0010:                   PORT_JOY1	equ 0x10	    ; port address for second joystick (read-only)
                        
                        ; Bit masks for the values in the joystick status register.
                        ; These bits are active-low (normally high).
0001:                   JOY_UP		equ 0x01
0002:                   JOY_DOWN	equ 0x02
0004:                   JOY_LEFT	equ 0x04
0008:                   JOY_RIGHT	equ 0x08
0010:                   JOY_FIRE	equ 0x10
0020:                   JOY_RESERVED1	equ 0x20
0040:                   JOY_RESERVED2	equ 0x40
0080:                   JOY_RESERVED3	equ 0x80
                        
                        ; The bit numbers (useful for bit, set, and res instructions).
0000:                   JOY_IDX_UP	equ 0
0001:                   JOY_IDX_DOWN	equ 1
0002:                   JOY_IDX_LEFT	equ 2
0003:                   JOY_IDX_RIGHT	equ 3
0004:                   JOY_IDX_FIRE	equ 4
                        #include "z84c20.inc"
                        ; The Z84C20 is the Z80's PIO peripheral. See um0081.pdf for documentation.
                        
0030:                   PORT_PIOBASE	equ 0x30		; base port address for PIO chip
0030:                   PORT_PIOADAT	equ PORT_PIOBASE	; port address for PIO port A, data register
0031:                   PORT_PIOBDAT	equ PORT_PIOBASE + 1    ; port address for PIO port B, data register
0032:                   PORT_PIOACTL	equ PORT_PIOBASE + 2    ; port address for PIO port A, control register
0033:                   PORT_PIOBCTL	equ PORT_PIOBASE + 3    ; port address for PIO port B, control register
                        
                        ; PIO Control Register commands
0000:                   PIOC_IVEC	equ 0x00	; OR in the high 7 bits of the interrupt vector
000F:                   PIOC_MODE	equ 0x0F	; OR in the desired PIOMODE_xxx setting
0007:                   PIOC_ICTL	equ 0x07	; OR in the desired PIOICTL_xxx settings
                        
                        ; PIOC_MODE values
0000:                   PIOMODE_OUTPUT	equ 0x00
0040:                   PIOMODE_INPUT	equ 0x40
0080:                   PIOMODE_BIDIREC	equ 0x80
00C0:                   PIOMODE_CONTROL	equ 0xC0	; next control byte written must be the IO direction byte
                        				; 1 = input, 0 = output
                        
                        ; PIOC_ICTL values
0080:                   PIOICTL_INTENA	equ 0x80	; enable interrupts
0000:                   PIOICTL_INTDIS	equ 0x00	; disable interrupts
0040:                   PIOICTL_AND	equ 0x40	; AND inputs together for port monitoring interrupt
0000:                   PIOICTL_OR	equ 0x00	; OR inputs together for port monitoring interrupt
0020:                   PIOICTL_HIGH	equ 0x20	; interrupt on high (1) inputs
0000:                   PIOICTL_LOW	equ 0x00	; interrupt on low (0) inputs
0010:                   PIOICTL_MASKNXT equ 0x10	; next control byte written must be the input interrupt mask
                        				; 1 = input masked, 0 = input enabled
                        
                        M_pio_reset	macro
                            ld	    a, PIOC_MODE | PIOMODE_INPUT
                            out	    (PORT_PIOACTL), a
                            out	    (PORT_PIOBCTL), a
                            ld	    a, PIOC_ICTL | PIOICTL_INTDIS
                            out	    (PORT_PIOACTL), a
                            out	    (PORT_PIOBCTL), a
                            endm
                        #include "z84c30.inc"
                        ; The Z84C30 is the Z80's CTC peripheral. See um0081.pdf for documentation.
                        
0040:                   PORT_CTCBASE	equ 0x40		; base port address for CTC chip
0040:                   PORT_CTCIVEC	equ PORT_CTCBASE	; port address for Interrupt Vector Register
0040:                   PORT_CTC0	equ PORT_CTCBASE	; port address for CTC channel 0
0041:                   PORT_CTC1	equ PORT_CTCBASE + 1	; port address for CTC channel 1
0042:                   PORT_CTC2	equ PORT_CTCBASE + 2	; port address for CTC channel 2
0043:                   PORT_CTC3	equ PORT_CTCBASE + 3	; port address for CTC channel 3
                        
                        ; CTC Channel Control Word bits
0080:                   CTC_INTENA	equ 0x80		; enable interrupts
0000:                   CTC_INTDIS	equ 0x00		; disable interrupts
0040:                   CTC_MODECTR	equ 0x40		; COUNTER mode
0000:                   CTC_MODETMR	equ 0x00		; TIMER mode
0020:                   CTC_SCALE256	equ 0x20		; prescale by 256
0000:                   CTC_SCALE16	equ 0x00		; prescale by 16
0010:                   CTC_RISING	equ 0x10		; CLK/TRG on rising edges
0000:                   CTC_FALLING	equ 0x00		; CLK/TRG on falling edges
0008:                   CTC_CLKTRG	equ 0x08		; CLK/TRG pulse starts timer
0000:                   CTC_AUTO	equ 0x00		; automatic timer start after loading time constant
0004:                   CTC_TIMENXT	equ 0x04		; next control byte written is the time constant
0002:                   CTC_RESET	equ 0x02		; software reset
0001:                   CTC_CONTROL	equ 0x01		; always set to indicate this is a control word, not IVEC 
                        
                        M_ctc_reset	macro
                            ld	    a, CTC_CONTROL | CTC_RESET | CTC_INTDIS
                            out	    (PORT_CTC0), a
                            out	    (PORT_CTC1), a
                            out	    (PORT_CTC2), a
                            out	    (PORT_CTC3), a
                            endm
                        #include "z84c40.inc"
                        ; The Z84C40 is the Z80's SIO peripheral. See um0081.pdf for documentation.
                        
0020:                   PORT_SIOBASE	    equ 0x20		    ; base port address for SIO chip
0020:                   PORT_SIOADAT	    equ PORT_SIOBASE	    ; port address for SIO port A, data register
0021:                   PORT_SIOBDAT	    equ PORT_SIOBASE + 1    ; port address for SIO port B, data register
0022:                   PORT_SIOACTL	    equ PORT_SIOBASE + 2    ; port address for SIO port A, control register
0023:                   PORT_SIOBCTL	    equ PORT_SIOBASE + 3    ; port address for SIO port B, control register
                        
                        ; WR0 "CRC Reset Code" values (bits 7-6)
0000:                   SIOWR0_CRC_NOP		equ 0x00	    ; no CRC reset code
0040:                   SIOWR0_CRC_RST_RX_CHK	equ 1 << 6	    ; reset RX CRC checker
0080:                   SIOWR0_CRC_RST_TX_GEN	equ 2 << 6	    ; reset TX CRC generator
00C0:                   SIOWR0_CRC_RST_TX_UNDR  equ 3 << 6	    ; reset TX underrun/EOM latch
                        
                        ; WR0 "Command" values (bits 5-3)
0000:                   SIOWR0_CMD_NOP		equ 0x00	    ; no command
0008:                   SIOWR0_CMD_SND_ABRT	equ 1 << 3	    ; send abort (SDLC only)
0010:                   SIOWR0_CMD_RST_EXTINT	equ 2 << 3	    ; reset external/status interrupts
0018:                   SIOWR0_CMD_RST_CHAN	equ 3 << 3	    ; reset channel
0020:                   SIOWR0_CMD_INTENA_NXTRX	equ 4 << 3	    ; enable interrupt on next receive character
0028:                   SIOWR0_CMD_RST_TXINTPND equ 5 << 3	    ; reset TX interrupt pending
0030:                   SIOWR0_CMD_RST_ERR	equ 6 << 3	    ; reset error latches
0038:                   SIOWR0_CMD_INTRETN	equ 7 << 3	    ; return from interrupt (not needed with Z80)
                        
                        ; WR0 "Pointer" values (bits 2-0)
0000:                   SIOWR0_PTR_R0		equ 0x00	    ; set pointer to register 0
0001:                   SIOWR0_PTR_R1		equ 0x01	    ; set pointer to register 1
0002:                   SIOWR0_PTR_R2		equ 0x02	    ; set pointer to register 2
0003:                   SIOWR0_PTR_R3		equ 0x03	    ; set pointer to register 3
0004:                   SIOWR0_PTR_R4		equ 0x04	    ; set pointer to register 4
0005:                   SIOWR0_PTR_R5		equ 0x05	    ; set pointer to register 5
0006:                   SIOWR0_PTR_R6		equ 0x06	    ; set pointer to register 6
0007:                   SIOWR0_PTR_R7		equ 0x07	    ; set pointer to register 7
                        
                        ; WR1 interrupt & wait/ready control bits
0001:                   SIOWR1_EXTINTENA	equ 0x01	    ; external/status interrupt enable
0002:                   SIOWR1_TXINTENA		equ 0x02	    ; TX interrupt enable
0004:                   SIOWR1_STATIVEC		equ 0x04	    ; status affects interrupt vector (set in ch. B only)
0000:                   SIOWR1_RXINT_DISABLE	equ 0 << 3	    ; RX interrupts disabled
0008:                   SIOWR1_RXINT_FIRST	equ 1 << 3	    ; RX interrupt on first character
0010:                   SIOWR1_RXINT_ALLPRTY	equ 2 << 3	    ; RX interrupt on all characters, parity err is SR cond
0018:                   SIOWR1_RXINT_ALLNPRTY	equ 3 << 3	    ; RX interrupt on all characters, parity err no intr
                        ; bits 7-5 are for WAIT/READY functions, which we don't use (always write as 0)
                        
                        ; WR2 is the interrupt vector register (set in channel B only)
                        
                        ; WR3 receiver logic control bits
0001:                   SIOWR3_RXENA		equ 0x01	    ; receiver enable
0002:                   SIOWR3_SYNC_INHIBIT	equ 0x02	    ; sync character load inhibit
0004:                   SIOWR3_ADDR_SRCHMODE	equ 0x04	    ; address search mode
0008:                   SIOWR3_RXCRCENA		equ 0x08	    ; receiver CRC enable
0010:                   SIOWR3_ENTER_HUNT	equ 0x10	    ; enter hunt phase
0020:                   SIOWR3_AUTO_ENABLES	equ 0x20	    ; auto enables (DCD/CTS are RX/TX enables)
0000:                   SIOWR3_RX_5_BITS	equ 0 << 6	    ; receive 5 bits/character
0040:                   SIOWR3_RX_7_BITS	equ 1 << 6	    ; receive 7 bits/character
0080:                   SIOWR3_RX_6_BITS	equ 2 << 6	    ; receive 6 bits/character
00C0:                   SIOWR3_RX_8_BITS	equ 3 << 6	    ; receive 8 bits/character
                        
                        ; WR4 RX/TX configuration (set first before WR1, WR3, WR5, WR6, and WR7)
0001:                   SIOWR4_PARITY		equ 0x01	    ; parity on/off
0002:                   SIOWR4_PRTY_EVEN	equ 0x02	    ; even parity
0000:                   SIOWR4_PRTY_ODD		equ 0x00	    ; odd parity
0000:                   SIOWR4_TXSTOP_SYNC	equ 0 << 2	    ; synchronous mode (no TX stop bits)
0004:                   SIOWR4_TXSTOP_1		equ 1 << 2	    ; 1 TX stop bit
0008:                   SIOWR4_TXSTOP_1_5	equ 2 << 2	    ; 1.5 TX stop bits
000C:                   SIOWR4_TXSTOP_2		equ 3 << 2	    ; 2 TX stop bits
                        ; bits 5-4 set the sync modes, which we don't use (always write as 0)
0000:                   SIOWR4_CLK_x1		equ 0 << 6	    ; data rate x1 = clock rate
0040:                   SIOWR4_CLK_x16		equ 1 << 6	    ; data rate x16 = clock rate
0080:                   SIOWR4_CLK_x32		equ 2 << 6	    ; data rate x32 = clock rate
00C0:                   SIOWR4_CLK_x64		equ 3 << 6	    ; data rate x64 = clock rate
                        
                        ; WR5 transmitter logic control bits
0001:                   SIOWR5_TXCRCENA		equ 0x01	    ; transmitter CRC enable
0002:                   SIOWR5_RTS		equ 0x02	    ; request to send
0004:                   SIOWR5_CRC16_SDLC	equ 0x04	    ; CRC-16 vs. SDLC polynomial
0008:                   SIOWR5_TXENA		equ 0x08	    ; transmitter enable
0010:                   SIOWR5_SND_BRK		equ 0x10	    ; send break
0000:                   SIOWR5_TX_5_BITS	equ 0 << 5	    ; transmit 5 bits/character
0020:                   SIOWR5_TX_7_BITS	equ 1 << 5	    ; transmit 7 bits/character
0040:                   SIOWR5_TX_6_BITS	equ 2 << 5	    ; transmit 6 bits/character
0060:                   SIOWR5_TX_8_BITS	equ 3 << 5	    ; transmit 8 bits/character
0080:                   SIOWR5_DTR		equ 0x80	    ; data terminal ready
                        
                        ; WR6 transmitter sync register for use in synchronous modes, which we don't use
                        ; WR7 receiver sync register for use in synchronous modes, which we don't use
                        
                        ; RR0 status bits (mostly normal operation)
0001:                   SIORR0_RCA		equ 0x01	    ; RX character available
0002:                   SIORR0_INTPND		equ 0x02	    ; interrupt pending (channel A only)
0004:                   SIORR0_TBE		equ 0x04	    ; TX buffer empty
0008:                   SIORR0_DCD		equ 0x08	    ; latched DCD input bit
0010:                   SIORR0_SYNC		equ 0x10	    ; latched SYNC input bit (hunt in SDLC)
0020:                   SIORR0_CTS		equ 0x20	    ; latched CTS input bit
0040:                   SIORR0_TX_UNDR		equ 0x40	    ; TX underrun / end of message
0080:                   SIORR0_BRK_ABRT		equ 0x80	    ; break/abort detected
                        ; As bit numbers, useful for the "bit" instruction, to test individual bit flags
0000:                   SIORR0_IDX_RCA		equ 0
0001:                   SIORR0_IDX_INTPND	equ 1
0002:                   SIORR0_IDX_TBE		equ 2
0003:                   SIORR0_IDX_DCD		equ 3
0004:                   SIORR0_IDX_SYNC		equ 4
0005:                   SIORR0_IDX_CTS		equ 5
0006:                   SIORR0_IDX_TX_UNDR	equ 6
0007:                   SIORR0_IDX_BRK_ABRT	equ 7
                        
                        ; RR1 status bits (mostly errors)
0001:                   SIORR1_ALLSENT		equ 0x01	    ; all characters fully sent
                        ; bits 3-1 are SDLC-only
0010:                   SIORR1_PRTYERR		equ 0x10	    ; parity error
0020:                   SIORR1_ROE		equ 0x20	    ; RX overrun error
0040:                   SIORR1_CRCFRMERR	equ 0x40	    ; CRC/framing error
                        ; bit 7 is SDLC-only
                        
                        ; RR2 is the interrupt vector register (read from channel B only)
                        ; - if "Status Affects Vector" bit is set, this will be the current vector value,
                        ;   modified by whatever interrupt conditions are pending
                        
                        M_sio_reset	macro
                            ld	    a, SIOWR0_CMD_RST_CHAN
                            out	    (PORT_SIOACTL), a
                            out	    (PORT_SIOBCTL), a
                            endm
                        #include "ascii.inc"
0000:                   NUL	equ 0x00
0001:                   SOH	equ 0x01
0004:                   EOT	equ 0x04
0006:                   ACK	equ 0x06
0007:                   BEL	equ 0x07
0008:                   BS	equ 0x08
0009:                   HT	equ 0x09
000A:                   LF	equ 0x0A
000D:                   CR	equ 0x0D
0015:                   NAK	equ 0x15
001B:                   ESC	equ 0x1B
                        
                        ; some macros that we have to declare before use
                        M_sio_puts  macro str
                            ; Careful: destroys HL
                            ld	    hl, &str
                            call    sio_puts
                            endm
                        
                        M_sio_putc  macro ch
                            ; Careful: destroys L
                            ld	    l, &ch
                            call    sio_putc
                            endm
                        
                        ; 128KB Static RAM - AS6C1008-55PCN
                        ; The first 8KB is shadowed by the EPROM.
                        ; The next 56KB is mapped from 0x2000-0xFFFF.
                        ; The top 64KB is not addressable (A16 tied low).
                        
                        ; We map our RAM area high so that our data fields don't clobber low memory where we're
                        ; likely to be loading programs.
FC00:                   #data RAM, 0xFC00, 0x400
                        ; define static variables here
FC00: 00                Seg0_data:: defs 1	; current value of first 7-segment display byte
FC01: 00                Seg1_data:: defs 1	; current value of second 7-segment display byte
                        
                        ; 128KB Flash ROM - SST39SF010A
                        ; The first 8KB is mapped from 0-0x1FFF.
0000:                   #code ROM, 0, 0x2000
                        
                        ; reset vector
0000:                   RST0::
0000: F3       [ 4]         di
0001: 31FFFF   [14]         ld	    sp, RAM_end-1
0004: C3A100   [24]         jp	    init
0007: FF                    defs    0x08-$
                        
0008:                   RST1::
0008: ED4D     [14]         reti
000A: FFFFFFFF              defs    0x10-$
000E: FFFF              
                        
0010:                   RST2::
0010: ED4D     [14]         reti
0012: FFFFFFFF              defs    0x18-$
0016: FFFF              
                        
0018:                   RST3::
0018: ED4D     [14]         reti
001A: FFFFFFFF              defs    0x20-$
001E: FFFF              
                        
0020:                   RST4::
0020: ED4D     [14]         reti
0022: FFFFFFFF              defs    0x28-$
0026: FFFF              
                        
0028:                   RST5::
0028: ED4D     [14]         reti
002A: FFFFFFFF              defs    0x30-$
002E: FFFF              
                        
0030:                   RST6::
0030: ED4D     [14]         reti
0032: FFFFFFFF              defs    0x38-$
0036: FFFF              
                        
                        ; maskable interrupt handler in interrupt mode 1:
0038:                   RST7::
0038: ED4D     [14]         reti
                        
                        ; non maskable interrupt:
                        ; e.g. call debugger and on exit resume.
003A: FFFFFFFF              defs    0x66-$
003E: FF...             
0066:                   NMI::
0066: ED45     [14]         retn
                        
                        ; Empty ISR for interrupts we want to ignore
0068:                   ISR_nop::
0068: FB       [ 4]         ei
0069: ED4D     [18]         reti
                        
006B: FFFFFFFF              defs    0x80-$
006F: FF...             
                        ; Interrupt Vector Table
0080:                   IVT::
                        ; Table starts at 0x0080
                        ; CTC has first 4 slots, so CTC Interrupt Vector register should be 0x80
0080: 6800                  .word   ISR_nop	    ; CTC channel 0
0082: 6800                  .word   ISR_nop	    ; CTC channel 1
0084: 6800                  .word   ISR_nop	    ; CTC channel 2
0086: 0601                  .word   ISR_ctc3	    ; CTC channel 3
                        ; TODO: ISRs for PIO & SIO
                        
0088:                   startup_msg::
0088: 0D0A5A38              .text   CR, LF, "Z80MON v2 ", __date__
008C: 304D4F4E          
0090: 20763220          
0094: 32303139          
0098: 2D31302D          
009C: 3031              
                            ; Falling through...
009E:                   crlf::
009E: 0D0A00                .text   CR, LF, NUL
                        
                        ; void init()
00A1:                   init::
                            ; reset peripherals
                            M_pio_reset
00A1: 3E4F     [ 7]         ld	    a, PIOC_MODE | PIOMODE_INPUT
00A3: D332     [18]         out	    (PORT_PIOACTL), a
00A5: D333     [29]         out	    (PORT_PIOBCTL), a
00A7: 3E07     [36]         ld	    a, PIOC_ICTL | PIOICTL_INTDIS
00A9: D332     [47]         out	    (PORT_PIOACTL), a
00AB: D333     [58]         out	    (PORT_PIOBCTL), a
                            M_sio_reset
00AD: 3E18     [65]         ld	    a, SIOWR0_CMD_RST_CHAN
00AF: D322     [76]         out	    (PORT_SIOACTL), a
00B1: D323     [87]         out	    (PORT_SIOBCTL), a
                            M_ctc_reset
00B3: 3E03     [94]         ld	    a, CTC_CONTROL | CTC_RESET | CTC_INTDIS
00B5: D340     [105]        out	    (PORT_CTC0), a
00B7: D341     [116]        out	    (PORT_CTC1), a
00B9: D342     [127]        out	    (PORT_CTC2), a
00BB: D343     [138]        out	    (PORT_CTC3), a
                            ; set up interrupts
00BD: 3E00     [145]        ld	    a, hi(IVT)
00BF: ED47     [154]        ld	    i, a	    ; I gets high byte of IVT address
00C1: ED5E     [162]        im	    2		    ; select interrupt mode 2
00C3: FB       [166]        ei
                            ; clear 7-segment display
00C4: CD2704   [183]        call    seg_init
                            ; initialize peripherals
00C7: CDD800   [200]        call    ctc_init	    ; need to set up CTC to get SIO working (need baud rate gen)
00CA: CD1201   [217]        call    sio_init
                            ; print startup banner
                            M_sio_puts startup_msg
                            ; Careful: destroys HL
00CD: 218800   [227]        ld	    hl, startup_msg
00D0: CDF803   [244]        call    sio_puts
00D3: CD2E01   [261]        call    cmd_loop
00D6: 18FE     [273]        jr	    $		    ; loop forever
                        
                        ; void ctc_init()
                        #local
00D8:                   ctc_init::
                            ; load CTC Interrupt Vector Register
00D8: 3E80     [ 7]         ld	    a, lo(IVT)	    ; CTC interrupt vectors are the first 4 in the IVT
00DA: D340     [18]         out	    (PORT_CTCIVEC), a
                            ; channel 0 is the baud rate generator for serial 0
00DC: 3E57     [25]         ld	    a, CTC_CONTROL | CTC_RESET | CTC_TIMENXT | CTC_RISING | CTC_MODECTR
00DE: D340     [36]         out	    (PORT_CTC0), a
00E0: 3E03     [43]         ld	    a, 3	    ; 1.8432MHz divided by 3 is 614.4kHz (SIO at x16 gives 38400 baud)
00E2: D340     [54]         out	    (PORT_CTC0), a
                            ; channel 1 is the baud rate generator for serial 1
00E4: 3E57     [61]         ld	    a, CTC_CONTROL | CTC_RESET | CTC_TIMENXT | CTC_RISING | CTC_MODECTR
00E6: D341     [72]         out	    (PORT_CTC1), a
00E8: 3E03     [79]         ld	    a, 3	    ; 1.8432MHz divided by 3 is 614.4kHz (SIO at x16 gives 38400 baud)
00EA: D341     [90]         out	    (PORT_CTC1), a
00EC: CDF500   [107]        call    ctc_tick_on
00EF: C9       [117]        ret
                        #endlocal
                        
                        ; void ctc_tick_off()
00F0:                   ctc_tick_off::
00F0: 3E01     [ 7]         ld	    a, CTC_CONTROL | CTC_INTDIS
00F2: D343     [18]         out	    (PORT_CTC3), a
00F4: C9       [28]         ret
                        
                        ; void ctc_tick_on()
00F5:                   ctc_tick_on::
                            ; channel 2 is used as a timer to divide down the system clock for channel 3
00F5: 3E17     [ 7]         ld	    a, CTC_CONTROL | CTC_RESET | CTC_TIMENXT | CTC_AUTO | CTC_RISING | CTC_SCALE16 | CTC_MODETMR
00F7: D342     [18]         out	    (PORT_CTC2), a
00F9: 3EFA     [25]         ld	    a, 250	    ; 10MHz prescale by 16, divide by 250 is 2.5kHz
00FB: D342     [36]         out	    (PORT_CTC2), a
                            ; channel 3 is used as a counter on the 2.5kHz signal from channel 2
00FD: 3ED7     [43]         ld	    a, CTC_CONTROL | CTC_RESET | CTC_TIMENXT | CTC_RISING | CTC_MODECTR | CTC_INTENA
00FF: D343     [54]         out	    (PORT_CTC3), a
0101: 3EFA     [61]         ld	    a, 250	    ; 2.5kHz divided by 250 is 10Hz
0103: D343     [72]         out	    (PORT_CTC3), a
0105: C9       [82]         ret
                        
                        ; CTC channel 3 ISR
                        ; - do not to modify ix or iy, or call any routine that does, as they aren't saved/restored!
0106:                   ISR_ctc3::
0106: 08       [ 4]         ex	    af, af'
0107: D9       [ 8]         exx
0108: 2E80     [15]         ld	    l, SEG_DP
010A: CD8604   [32]         call    seg1_toggle
010D: D9       [36]         exx
010E: 08       [40]         ex	    af, af'
010F: FB       [44]         ei
0110: ED4D     [58]         reti
                        
                        ; void sio_init()
                        #local
0112:                   sio_init::
0112: E5       [11]         push    hl
0113: C5       [22]         push    bc
                            ; configure SIO port A
0114: 012207   [32]         ld	    bc, 0x0700 | PORT_SIOACTL
0117: 212701   [42]         ld	    hl, sioA_cfg
011A: EDB3     [58|21]      otir
                            ; configure SIO port B
011C: 012307   [68]         ld	    bc, 0x0700 | PORT_SIOBCTL
011F: 212701   [78]         ld	    hl, sioB_cfg
0122: EDB3     [94|21]      otir
0124: C1       [104]        pop	    bc
0125: E1       [114]        pop	    hl
0126: C9       [124]        ret
0127:                   sioA_cfg:
0127:                   sioB_cfg:
0127: 18                    .byte SIOWR0_CMD_RST_CHAN
0128: 04                    .byte SIOWR0_PTR_R4
0129: 44                    .byte SIOWR4_TXSTOP_1 | SIOWR4_CLK_x16
                            ; No need to set up WR1/WR2, as they are only used for interrupts
012A: 03                    .byte SIOWR0_PTR_R3
012B: C1                    .byte SIOWR3_RXENA | SIOWR3_RX_8_BITS
012C: 05                    .byte SIOWR0_PTR_R5
012D: EA                    .byte SIOWR5_RTS | SIOWR5_TXENA | SIOWR5_TX_8_BITS | SIOWR5_DTR
                            ; No need to set up WR6/WR7, as they are only used for synchronous modes
                        #endlocal
                        
                        ; void cmd_loop()
                        #local
012E:                   cmd_loop::
012E: E5       [11]         push    hl
012F: C5       [22]         push    bc
0130:                   prompt:
                            M_sio_putc '>'
                            ; Careful: destroys L
0130: 2E3E     [ 7]         ld	    l, '>'
0132: CDEE03   [24]         call    sio_putc
0135:                   nextByte:
0135: CD0003   [17]         call    sio_getc
                            ; map input byte to upper case
0138: CDB202   [34]         call    toupper
                            ; switch on input byte, and dispatch to appropriate subroutine
013B: 7D       [38]         ld	    a, l
013C: 215B01   [48]         ld	    hl, cmd_chars
013F: 010800   [58]         ld	    bc, num_cmds
0142: EDB1     [74|21]      cpir
0144: 20EF     [81|86]      jr	    nz, nextByte
0146: 216301   [91]         ld	    hl, cmd_procs
                            ; add 2 * (num_cmds - 1 - c) to hl
0149: 3E07     [98]         ld	    a, num_cmds-1
014B: 91       [102]        sub	    c
014C: 87       [106]        add	    a
014D: 4F       [110]        ld	    c, a
014E: 09       [121]        add	    hl, bc
                            M_deref_hl
                            ; hl = (hl)
                            ; destroys a
014F: 7E       [128]        ld	    a, (hl)
0150: 23       [134]        inc	    hl
0151: 66       [141]        ld	    h, (hl)
0152: 6F       [145]        ld	    l, a
                            ; call hl
0153: CDAF02   [162]        call    jp_hl
0156: 18D8     [174]        jr	    prompt
0158: C1       [184]        pop	    bc
0159: E1       [194]        pop	    hl
015A: C9       [204]        ret
                        
015B:                   cmd_chars:
015B: 01425743              .byte SOH,'B','W','C','R','I','O',CR
015F: 52494F0D          
0008:                   num_cmds	equ $-cmd_chars
0163:                   cmd_procs:
0163: 7301                  .word cmd_do_packet
0165: 0602                  .word cmd_do_disp_bytes
0167: 0902                  .word cmd_do_disp_words
0169: 0C02                  .word cmd_do_call
016B: 4102                  .word cmd_do_reset
016D: 4C02                  .word cmd_do_input
016F: 7102                  .word cmd_do_output
0171: 9E02                  .word cmd_do_cr
                        #endlocal
                        
                        #local
0173:                   cmd_do_packet::
0173: E5       [11]         push    hl
0174: C5       [22]         push    bc
0175: D5       [33]         push    de
                            ; get packet type
0176: CD0003   [50]         call    sio_getc
0179: 7D       [54]         ld	    a, l
017A: FE57     [61]         cp	    'W'
017C: 2811     [68|73]      jr	    z, doWrite
017E: FE43     [75]         cp	    'C'
0180: 284E     [82|87]      jr	    z, doCall
                            ; unrecognized packet type!
                            ; might be nice to consume everything up to EOT, but how long should we wait?
0182:                   failure:
0182: 2E4E     [ 7]         ld	    l, 'N'
0184: 1802     [19]         jr	    putcAndDone
0186:                   success:
0186: 2E41     [ 7]         ld	    l, 'A'
0188:                   putcAndDone:
0188: CDEE03   [17]         call    sio_putc
018B:                   done:
018B: D1       [10]         pop	    de
018C: C1       [20]         pop	    bc
018D: E1       [30]         pop	    hl
018E: C9       [40]         ret
                        
018F:                   doWrite:
                            ; Write packet consists of:
                            ;	'W'
                            ;	2-byte address
                            ;	2-byte length
                            ;	data bytes
                            ;	checksum byte
                            ;	EOT
                            ; place address in de and ix
018F: CD0003   [17]         call    sio_getc
0192: 5D       [21]         ld	    e, l
0193: CD0003   [38]         call    sio_getc
0196: 55       [42]         ld	    d, l
0197: D5       [53]         push    de
0198: DDE1     [67]         pop	    ix
                            ; place length in bc
019A: CD0003   [84]         call    sio_getc
019D: 4D       [88]         ld	    c, l
019E: CD0003   [105]        call    sio_getc
01A1: 45       [109]        ld	    b, l
                            ; get a checksum started
01A2: 3E57     [116]        ld	    a, 'W'
01A4: 83       [120]        add	    e
01A5: 82       [124]        add	    d
01A6: 81       [128]        add	    c
01A7: 80       [132]        add	    b
                            ; keep running checksum in d
01A8: 57       [136]        ld	    d, a
                            ; read data bytes
01A9:                   writeLoop:
                            ; test bc against 0
01A9: AF       [ 4]         xor	    a		    ; resets carry flag, sets a=0
01AA: 67       [ 8]         ld	    h, a
01AB: 6F       [12]         ld	    l, a	    ; set hl=0
01AC: ED42     [27]         sbc	    hl, bc	    ; test bc against 0
01AE: 280E     [34|39]      jr	    z, writeDataDone
01B0: 0B       [40]         dec	    bc
01B1: CD0003   [57]         call    sio_getc	    ; l = next byte
01B4: DD7500   [76]         ld	    (ix), l
01B7: DD23     [86]         inc	    ix
                            ; checksum data byte
01B9: 7A       [90]         ld	    a, d
01BA: 85       [94]         add	    l
01BB: 57       [98]         ld	    d, a
01BC: 18EB     [110]        jr	    writeLoop
01BE:                   writeDataDone:
01BE: CD0003   [17]         call    sio_getc	    ; l = incoming checksum
01C1: 5D       [21]         ld	    e, l
01C2: CD0003   [38]         call    sio_getc	    ; expecting an EOT
01C5: 7D       [42]         ld	    a, l
01C6: FE04     [49]         cp	    EOT
01C8: 20B8     [56|61]      jr	    nz, failure
                            ; validate checksum
01CA: 7A       [60]         ld	    a, d
01CB: BB       [64]         cp	    e
01CC: 28B8     [71|76]      jr	    z, success
01CE: 18B2     [83]         jr	    failure
                        
01D0:                   doCall:
                            ; Call packet consists of:
                            ;	'C'
                            ;	2-byte address
                            ;	checksum byte
                            ;	EOT
                            ; place address in bc
01D0: CD0003   [17]         call    sio_getc
01D3: 4D       [21]         ld	    c, l
01D4: CD0003   [38]         call    sio_getc
01D7: 45       [42]         ld	    b, l
01D8: CD0003   [59]         call    sio_getc	    ; l = incoming checksum
01DB: 5D       [63]         ld	    e, l
01DC: CD0003   [80]         call    sio_getc	    ; expecting an EOT
01DF: 7D       [84]         ld	    a, l
01E0: FE04     [91]         cp	    EOT
01E2: 209E     [98|103]     jr	    nz, failure
                            ; calculate checksum
01E4: 3E43     [105]        ld	    a, 'C'
01E6: 81       [109]        add	    c
01E7: 80       [113]        add	    b
                            ; validate checksum
01E8: BB       [117]        cp	    e
01E9: 2097     [124|129]    jr	    nz, failure
                            M_sio_putc 'A'
                            ; Careful: destroys L
01EB: 2E41     [131]        ld	    l, 'A'
01ED: CDEE03   [148]        call    sio_putc
                            ; af is scratch & we already save/restore bc, de, hl
                            ; save/restore ix, iy too
01F0: DDE5     [163]        push    ix
01F2: FDE5     [178]        push    iy
01F4: CDF000   [195]        call    ctc_tick_off
                            ; call bc
01F7: CDB002   [212]        call    jp_bc
01FA: CD2704   [229]        call    seg_init
01FD: CDF500   [246]        call    ctc_tick_on
0200: FDE1     [260]        pop	    iy
0202: DDE1     [274]        pop	    ix
0204: 1885     [286]        jr	    done
                        #endlocal
                        
0206:                   cmd_do_disp_bytes::
0206: E5       [11]         push    hl
                            ; TODO: NYI
0207: E1       [21]         pop	    hl
0208: C9       [31]         ret
                        
0209:                   cmd_do_disp_words::
0209: E5       [11]         push    hl
                            ; TODO: NYI
020A: E1       [21]         pop	    hl
020B: C9       [31]         ret
                        
                        #local
020C:                   cmd_do_call::
020C: E5       [11]         push    hl
020D: D5       [22]         push    de
020E: C5       [33]         push    bc
                            M_sio_puts prompt_str
                            ; Careful: destroys HL
020F: 213E02   [43]         ld	    hl, prompt_str
0212: CDF803   [60]         call    sio_puts
0215: CD5D03   [77]         call    sio_gethex16
0218: 281A     [84|89]      jr	    z, done
                            ; call address is in HL
                            ; AF is scratch & we already save/restore BC, DE, HL
                            ; save/restore IX, IY too
021A: DDE5     [99]         push    ix
021C: FDE5     [114]        push    iy
021E: CDF000   [131]        call    ctc_tick_off
0221: CDAF02   [148]        call    jp_hl	; call HL
0224: CD2704   [165]        call    seg_init
0227: CDF500   [182]        call    ctc_tick_on
022A: FDE1     [196]        pop	    iy
022C: DDE1     [210]        pop	    ix
                            M_sio_puts cmd_ok_str
                            ; Careful: destroys HL
022E: 21AA02   [220]        ld	    hl, cmd_ok_str
0231: CDF803   [237]        call    sio_puts
0234:                   done:
                            M_sio_puts crlf
                            ; Careful: destroys HL
0234: 219E00   [10]         ld	    hl, crlf
0237: CDF803   [27]         call    sio_puts
023A: C1       [37]         pop	    bc
023B: D1       [47]         pop	    de
023C: E1       [57]         pop	    hl
023D: C9       [67]         ret
                        
023E:                   prompt_str:
023E: 432400                .asciz  "C$"
                        #endlocal
                        
0241:                   cmd_do_reset::
0241: E5       [11]         push    hl
                            M_sio_putc 'R'
                            ; Careful: destroys L
0242: 2E52     [18]         ld	    l, 'R'
0244: CDEE03   [35]         call    sio_putc
0247: CDA604   [52]         call    delay_1ms
024A: F3       [56]         di
024B: C7       [67]         rst	    0x00	; reset
                        
                        #local
024C:                   cmd_do_input::
024C: E5       [11]         push    hl
024D: C5       [22]         push    bc
                            M_sio_puts prompt_str
                            ; Careful: destroys HL
024E: 216E02   [32]         ld	    hl, prompt_str
0251: CDF803   [49]         call    sio_puts
0254: CD0A03   [66]         call    sio_gethex8
0257: 280C     [73|78]      jr	    z, done
                            ; I/O address is in l
0259: 4D       [77]         ld	    c, l
                            M_sio_puts cmd_equals_str
                            ; Careful: destroys HL
025A: 21A702   [87]         ld	    hl, cmd_equals_str
025D: CDF803   [104]        call    sio_puts
0260: ED68     [116]        in	    l, (c)
0262: CD0E04   [133]        call    sio_puthex8
0265:                   done:
                            M_sio_puts crlf
                            ; Careful: destroys HL
0265: 219E00   [10]         ld	    hl, crlf
0268: CDF803   [27]         call    sio_puts
026B: C1       [37]         pop	    bc
026C: E1       [47]         pop	    hl
026D: C9       [57]         ret
                        
026E:                   prompt_str:
026E: 492400                .asciz  "I$"
                        #endlocal
                        
                        #local
0271:                   cmd_do_output::
0271: E5       [11]         push    hl
0272: C5       [22]         push    bc
                            M_sio_puts prompt_str
                            ; Careful: destroys HL
0273: 219B02   [32]         ld	    hl, prompt_str
0276: CDF803   [49]         call    sio_puts
0279: CD0A03   [66]         call    sio_gethex8
027C: 2814     [73|78]      jr	    z, done
                            ; I/O address is in l -- stash it in c
027E: 4D       [77]         ld	    c, l
                            M_sio_puts cmd_equals_str
                            ; Careful: destroys HL
027F: 21A702   [87]         ld	    hl, cmd_equals_str
0282: CDF803   [104]        call    sio_puts
0285: CD0A03   [121]        call    sio_gethex8
0288: 2808     [128|133]    jr	    z, done
                            ; output value is in l
028A: ED69     [140]        out	    (c), l
                            M_sio_puts cmd_ok_str
                            ; Careful: destroys HL
028C: 21AA02   [150]        ld	    hl, cmd_ok_str
028F: CDF803   [167]        call    sio_puts
0292:                   done:
                            M_sio_puts crlf
                            ; Careful: destroys HL
0292: 219E00   [10]         ld	    hl, crlf
0295: CDF803   [27]         call    sio_puts
0298: C1       [37]         pop	    bc
0299: E1       [47]         pop	    hl
029A: C9       [57]         ret
                        
029B:                   prompt_str:
029B: 4F2400                .asciz  "O$"
                        #endlocal
                        
029E:                   cmd_do_cr::
029E: E5       [11]         push    hl
                            M_sio_puts crlf
                            ; Careful: destroys HL
029F: 219E00   [21]         ld	    hl, crlf
02A2: CDF803   [38]         call    sio_puts
02A5: E1       [48]         pop	    hl
02A6: C9       [58]         ret
                        
02A7:                   cmd_equals_str::
02A7: 3D2400                .asciz  "=$"
02AA:                   cmd_ok_str::
02AA: 0D0A4F4B              .text   CR, LF, "OK", NUL
02AE: 00                
                        
                        ; Library routines
                        ; ----------------
                        
                        ; Call jp_hl to make a call to the address in hl. What actually happens is the call to jp_hl loads
                        ; the return address on the stack, then control transfers to jp_hl, which jumps to the address
                        ; in hl, thus giving the effect of "call hl", which isn't a Z80 instruction.
02AF:                   jp_hl::
02AF: E9       [ 4]         jp	    hl
                        
                        ; Call jp_bc to make a call to the address in bc. What actually happens is the call to jp_bc loads
                        ; the return address on the stack, then control transfers to jp_bc, which jumps to the address
                        ; in bc, thus giving the effect of "call bc", which isn't a Z80 instruction.
02B0:                   jp_bc::
02B0: C5       [11]         push    bc
02B1: C9       [21]         ret
                        
                        ; uint8_t toupper(uint8_t ch)
                        ; - map character "ch" to upper-case, if it is a lower-case letter
                        #local
02B2:                   toupper::
02B2: 7D       [ 4]         ld	    a, l
02B3: FE61     [11]         cp	    'a'
02B5: D8       [16|22]      ret	    c
02B6: FE7B     [23]         cp	    'z'+1
02B8: D0       [28|34]      ret	    nc
02B9: E6DF     [35]         and	    ~0x20
02BB: 6F       [39]         ld	    l, a
02BC: C9       [49]         ret
                        #endlocal
                        
                        ; Z_flag isxdigit(uint8_t ch)
                        ; - set Z flag iff "ch" is a digit 0-9 or A-F
                        #local
02BD:                   isxdigit::
02BD: 7D       [ 4]         ld	    a, l
02BE: FE30     [11]         cp	    '0'
02C0: 380C     [18|23]      jr	    c, no
02C2: FE3A     [25]         cp	    '9'+1
02C4: 380B     [32|37]      jr	    c, yes
02C6: FE41     [39]         cp	    'A'
02C8: 3804     [46|51]      jr	    c, no
02CA: FE47     [53]         cp	    'F'+1
02CC: 3803     [60|65]      jr	    c, yes
                            ; otherwise, no
02CE:                   no:
02CE: FE30     [ 7]         cp	    '0'		; reset Z flag (a != '0', so Z is reset)
02D0: C9       [17]         ret
02D1:                   yes:
02D1: AF       [ 4]         xor	    a		; set Z flag
02D2: C9       [14]         ret
                        #endlocal
                        
                        ; uint8_t hex2bin(uint8_t ch)
                        ; - converts the single hex digit "ch" (must be 0-9 or A-F) into a binary value between 0-15
                        ; - pass "ch" in A
                        ; - returns value in low nybble of A
                        #local
02D3:                   hex2bin::
02D3: FE41     [ 7]         cp	    'A'
02D5: 3003     [14|19]      jr	    nc, hex
02D7: D630     [21]         sub	    '0'
02D9: C9       [31]         ret
02DA:                   hex:
02DA: D637     [ 7]         sub	    'A'-10
02DC: C9       [17]         ret
                        #endlocal
                        
                        ; uint16_t hex2bin2(uint8_t high, uint8_t low)
                        ; - converts the two hex digits "high" and "low" (must be 0-9 or A-F) into an unsigned 8-bit value
                        ; - pass "high" in H, and "low" in L
                        ; - returns result in L
                        #local
02DD:                   hex2bin2::
02DD: E5       [11]         push    hl		; preserve H
02DE: 7C       [15]         ld	    a, h
02DF: CDD302   [32]         call    hex2bin
02E2: 67       [36]         ld	    h, a	; convert digit in H to nybble in H
02E3: 7D       [40]         ld	    a, l
02E4: CDD302   [57]         call    hex2bin
02E7: 6F       [61]         ld	    l, a	; convert digit in L to nybble in L
                            ; compute A = (H << 4) | L
02E8: 7C       [65]         ld	    a, h
02E9: 87       [69]         add	    a
02EA: 87       [73]         add	    a
02EB: 87       [77]         add	    a
02EC: 87       [81]         add	    a
02ED: B5       [85]         or	    l
02EE: E1       [95]         pop	    hl
02EF: 6F       [99]         ld	    l, a
02F0: C9       [109]        ret
                        #endlocal
                        
                        ; uint8_t bin2hex(uint8_t val)
                        ; - converts the lower 4 bits of the 8-bit value "val" to hexadecimal (0-9,A-F)
                        #local
02F1:                   bin2hex::
02F1: 7D       [ 4]         ld	    a, l
02F2: E60F     [11]         and	    0xF
02F4: FE0A     [18]         cp	    0xA
02F6: 3804     [25|30]      jr	    c, decimal
02F8: C637     [32]         add	    'A'-10
02FA: 6F       [36]         ld	    l, a
02FB: C9       [46]         ret
02FC:                   decimal:
02FC: C630     [ 7]         add	    '0'
02FE: 6F       [11]         ld	    l, a
02FF: C9       [21]         ret
                        #endlocal
                        
                        ; uint8_t sio_getc()
                        ; - wait synchronously until a byte is available from port A, and return it
                        #local
0300:                   sio_getc::
0300:                   waitRX:
                            ; wait for an input character
0300: DB22     [11]         in	    a, (PORT_SIOACTL)
0302: CB47     [19]         bit	    SIORR0_IDX_RCA, a
0304: 28FA     [26|31]      jr	    z, waitRX
                            ; read input character
0306: DB20     [37]         in	    a, (PORT_SIOADAT)
0308: 6F       [41]         ld	    l, a
                        ;    call    seg_writehex
0309: C9       [51]         ret
                        #endlocal
                        
                        ; int8_t sio_gethex8()
                        ; - read a two-char 8-bit hex value from port A
                        ; - echoes chars as entered, erases as backspaced
                        ; - BS erases last entered char
                        ; - ESC aborts entry at any point
                        ; - CR accepts entry
                        ; - returns unsigned 8-bit value entered in L
                        ; - Z flag is set if user aborted entry, cleared otherwise
                        #local
030A:                   sio_gethex8::
030A: C5       [11]         push    bc
030B:                   getFirst:
030B: CD0003   [17]         call    sio_getc
030E: 7D       [21]         ld	    a, l
030F: FE1B     [28]         cp	    ESC
0311: 2848     [35|40]      jr	    z, abort	; Z is set, return
0313: CDB202   [52]         call    toupper
0316: CDBD02   [69]         call    isxdigit	; Z set iff is hex digit
0319: 20F0     [76|81]      jr	    nz, getFirst
031B: CDEE03   [93]         call    sio_putc	; echo digit
031E: 45       [97]         ld	    b, l	; store high digit in B
031F:                   getSecond:
031F: CD0003   [17]         call    sio_getc
0322: 7D       [21]         ld	    a, l
0323: FE1B     [28]         cp	    ESC
0325: 2834     [35|40]      jr	    z, abort	; Z is set, return
0327: FE08     [42]         cp	    BS
0329: 2005     [49|54]      jr	    nz, notBS1
032B: CDEE03   [66]         call    sio_putc	; echo BS
032E: 18DB     [78]         jr	    getFirst
0330:                   notBS1:
0330: CDB202   [17]         call    toupper
0333: CDBD02   [34]         call    isxdigit	; Z set iff is hex digit
0336: 20E7     [41|46]      jr	    nz, getSecond
0338: CDEE03   [58]         call    sio_putc	; echo digit
033B: 4D       [62]         ld	    c, l	; store low digit in C
033C:                   getThird:
033C: CD0003   [17]         call    sio_getc
033F: 7D       [21]         ld	    a, l
0340: FE1B     [28]         cp	    ESC
0342: 2817     [35|40]      jr	    z, abort	; Z is set, return
0344: FE0D     [42]         cp	    CR
0346: 2809     [49|54]      jr	    z, convert
0348: FE08     [56]         cp	    BS
034A: 20F0     [63|68]      jr	    nz, getThird
                            ; handle backspace
034C: CDEE03   [80]         call    sio_putc	; echo BS
034F: 18CE     [92]         jr	    getSecond
0351:                   convert:
0351: E5       [11]         push    hl		; save H
0352: 6069     [19]         ld	    hl, bc
0354: CDDD02   [36]         call    hex2bin2
0357: 7D       [40]         ld	    a, l
0358: E1       [50]         pop	    hl		; restore H
0359: 6F       [54]         ld	    l, a
035A: B0       [58]         or	    b		; reset Z flag by ORing in the ASCII hex digit in B
035B:                   abort:
035B: C1       [10]         pop	    bc
035C: C9       [20]         ret
                        #endlocal
                        
                        ; int16_t sio_gethex16()
                        ; - read a four-char 16-bit hex value from port A
                        ; - echoes chars as entered, erases as backspaced
                        ; - BS erases last entered char
                        ; - ESC aborts entry at any point
                        ; - CR accepts entry
                        ; - returns unsigned 16-bit value entered in HL
                        ; - Z flag is set if user aborted entry, cleared otherwise
                        #local
035D:                   sio_gethex16::
035D: C5       [11]         push    bc
035E: D5       [22]         push    de
035F:                   getFirst:
035F: CD0003   [17]         call    sio_getc
0362: 7D       [21]         ld	    a, l
0363: FE1B     [28]         cp	    ESC
0365: CAEB03   [38|38]      jp	    z, abort	; Z is set, return
0368: CDB202   [55]         call    toupper
036B: CDBD02   [72]         call    isxdigit	; Z set iff is hex digit
036E: 20EF     [79|84]      jr	    nz, getFirst
0370: CDEE03   [96]         call    sio_putc	; echo digit
0373: 45       [100]        ld	    b, l	; store digit1 in B
0374:                   getSecond:
0374: CD0003   [17]         call    sio_getc
0377: 7D       [21]         ld	    a, l
0378: FE1B     [28]         cp	    ESC
037A: 286F     [35|40]      jr	    z, abort	; Z is set, return
037C: FE08     [42]         cp	    BS
037E: 2005     [49|54]      jr	    nz, notBS1
0380: CDEE03   [66]         call    sio_putc	; echo BS
0383: 18DA     [78]         jr	    getFirst
0385:                   notBS1:
0385: CDB202   [17]         call    toupper
0388: CDBD02   [34]         call    isxdigit	; Z set iff is hex digit
038B: 20E7     [41|46]      jr	    nz, getSecond
038D: CDEE03   [58]         call    sio_putc	; echo digit
0390: 4D       [62]         ld	    c, l	; store digit2 in C
0391:                   getThird:
0391: CD0003   [17]         call    sio_getc
0394: 7D       [21]         ld	    a, l
0395: FE1B     [28]         cp	    ESC
0397: 2852     [35|40]      jr	    z, abort	; Z is set, return
0399: FE08     [42]         cp	    BS
039B: 2005     [49|54]      jr	    nz, notBS2
039D: CDEE03   [66]         call    sio_putc	; echo BS
03A0: 18D2     [78]         jr	    getSecond
03A2:                   notBS2:
03A2: CDB202   [17]         call    toupper
03A5: CDBD02   [34]         call    isxdigit	; Z set iff is hex digit
03A8: 20E7     [41|46]      jr	    nz, getThird
03AA: CDEE03   [58]         call    sio_putc	; echo digit
03AD: 55       [62]         ld	    d, l	; store digit3 in D
03AE:                   getFourth:
03AE: CD0003   [17]         call    sio_getc
03B1: 7D       [21]         ld	    a, l
03B2: FE1B     [28]         cp	    ESC
03B4: 2835     [35|40]      jr	    z, abort	; Z is set, return
03B6: FE08     [42]         cp	    BS
03B8: 2005     [49|54]      jr	    nz, notBS3
03BA: CDEE03   [66]         call    sio_putc	; echo BS
03BD: 18D2     [78]         jr	    getThird
03BF:                   notBS3:
03BF: CDB202   [17]         call    toupper
03C2: CDBD02   [34]         call    isxdigit	; Z set iff is hex digit
03C5: 20E7     [41|46]      jr	    nz, getFourth
03C7: CDEE03   [58]         call    sio_putc	; echo digit
03CA: 5D       [62]         ld	    e, l	; store digit4 in E
03CB:                   getFifth:
03CB: CD0003   [17]         call    sio_getc
03CE: 7D       [21]         ld	    a, l
03CF: FE1B     [28]         cp	    ESC
03D1: 2818     [35|40]      jr	    z, abort	; Z is set, return
03D3: FE0D     [42]         cp	    CR
03D5: 2809     [49|54]      jr	    z, convert
03D7: FE08     [56]         cp	    BS
03D9: 20F0     [63|68]      jr	    nz, getFifth
                            ; handle backspace
03DB: CDEE03   [80]         call    sio_putc	; echo BS
03DE: 18CE     [92]         jr	    getFourth
03E0:                   convert:
03E0: 6069     [ 8]         ld	    hl, bc	; HL := digit1,digit2
03E2: CDDD02   [25]         call    hex2bin2	; L := hex2bin2(digit1,digit2)
03E5: EB       [29]         ex	    de, hl	; HL := digit3,digit4 ; E := hex2bin2(digit1,digit2)
03E6: CDDD02   [46]         call    hex2bin2	; L := hex2bin2(digit3,digit4)
03E9: 63       [50]         ld	    h, e	; H := hex2bin2(digit1,digit2)
03EA: B0       [54]         or	    b		; reset Z flag by ORing in the ASCII hex digit in B
03EB:                   abort:
03EB: D1       [10]         pop	    de
03EC: C1       [20]         pop	    bc
03ED: C9       [30]         ret
                        #endlocal
                        
                        ; void sio_putc(uint8_t ch)
                        ; - write the specified character "ch" to port A
                        #local
03EE:                   sio_putc::
03EE:                   waitTX:
                            ; wait until transmitter is idle
03EE: DB22     [11]         in	    a, (PORT_SIOACTL)
03F0: CB57     [19]         bit	    SIORR0_IDX_TBE, a
03F2: 28FA     [26|31]      jr	    z, waitTX
                            ; write output character
03F4: 7D       [30]         ld	    a, l
03F5: D320     [41]         out	    (PORT_SIOADAT), a	; send byte out serial port
03F7: C9       [51]         ret
                        #endlocal
                        
                        ; void sio_puts(uint8_t *text)
                        ; - write the NUL-terminated string at "text" to port A
                        #local
03F8:                   sio_puts::
03F8: E5       [11]         push    hl
03F9: C5       [22]         push    bc
03FA:                   nextByte:
03FA: 7E       [ 7]         ld	    a, (hl)
03FB: 23       [13]         inc	    hl
03FC: B7       [17]         or	    a		; fast test a==0
03FD: 280C     [24|29]      jr	    z, done
03FF: 47       [28]         ld	    b, a
0400:                   waitTX:
                            ; wait until transmitter is idle
0400: DB22     [11]         in	    a, (PORT_SIOACTL)
0402: CB57     [19]         bit	    SIORR0_IDX_TBE, a
0404: 28FA     [26|31]      jr	    z, waitTX
                            ; write output character
0406: 78       [30]         ld	    a, b
0407: D320     [41]         out	    (PORT_SIOADAT), a	; send byte out serial port
0409: 18EF     [53]         jr	    nextByte
040B:                   done:
040B: C1       [10]         pop	    bc
040C: E1       [20]         pop	    hl
040D: C9       [30]         ret
                        #endlocal
                        
                        ; void sio_puthex8(uint8_t val)
                        ; - writes the specified 8-bit value "val" as a pair of hex digits to port A
040E:                   sio_puthex8::
040E: E5       [11]         push    hl
040F: 65       [15]         ld	    h, l
0410: CB3D     [23]         srl	    l
0412: CB3D     [31]         srl	    l
0414: CB3D     [39]         srl	    l
0416: CB3D     [47]         srl	    l
0418: CDF102   [64]         call    bin2hex
041B: CDEE03   [81]         call    sio_putc
041E: 6C       [85]         ld	    l, h
041F: CDF102   [102]        call    bin2hex
0422: CDEE03   [119]        call    sio_putc
0425: E1       [129]        pop	    hl
0426: C9       [139]        ret
                        
                        ; void seg_init()
0427:                   seg_init::
0427: AF       [ 4]         xor	    a
0428: CD8E04   [21]         call    seg0_write
042B: CD9404   [38]         call    seg1_write
042E: C9       [48]         ret
                        
                        ; void seg_writehex(uint8_t val)
                        ; - write the two hex digits of "val" to the 7-segment displays
042F:                   seg_writehex::
042F: E5       [11]         push    hl
0430: CD5604   [28]         call    seg1_writehex
0433: 7D       [32]         ld	    a, l
0434: 07       [36]         rlca
0435: 07       [40]         rlca
0436: 07       [44]         rlca
0437: 07       [48]         rlca
0438: 6F       [52]         ld	    l, a
0439: CD3E04   [69]         call    seg0_writehex
043C: E1       [79]         pop	    hl
043D: C9       [89]         ret
                        
                        ; void seg0_writehex(uint8_t val)
                        ; - write hex digit in lower nybble of "val" to 7-segment display
043E:                   seg0_writehex::
043E: E5       [11]         push    hl
043F: C5       [22]         push    bc
0440: 016E04   [32]         ld	    bc, hex2seg_table
0443: 7D       [36]         ld	    a, l
0444: E60F     [43]         and	    0xF	    ; mask off upper nybble of l
0446: 6F       [47]         ld	    l, a
0447: 2600     [54]         ld	    h, 0
0449: 09       [65]         add	    hl, bc  ; hl = hex2seg_table + (val & 0xF)
044A: 3A00FC   [78]         ld	    a, (Seg0_data)
044D: E680     [85]         and	    SEG_DP
044F: B6       [92]         or	    (hl)    ; a = (*Seg0_data & SEG_DP) | hex2seg_table[val & 0xF]
0450: CD8E04   [109]        call    seg0_write
0453: C1       [119]        pop	    bc
0454: E1       [129]        pop	    hl
0455: C9       [139]        ret
                        
                        ; void seg1_writehex(uint8_t val)
                        ; - write hex digit in lower nybble of "val" to 7-segment display
0456:                   seg1_writehex::
0456: E5       [11]         push    hl
0457: C5       [22]         push    bc
0458: 016E04   [32]         ld	    bc, hex2seg_table
045B: 7D       [36]         ld	    a, l
045C: E60F     [43]         and	    0xF	    ; mask off upper nybble of l
045E: 6F       [47]         ld	    l, a
045F: 2600     [54]         ld	    h, 0
0461: 09       [65]         add	    hl, bc  ; hl = hex2seg_table + (val & 0xF)
0462: 3A01FC   [78]         ld	    a, (Seg1_data)
0465: E680     [85]         and	    SEG_DP
0467: B6       [92]         or	    (hl)    ; a = (*Seg1_data & SEG_DP) | hex2seg_table[val & 0xF]
0468: CD9404   [109]        call    seg1_write
046B: C1       [119]        pop	    bc
046C: E1       [129]        pop	    hl
046D: C9       [139]        ret
                        
046E:                   hex2seg_table::
                            ; 0
046E: 3F                    .byte SEG_A | SEG_B | SEG_C | SEG_D | SEG_E | SEG_F
                            ; 1
046F: 06                    .byte SEG_B | SEG_C
                            ; 2
0470: 5B                    .byte SEG_A | SEG_B | SEG_G | SEG_E | SEG_D
                            ; 3
0471: 4F                    .byte SEG_A | SEG_B | SEG_G | SEG_C | SEG_D
                            ; 4
0472: 66                    .byte SEG_F | SEG_G | SEG_B | SEG_C
                            ; 5
0473: 6D                    .byte SEG_A | SEG_F | SEG_G | SEG_C | SEG_D
                            ; 6
0474: 7D                    .byte SEG_A | SEG_F | SEG_G | SEG_C | SEG_D | SEG_E
                            ; 7
0475: 07                    .byte SEG_A | SEG_B | SEG_C
                            ; 8
0476: 7F                    .byte SEG_A | SEG_B | SEG_C | SEG_D | SEG_E | SEG_F | SEG_G
                            ; 9
0477: 6F                    .byte SEG_A | SEG_B | SEG_C | SEG_D | SEG_F | SEG_G
                            ; A
0478: 77                    .byte SEG_A | SEG_B | SEG_C | SEG_E | SEG_F | SEG_G
                            ; b
0479: 7C                    .byte SEG_F | SEG_G | SEG_C | SEG_D | SEG_E
                            ; C
047A: 39                    .byte SEG_A | SEG_D | SEG_E | SEG_F
                            ; d
047B: 5E                    .byte SEG_B | SEG_C | SEG_D | SEG_E | SEG_G
                            ; E
047C: 79                    .byte SEG_A | SEG_D | SEG_E | SEG_F | SEG_G
                            ; F
047D: 71                    .byte SEG_A | SEG_E | SEG_F | SEG_G
                        
                        ; void seg0_toggle(uint8_t bits)
                        ; - toggle specified bits of first 7-segment display register
047E:                   seg0_toggle::
047E: 3A00FC   [13]         ld	    a, (Seg0_data)
0481: AD       [17]         xor	    l
0482: CD8E04   [34]         call    seg0_write
0485: C9       [44]         ret
                        
                        ; void seg1_toggle(uint8_t bits)
                        ; - toggle specified bits of second 7-segment display register
0486:                   seg1_toggle::
0486: 3A01FC   [13]         ld	    a, (Seg1_data)
0489: AD       [17]         xor	    l
048A: CD9404   [34]         call    seg1_write
048D: C9       [44]         ret
                        
                        ; void seg0_write(uint8_t bits)
                        ; - parameter passed in A
                        ; - write raw bits to first 7-segment display register
048E:                   seg0_write::
048E: 3200FC   [13]         ld	    (Seg0_data), a
0491: D300     [24]         out	    (PORT_SEG0), a
0493: C9       [34]         ret
                        
                        ; void seg1_write(uint8_t bits)
                        ; - parameter passed in A
                        ; - write raw bits to second 7-segment display register
0494:                   seg1_write::
0494: 3201FC   [13]         ld	    (Seg1_data), a
0497: D310     [24]         out	    (PORT_SEG1), a
0499: C9       [34]         ret
                        
                        ; void delay_ms(uint8_t ms)
                        ; - delay for at least the specified number of milliseconds
                        #local
049A:                   delay_ms::
049A: 2C       [ 4]         inc	    l
049B: 2D       [ 8]         dec	    l
049C: C8       [13|19]      ret	    z		; delay of 0 returns immediately
049D: C5       [24]         push    bc
049E: 45       [28]         ld	    b, l
049F:                   loop:
049F: CDA604   [17]         call    delay_1ms
04A2: 10FB     [25|30]      djnz    loop
04A4: C1       [35]         pop	    bc
04A5: C9       [45]         ret
                        #endlocal
                        
                        ; void delay_1ms()
                        ; - delay for 1ms (technically, 0.9999ms)
                        #local
04A6:                   delay_1ms::
04A6: C5       [11]         push    bc		; 11 T-states
                        ; To delay 1ms, we want to wait 10,000 T-states (@10MHz)
                        ; The loop is (38*b + 13*(b-1) + 8) T-states long
                        ; Rearranging: 51*b - 5
                        ; Solve for b: b = (10000 + 5 / 51) = 196.17
04A7: 06C3     [18]         ld	    b, 195	; 7 T-states
04A9:                   loop:
04A9: DD7E01   [19]         ld	    a, (ix+1)	; 19 T-states
04AC: DD7E01   [38]         ld	    a, (ix+1)	; 19 T-states
04AF: 10F8     [46|51]      djnz    loop	; (b-1)*13+8 T-states
04B1: C1       [56]         pop	    bc		; 10 T-states
04B2: 00       [60]         nop			; 4 T-states
04B3: C9       [70]         ret			; 10 T-states
                        ; We also assume the routine is CALLed, for 17 T-states.
                        ; Total delay is therefore:
                        ;   17 + 11 + 7 + 51*195 - 5 + 10 + 4 + 10 = 9,999
                        #endlocal
                        
                        ; Remaining 56KB and 64KB segments to fill up ROM image
0000:                   #code FILLER1, 0, 0xE000
0000:                   #code FILLER2, 0, 0x10000


total time: 0.0157 sec.
no errors
